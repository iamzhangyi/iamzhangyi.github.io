<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《解构领域驱动设计》前言</title>
    <url>/Preface-of-DDD-Explained/</url>
    <content><![CDATA[<p>写下本书内容第一个字的具体时间已不可考，从文档创建的时间看，本书的写作至少可以追溯到2017年11月，屈指算来，距今已是三载光阴流逝而过，为了本书，我已算得上呕心沥血。回想这悠悠三年，无论在万米高空的飞行途中，还是在蔚蓝海边的栖息之旅，抑或工作之余正襟危坐书桌之前，我的心弦一刻不敢放松，沉思于体系的构建，纠结于案例的选择，锱铢必较于每个文字的运用，我力求输出最好的文本，希望打造领域驱动设计技术书籍的经典！</p>
<p>我在ThoughtWorks的前同事滕云开我的玩笑，说：“老人家，你写完这本书，也就功德圆满了！”老人家是我在ThoughtWorks的诨名，虽然我对此称呼一直敬谢不敏，不过写作此书至今，我已心力交瘁，老人家的称谓也算名实相副了，至于是否“功德圆满”，就要交给读者诸君来品评了。本书内容主要来自我在GitChat发布的课程《领域驱动设计实践》。该课程历经两年，完成于2020年1月21日。当时的我，颇有感慨地写下如此后记：</p>
<blockquote>
<p>课程写作结束了。战略篇一共 34 章，15 万 5 千字；战术篇一共 71 章，35 万 1 千字；合计 105 章，共 50 万 6 千余字，加上两篇开篇词与这篇可以称为写后感的后记，共108 章，算是凑齐了一百单八将。如此成果也足可慰藉我为之付出的两年多艰辛时光！</p>
</blockquote>
<p>我对《领域驱动设计实践》课程的内容还算满意，然而，随着我对领域驱动设计理解的蜕变与升华，我的“野心”也在不断膨胀，不仅希望讲清楚该如何实践领域驱动设计，还企图对这套方法体系进行深层次的解构。这也是本书书名《解构领域驱动设计》得名的由来。</p>
<span id="more"></span>

<p>所谓“解构”，就是解析与重构：</p>
<ul>
<li>解析，就是要做到知其然更知其所以然</li>
<li>重构，则要做到青出于蓝而胜于蓝</li>
</ul>
<p>我钦佩并且尊敬Eric Evans对领域驱动设计革命性的创造，他对设计的洞见至今让我赞赏不已，尤其在我彻底吃透限界上下文的本质之后，结合微服务之大行其道，更让我彻底佩服他的远见卓识；然而，尊敬不是膜拜，佩服并非盲从，在实践领域驱动设计过程中，我确实发现了这套方法体系天生存在的不足，于是，我在本书提出了GitChat课程不曾涵盖的领域驱动设计统一过程（Domain-Driven Design Unified Process），相当于站在Eric Evans的巨人肩膀上，我构建了自己的一套领域驱动设计知识体系。</p>
<p>领域驱动设计统一过程的提出，从根基上改变了本书的结构，我调整和梳理了写作的脉络，呈现出与《领域驱动设计实践》课程迥然有别的全新面貌，整本书不再满足于粗略地将内容划分为战略篇和战术篇，而是在领域驱动设计统一过程的指导下，将该过程的全部三个阶段作为本书的三个核心篇章：全局分析、架构映射与领域建模，再辅以开篇和融合，共分为五篇二十五章，全面而完整地表达了我对领域驱动设计的全部认知与最佳实践。在对内容做进一步精简后，本书仍然达到了43万余字，算得上是软件技术类别的大部头著作了。</p>
<p>该如何阅读这样一本厚书？</p>
<p>若你时间足够充裕，又渴望彻底探索领域驱动设计的全貌，建议还是按部就班、循序渐进地开始你的阅读之旅。或许在阅读开篇的三个章节时，你会因为太多信息量的一次性涌入，产生迷惑、困扰和不解，那只是因为我期望率先为读者呈现领域驱动设计的整体面貌，在获得整体印象之后，哪怕只是在脑海中存留了如雾一般朦胧的轮廓，也足以指导你开启对设计细节的理解和认识。</p>
<p>若你追求高效阅读，又渴望寻求困惑于领域驱动设计问题的答案，当然可以根据目录按图索骥，精准定位你最为关心的技术讲解。或许你会失望，甚至产生质疑，从目录中你获得了太多全新的概念，而这些概念从未见诸于任何一本领域驱动设计的书籍，那只是因为这些概念都是我针对领域驱动设计提出的改进与补充，它们是我解构全新领域驱动设计知识体系的得意之笔。——要不然，一本技术书籍怎么会写三年之久呢？</p>
<p>我自鸣得意的开创性概念一一罗列于此：</p>
<ul>
<li>业务活动：它是全局分析的基本业务单元，在统一语言的指导下完成对业务需求的抽象，既可帮助我们识别限界上下文，对它的细节分析还可以帮助开发团队开展领域分析建模、领域设计建模和领域实现建模；业务活动的粒度也是服务契约的粒度，由此拉近了需求分析与软件设计的距离，甚至可以说打通了需求分析与软件设计的鸿沟。</li>
<li>菱形对称架构：虽然该模式脱胎于整洁架构与六边形架构，但它更为简洁，与限界上下文的搭配可谓珠联璧合，既保证了限界上下文作为基本架构单元的自治性，又融入了上下文映射的通信模式，极大了丰富了设计元素的角色构造型。</li>
<li>场景驱动设计：采用过程式的设计思维，却又遵循面向对象的职责分配，从而在提高设计质量的同时降低了开发团队的设计门槛，完成了从领域分析模型到领域实现模型的无缝转换，并可作为测试驱动开发的前奏，让领域逻辑的实现变得更加稳健而高效。</li>
</ul>
<p>以上概念皆为领域驱动设计统一过程的设计元素，同时又能与领域驱动设计的固有模式有机融合。至于我对软件复杂度成因的剖析，对价值需求和业务需求的划分，在领域驱动设计统一过程基础上建立的领域驱动设计魔方、参考过程模型与能力评估模型，诸多新概念、新方法、新模式、新体系虽说都出自我的一孔之见，但自觉可圈可点，确乎来自于我的一线实践和总结。至于内容的优劣，还是交给读者诸君来品判吧。</p>
<p>照例表示致谢！</p>
<p>感谢GitChat创始人谢工女士，没有她的支持与鼓励，就不会有《领域驱动设计实践》课程的诞生，自然不会让我下定决心撰写本书。感谢人民邮电出版社异步图书的杨海玲女士，是她的宽容与耐心，使得我能够有足够充裕的时间精心打磨本书的内容，没有因为错过最好的出版时间窗口，而催促我逼迫我尽快交稿。感谢京东周吉鑫、Amazon高翊凱 (Kim, Kao) 、腾讯王立、阿里蚂蚁金服于君泽（花名右军）与ThoughtWorks王威诸兄的抬爱，不仅拨冗为我的著作写序，也给予了许多好的建议与指点，提升了本书的整体质量。感谢阿里的彭佳斌（花名言武）、自主创业人张闯、中航信杨成科、工商银行劳永安，四位兄台作为本书试读的第一批读者，花费了大量时间认真阅读了我的初稿，提出了非常宝贵的反馈意见，帮助我订正了不少错误。感谢我的领域驱动设计技术交流群，近1500名群友的耐心等待以及坚持不懈的催促，使得我能够坚持写完本书。</p>
<p>之所以“三年磨一剑”，是希望通过我的努力让本书的质量对得起读者！可是，在态度上对得起读者的同时，我却对不起我生命中最重要的两个人：我的妻子漆茜与儿子张子瞻。这三年经历了风雨阳光，很遗憾，我把大部分业余时间都交给了《解构领域驱动设计》，多少个晚上笔耕不缀，妻子陪着儿子，我则陪着电脑。为了支持我的创作，没有怨怼，只有默默的支持。本书的出版，有他们一大半的功劳！最后，还要感谢我的父母，每次匆匆回家看望他们，极短的时间和他们聊天，挤出来的时间都留给本书的写作了！</p>
<p>在写作本篇前言的前一天，我偶然读到苏东坡的一首小词：<br>春未老，风细柳斜斜。试上超然台上看，半壕春水一城花。烟雨暗千家。<br>寒食后，酒醒却咨嗟。休对故人思故国，且将新火试新茶。诗酒趁年华。</p>
<p>蓦然内心被叩击，仿佛心弦被优美的辞章轻轻地带着诗意拨弄。吾身虽不能上超然台，然而书成之后，是否能够看到半壕春水一城花呢？未曾饮酒，却咨嗟，是否多情笑我早生华发？如今的我，已然焙出新火，恰当新火试新茶，却不知待到明年春未老时，能否做到何妨吟啸且徐行的落拓不羁？不管如何，还当诗酒趁年华，如此当——仰天大笑出门去，吾辈岂是蓬蒿人!</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>领域场景分析的6W模型</title>
    <url>/6w-model-based-on-scenario/</url>
    <content><![CDATA[<img src="/6w-model-based-on-scenario/logo.jpg" class="">

<p>在软件构造过程中，我们必须正确地理解领域。一种生动的方式是通过“场景”来展现领域逻辑。领域专家或业务分析师从领域中提炼出“场景”，就好像是从抽象的三维球体中，切割出具体可见的一片。然后以这一片场景为舞台，上演各种角色之间的悲欢离合。每个角色的行为皆在业务流程的指引下展开活动，并受到业务规则的约束。当我们在描述场景时，就好像在讲故事，又好似在拍电影。</p>
<span id="more"></span>

<p>组成场景的要素常常被称之为<strong>6W模型</strong>，即描写场景的过程必须包含<strong>W</strong>ho，<strong>W</strong>hat，<strong>W</strong>hy，<strong>W</strong>here，<strong>W</strong>hen与ho<strong>W</strong>这六个要素。6W模型如下图所示：</p>
<img src="/6w-model-based-on-scenario/6w.png" class="">

<p>通过场景分析领域需求时，我们需要首先识别参与该场景的用户角色。我们可以为其建立用户画像（Persona），通过分析该用户的特征与属性辨别该角色在整个场景中参与的活动。这意味着我们需要明确业务功能（what），思考这一功能给该角色能够带来什么样的业务价值（why）。注意，这里所谓的“角色”是参差多态的，同一个用户在不同场景可能是完全不同的角色。例如在电商系统中，倘若执行的是下订单功能，则角色就是买家；针对该订单发表评论，参与的角色就变成了评论者。</p>
<p>在6W模型中，我将领域功能划分为三个层次，即业务价值、业务功能和业务实现，我将其称之为“职责的层次”。定义为“职责（Responsibility）”，才能够更好地体现它与角色之间的关系，即“角色履行了职责”。业务价值体现了职责存在的目的，即解释了该领域需求的Why。只有提供了该职责，这个场景对于参与角色才是有价值的。为了满足业务价值，我们可以进一步剖析为了实现该价值需要哪些支撑功能，这些业务功能对应6W模型中的What。进一步，我们对功能深入分析，就可以分析获得具体的业务实现。业务实现关注于如何去实现该业务价值，因而对应于hoW。</p>
<p>在电商系统中购买商品时，对于买家而言，<strong>下订单</strong>这一职责是具有业务价值的。通过领域分析，结合职责的层次概念，我们就可以得到如下的职责分层结构：</p>
<ul>
<li>下订单<ul>
<li>验证订单是否有效<ul>
<li>验证订单是否为空</li>
<li>验证订单信息是否完整</li>
<li>验证订单当前状态是否处于“待提交”状态</li>
<li>验证订单提交者是否为合法用户</li>
<li>验证商品库存量是否大于等于订单中的数量</li>
</ul>
</li>
<li>基于业务规则计算订单总价、优惠与配送费<ul>
<li>获取用户信息</li>
<li>获取当前促销规则</li>
<li>计算订单总价</li>
<li>计算订单优惠</li>
<li>计算商品配送费</li>
</ul>
</li>
<li>提交订单<ul>
<li>将订单项插入到数据表中</li>
<li>将订单插入到数据表中</li>
<li>更新订单状态为“待付款”</li>
</ul>
</li>
<li>发送通知<ul>
<li>给买家发送电子邮件，通知订单提交成功，等待付款</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>当我们获得这样的职责层次结构之后，就可以帮助我们更加细致地针对领域进行建模。在利用场景进行建模时，还要充分考虑场景的边界，即6W模型中的Where。例如在“下订单”的案例中，验证商品库存量的业务实现需要调用库存提供的接口，而该功能实则属于下订单场景的边界之外。领域驱动设计引入了<strong>限界上下文（Bounded Context）</strong>来解决这一问题。</p>
<p>针对问题域提炼领域知识是一个空泛的概念，业务场景分析的6W模型给出了具有指导意义的约束，要求我们提炼的领域知识必须具备模型的六个要素。这就好比两位侃侃而谈的交谈者，因为有了确定的主题与话题边界，一场本来是漫无目的野鹤闲云似的闲聊就变成了一次深度交流的专题高端对话。6W模型也是对领域逻辑的一种检验，如果提炼出来的领域逻辑缺乏部分要素，就有可能忽略一些重要的领域概念、规则与约束。这种缺失会对后续的领域建模直接产生影响。正本清源，按照领域场景分析的6W模型去分析领域逻辑，提炼领域知识，可以从一开始在一定程度上保证领域模型的完整性。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Requirement</tag>
      </tags>
  </entry>
  <entry>
    <title>《解构领域驱动设计》最新进展</title>
    <url>/Report-the-progress-of-DDDE/</url>
    <content><![CDATA[<img src="/Report-the-progress-of-DDDE/cover.jpg" class="">



<p>不出意外，《解构领域驱动设计》再次延期，完全符合一般软件开发的惯例。 </p>
<p>我来汇报一下本书临近出版的一条时间线。</p>
<p>5月31日，出版社编辑刘雅思同学告知我本书正式申领到书号，标志着本书正式发稿完毕。这个流程是必走的，否则就别想通过正规出版社出版了。之后的流程就是排版。 因为书的内容非常多，排版花费了不少时间。</p>
<span id="more"></span>

<p>6月9日，编辑发给我设计后的封面初稿，针对封面的文字内容与作者简介做了沟通后，在6月10日确定了封面的最终版本。</p>
<img src="/Report-the-progress-of-DDDE/book-cover.png" class="">



<p>当天同时确定了本书排版的版式，基本上和人邮版Eric Evans《<a href="https://wx.zsxq.com/mweb/views/weread/search.html?keyword=%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1">领域驱动设计</a>》保持了相似的排版格式，并在其基础上做了微调。 6月15日，编辑发给我排版后的书稿样章，并告知我书稿已经排版完毕，开始校对。</p>
<img src="/Report-the-progress-of-DDDE/draft-01.png" class="">

<img src="/Report-the-progress-of-DDDE/draft-02.png" class="">

<p>按照出版社规定的流程，校对环节包含三个校次，也就是说，<strong>需要出版社的编辑同学把45万字、660页的书稿从头到尾通读一遍</strong>，可想这个工作量及其需要花费的时间。 为了保证质量，我要求出版社在完成一次校对后，还需要发稿给我，由我针对本书内容做最后一次作者的审校。</p>
<p>为了提升效率，编辑在6月15日直接给了我一个排版的初稿，我在此稿基础上进行技术审校。</p>
<p>从当初交付最终书稿，由出版社完成内审，再到现在做最后一次审校，大概过去了一个月时间。就在此期间，根据我在工作上遇见的问题，反思书中的内容，又不断发现部分内容的不足之处。——事实上，天下哪有尽善尽美的书籍呢？——我不愿将这些不足留到后来的版本，因此在最后一次技术审校时，为追求完美，对书稿又做了一些调整。 </p>
<img src="/Report-the-progress-of-DDDE/review-01.png" class="">

<p>调整内容包括：</p>
<ol>
<li><p>对第3章内容做了较大改动。该章节规定了领域驱动设计统一过程每个阶段需要输出的交付物，为了便于读者参考，我特地为全局分析阶段与架构映射阶段提供了交付文档的模板，作为一个相对完整的内容放到了本书的附录中，即增加了新的一章附录D。</p>
</li>
<li><p>第12章的12.1.9做了调整，修改了服务契约列表的内容。 </p>
</li>
<li><p>第15章发现代码中存在技术错误，之前未曾注意，这次对代码做了修改。 </p>
</li>
<li><p>删去了部分啰嗦的语句和字词，发现了个别小错误，都一一做了订正。 </p>
</li>
</ol>
<img src="/Report-the-progress-of-DDDE/review-02.png" class="">

<p>这次审校又花费了我不少时间，从6月15日收到书稿开始，每天晚上都在进行书稿阅读，实话实说，我读自己的书稿都读到要吐的地步。</p>
<p>从去年完成整个书稿至今，我前前后后对书稿<strong>做了不下于5次的全面审校</strong>，如此算来，所读文字加起来合计230万字了，关键在于这样的阅读在于反复嚼甘蔗，已经没有任何味道了，能不吐么？</p>
<p>终于，公元2021年6月25日，我完成了这最后一次技术审校——在拿到出版的纸质书之前，我不打算再看我的书稿了！</p>
<p>目前，出版社还在按照出版的规定动作紧张地进行校对工作，一旦校对完毕，就可以付诸印刷了，估计时间，本书在七月应该能够出版。我想，这次绝对不会再次延期了。</p>
<p>抱歉了，诸位读者！感谢你们的耐心！为表感谢，我会在我的微信公众号与知识星球上陆续给出本书的样章，因为内容太多而被删减的部分内容也会陆续揭秘。</p>
]]></content>
      <categories>
        <category>Writing</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title>对Flink流处理模型的抽象</title>
    <url>/abstract-streaming-model-on-flink/</url>
    <content><![CDATA[<img src="/abstract-streaming-model-on-flink/cover.jpg" class="">

<p>我们开发的一个基于大数据平台的数据仓库，选择了Flink作为数据处理的底层框架。我们主要看重于它在流处理的低延迟性，消息传递保证的extractly once特性；它为流处理和批处理提供了相对统一的API，支持Java、Scala和Python等主流开发语言，同时还较好地支持了SQL。Flink搭建了非常棒的基础设施，例如它可以和ZooKeeper、YARN集成起来，保证处理功能的高可用性与水平扩展的集群能力，同时还提供了相对开放的扩展能力，使得我们可以较容易地在已有功能基础之上实现定制开发。</p>
<span id="more"></span>

<p>我们基于Flink开发了自己的底层框架“海纳（haina）”，这是取“海纳百川有容乃大”之意。haina以库的形式为我们的产品提供了数据采集、治理和共享等功能，是整个平台最核心的数据处理基础设施，逻辑架构如下图所示：</p>
<img src="/abstract-streaming-model-on-flink/01.png" class="">

<h3 id="抽象的流处理模型"><a href="#抽象的流处理模型" class="headerlink" title="抽象的流处理模型"></a>抽象的流处理模型</h3><p>由于我们的产品对数据的处理主要包括三个方面：采集、治理与共享，这之间流转的皆为采集器从上游系统采集获得的数据。我们结合Flink的架构，并参考了Apex、Storm、Flume等其他流处理框架，抽象出自己的流处理模型。这个模型中各个概念之间的关系与层次如下图所示：</p>
<img src="/abstract-streaming-model-on-flink/02.png" class="">

<p>在这个流处理模型中，一个Job对应一个实际的物理环境（Environment）。多数情况下，为了保证Job运行的独立性，可以为每个Job分配一个单独的运行节点，提供专有的运行资源。每个Job核心的逻辑概念是Flow，它由Source、Processor和Sink组成，它们都是Flink的Operator，其中Processor对应于Flink的Transformation Operator。在实时流处理中，一个典型的Processor其实就是我们常用的map、filter或flatMap函数。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArchiveJsonMetaProcessor</span> <span class="keyword">implements</span> <span class="title">MapFunction</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArchiveJsonMetaProcessor</span><span class="params">(String target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        JSONObject message = JSONObject.parseObject(msg);</span><br><span class="line">        String messageId = message.getString(<span class="string">&quot;messageId&quot;</span>);</span><br><span class="line">        String originTimestamp = message.getString(<span class="string">&quot;originalTimestamp&quot;</span>);</span><br><span class="line">        String archivedTimestamp = DateUtil.transformTime(<span class="keyword">new</span> Date(), DateUtil.YYYYMMDDHHMMSSS);</span><br><span class="line">        ArchivedMetaData archivedMetaData = ArchivedMetaData.fillArchivedMetaData(messageId, target, originTimestamp, archivedTimestamp);</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(archivedMetaData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Processor的设计原则"><a href="#Processor的设计原则" class="headerlink" title="Processor的设计原则"></a>Processor的设计原则</h3><p>我们之所以要抽象出Processor概念，是因为我们遵循了管道-过滤器模式，希望每个operator都是一个最小的可以重用的逻辑单元。管道就是我们定义的Flow，Source是管道的上游入口，Sink是管道的下游出口，每个细粒度的Processor就是每个负责处理数据流的过滤器。我们的底层框架haina实现了这些逻辑单元，至于它们该如何组装，则交由框架的使用者。正因为此，我们制定了Processor的设计原则，其根本思想就是保持Processor的细粒度，严格分离与业务无关和有关的Processor，保证Processor在组成Flow时尽可能被重用。</p>
<p>如下为设计Processor应该遵循的原则：</p>
<ul>
<li>业务上对数据流的处理可以拆分为多个阶段，每个Processor对应一个阶段。</li>
<li>尽可能把有副作用的和无副作用的职责分离到不同的Processor。</li>
<li>把需要访问外部资源的职责尽可能分离到不同的Processor。</li>
<li>尽可能确保Processor的代码短小，这样可以保证将Processor真正的职责转移到别的类，例如对象的转换逻辑。转移出去的类与Flink平台无关，有利于编写和运行单元测试。</li>
<li>每个Processor的上游与下游，即<code>MapFunction</code>或其他接口对应的类型参数<code>T</code>与<code>O</code>，应尽量采用平台定义的模型对象，而非如String之类的基础类型。这样就能保证调用者对Processor进行组装时，通过编译就能检查到不必要的组装错误。</li>
<li>每个Processor的命名采用动宾短语，并以Processor作为类的后缀。例如将一条航班信息拆分成多个机位信息，命名为<code>SplitFlightToStandsProcessor</code>。好的命名可以帮助我们更容易发现它，进而促进调用者对它的重用。例如在IntelliJ中，就可以直接以<code>*Processor</code>来搜索所有的Processor，然后根据它的命名就能推测出这个Processor到底是做什么的。</li>
<li>每个Processor需要的外部数据，都通过Processor的构造函数来传递。</li>
<li>每个Processor都应该实现Flink提供的transfomation接口。</li>
<li>第一个Processor接收的是<code>String</code>类型的消息，则要求必须对传入的消息进行验证。用于验证的Processor应该实现<code>FilterFunction&lt;String&gt;</code>。</li>
<li>应保证每个Processor都不要抛出出人意料不可控制的异常，否则可能导致执行Job时出现错误从而导致整个Application停止或者重启。</li>
</ul>
<h3 id="自定义Source与Sink"><a href="#自定义Source与Sink" class="headerlink" title="自定义Source与Sink"></a>自定义Source与Sink</h3><p>针对Source与Sink，除了重用Flink本身提供的source与sink之外，我们还开发了大量的满足自己需求的自定义Source与Sink。例如，我们为独立开发的ESB系统提供了Source，为关系型数据库和WebService提供了具有轮询能力的Source，为ElasticSearch开发了满足批量添加数据的Sink，同时还实现了具有回调能力的自定义Sink。如下就是针对Oracle编写的具有轮询能力的自定义Source：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OracleClobSource</span> <span class="keyword">extends</span> <span class="title">RichSourceFunction</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(OracleClobSource.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcGateway jdbcGateway;</span><br><span class="line">    <span class="keyword">private</span> Long period;</span><br><span class="line">    <span class="keyword">private</span> DSLContext executor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OracleClobSource</span><span class="params">(JdbcGateway jdbcGateway, Long period)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcGateway = jdbcGateway;</span><br><span class="line">        <span class="keyword">this</span>.period = period;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        executor = jdbcGateway.executor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;String&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Result&lt;Record&gt; results = executor.select().from(table(tableName)).where(rownum().le(<span class="number">10</span>)).fetch();</span><br><span class="line">            <span class="keyword">for</span> (Record record : results) &#123;</span><br><span class="line">                String msgcontext = record.get(field(filedName), String.class);</span><br><span class="line">                ctx.collect(msgcontext);</span><br><span class="line">                Long id = record.get(field(<span class="string">&quot;ID&quot;</span>), Long.class);</span><br><span class="line">                executor.delete(table(tableName)).where(field(<span class="string">&quot;ID&quot;</span>).equal(id)).execute();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(period);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        executor.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了便于使用，我们还为这些内置与定制source和sink分别定义了静态工厂。</p>
<h3 id="Flow与Job"><a href="#Flow与Job" class="headerlink" title="Flow与Job"></a>Flow与Job</h3><p>Flow相当于是传递DataStream的拓扑图，由Source、Processor和Sink组成。我们之所以引入这个概念，一方面是为Job提供更粗粒度的重用单元，另一方面也承担了封装业务流程的主要职责。例如，一个航班数据从上游系统进入我们的大数据平台，需要进行多次数据格式的转换、验证与治理，我们就可以定义一个FlightFlow来完成这些细小职责的组装：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlightFlow</span> <span class="keyword">extends</span> <span class="title">AbstractFlow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlightFlow</span><span class="params">(Environment env, Config config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(env, config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLIGHT = <span class="string">&quot;flight&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DataStream&lt;String&gt; source = env.addSource(sourcesFactory.createSslKafkaSource(<span class="string">&quot;INBOUND&quot;</span>));</span><br><span class="line">        SingleOutputStreamOperator flightStream = source</span><br><span class="line">                .filter(<span class="keyword">new</span> FilterFlightProcessor())</span><br><span class="line">                .map(<span class="keyword">new</span> TransformXmlToJsonProcessor())</span><br><span class="line">                .map(<span class="keyword">new</span> TransformJsonStringToJsonObjectProcessor())</span><br><span class="line">                .map(<span class="keyword">new</span> TransformJsonMessageToFlightsProcessor())</span><br><span class="line">                .map(<span class="keyword">new</span> FlattenDomainModelProcessor());</span><br><span class="line"></span><br><span class="line">        flightStream</span><br><span class="line">                .map(<span class="keyword">new</span> DeletedDiscusedRecordsProcessor(DETAIL, FLIGHT))</span><br><span class="line">                .map(<span class="keyword">new</span> DeleteFullModelProcessor(DETAIL, FLIGHT))</span><br><span class="line">                .map(<span class="keyword">new</span> InsertFullModelProcessor(DETAIL, FLIGHT))</span><br><span class="line">                .map(<span class="keyword">new</span> UpdateChangedRecordsProcessor(DETAIL, FLIGHT))</span><br><span class="line">                .map(<span class="keyword">new</span> TransformModelToEventProcessor())</span><br><span class="line">                .map(<span class="keyword">new</span> TransformObjectToJsonProcessor())</span><br><span class="line">                .addSink(sinksFactory.createSslKafkaSink(<span class="string">&quot;trigger&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Job与Flow之间的关系是一对多关系。这种关系可以根据资源情况与业务需求的不同随时调整。因而我们引入配置方式来保证这种灵活性。Job是一个容器，通过它可以传入Flink Job的执行环境，然后在配置文件中配置Job与Flow之间的关系。如下配置文件就是为数据探针任务配置的Job，它包含了三个完全不同的Flow，运行同一个Flink集群上：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">job</span> <span class="attr">name</span>=<span class="string">&quot;AirportToKafkaJob&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">flow</span> <span class="attr">name</span>=<span class="string">&quot;FlightToKafkaFlow&quot;</span> <span class="attr">flowClassName</span>=<span class="string">&quot;haina.airprobe.flow.FlightToKafkaFlow&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">flow</span> <span class="attr">name</span>=<span class="string">&quot;PassengerToKafkaFlow&quot;</span> <span class="attr">flowClassName</span>=<span class="string">&quot;haina.airprobe.flow.PassengerToKafkaFlow&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">flow</span> <span class="attr">name</span>=<span class="string">&quot;AcdmToKafkaFlow&quot;</span> <span class="attr">flowClassName</span>=<span class="string">&quot;haina.airprobe.flow.AcdmToKafkaFlow&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">job</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="内核与外部应用"><a href="#内核与外部应用" class="headerlink" title="内核与外部应用"></a>内核与外部应用</h3><p>haina在针对flink的流处理模型进行了抽象和扩展开发后，就形成了围绕flink为核心的逻辑架构。如下图所示：</p>
<img src="/abstract-streaming-model-on-flink/03.png" class="">

<p>flink是haina的核心，提供了基本的运算、运行和部署的能力，而haina则根据我们产品的需求对flink进行扩展，并遵循前面提及的抽象流处理模型提供各个可以被重用的细粒度组成单元，并实现了通用的组成逻辑，简化了开发工作量。图中所示的air-probe、air-jobs等模块满足不同的数据处理功能。这些模块都是建立在haina之上薄薄的一层应用，只需要创建满足业务流程处理的Flow，并配置Flow与Job的关系即可。</p>
<p>同时，我们还自行开发了一套配置框架，可以简化整个大数据平台要使用到的外部资源，包括YARN、Flink、Kafka、ElasticSearch、RabbitMQ、ZooKeeper等，并在AbstractJob中完成了Flink执行环境与具体Job之间的绑定以及对外部环境的使用。</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Streaming</tag>
        <tag>Big Data</tag>
        <tag>Flink</tag>
        <tag>Architecture</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>关于《恰如其分的软件架构》</title>
    <url>/about-just-enough-soft-arch/</url>
    <content><![CDATA[<img src="/about-just-enough-soft-arch/just-enough.jpg" class="">
<p>昨天，久（shi）违（san）多年的华中科技大学出版社徐定翔兄，以近乎于地下党接头的曲折方式联系上我。徐兄送来了好消息：“《恰如其分的软件架构》这两年又销售了近1000册，可以给<strong>大家</strong>申请1000册稿酬。”稿酬自然不多，但没想到这本译作过了如许几年，销量还能缓慢增长，令我惊喜。</p>
<span id="more"></span>

<p>消息中提及的<strong>大家</strong>，乃《恰如其分的软件架构》翻译三人组，即审校高翌翔，翻译倪健和我。我认识翌翔是通过InfoQ，当时我们同为InfoQ的兼职编辑，在北京有几次谋面。翌翔对技术的热爱令我印象颇深。倪健兄则属于神交，从未谋面。我是在拜读他的大作《<a href="https://book.douban.com/subject/4714092/">简单之美</a>》后，深感一个IT人能把文字写得如此动人，从而滋生“拉他下水”的想法。记得倪健兄定居上海，被我拉下水后，快手译书，倚马可待，终于使得本书的译作能够如期面试。遗憾的是，后来随着我工作变动、工作地点变动，翻译三人组慢慢失去了联系。回想起来，还是令我唏嘘不已。</p>
<p>翻译Just Enough Software Architecture时，我在Thoughtworks就职，relocation在北京，居住在靠近东直门的蜗居内。每日公司宿舍两点一线，过着简朴而又纯粹的生活。过去的回忆一下子又在脑海中鲜活呈现。这篇博客是我写于2013年的旧文，真实记录了当初译稿交付后的点滴感受，叙述了当初翻译的艰难历程。如今发布出来，颇有些“忆往昔峥嵘岁月”的感觉。——是为记。</p>
<hr>
<p>华中科技大学出版社的徐定翔问我意见，了解我对Just Enough Software Architecture这本书的观感，看是否值得引进。时间是在2010年。从一开始，我就被书名中的Just Enough理念所吸引。它让我想起宋玉的东家姑娘，“增之一分则太长，减之一分则太短”那种不可言说的美丽。我在心里说，架构设计就需要这样。我当时并没有看到本书，只是到Amazon上找到了几篇英文原版样章。犹记得我在读到第一章介绍的RackSpace案例时那种兴奋之情。于是，我迫切地向徐定翔强烈推荐引进这本书，而我则毛遂自荐，希望能作为本书的译者。之后，我在InfoQ上看到对本书的《<a href="http://www.infoq.com/cn/articles/fairbanks-jesa">访谈和书摘</a>》，进一步加强了我翻译本书的信念。于是，出版社开始与作者Fairbanks联系，然而从此音讯如石沉大海。时针指向2011年，我对于本书是否被引进，是否由我翻译，一切未知。我觉得我可能错过了它，思之仍觉怅然。谁知到了九月，消息突然确定，而徐大编辑就不容分说地直接把原书给我寄来了。</p>
<p>拿到沉甸甸的书，第一面就为本书的装帧而惊喜。心里想，我这一辈子若能写出这样一本书，绝对值得生命走过的这一遭了。我并没有迫不及待地开始翻译，这就好似遇到珍馐美味，需得先赏其色，闻其香，然后再品其味。我每天抱着这本书饶有兴味地开始阅读之旅。阅读之旅确乎如行山阴道，沿途之美，目不暇接；可一想到翻译，这种美景就成了一种折磨，因为我害怕辜负这一美景。翻译之初我就举步维艰，那些词语放在那里，我却无法解开“封印”将它们取出来，即使取出来，却又找不到存放的合适位置。一些翻译隐隐约约浮现着，当我竭力去揭开这些词语的真面目时，无论如何用力，总也不能够着。翻译就好像那些年我们一起追过的女孩——追不到，痛苦；追到了，销魂。翻译进度像蜗牛一样的爬着，我终于决定求助了。辗转寻找了好多朋友，都以各种理由拒绝或者放弃了。翻译讲解软件架构的书，确乎不是一件轻松的事儿。那个时候，我的Buddy肖鹏正从翻译《面向模式的软件架构》第五卷的泥潭中爬了出来。每一提及他的这段翻译经历，脸上就会浮现出不堪回首的表情，如看了恐怖片。终于，事情得到转机，最开始是倪健的雪中送炭，再有高翌翔的锦上添花，随着我们这个三人组的建立，翻译才算开始走向正规，我才有了交稿的信心。</p>
<p>自从开始翻译这本书后，我与人谈架构，动辄就会提及“Just Enough，恰如其分”。我像祥林嫂一般地推介着Fairbanks提出的风险驱动模型，并认真地实践着这一模型。我开始对演进的架构有了更深入的理解。我写了《<a href="http://agiledon.github.io/blog/2011/10/10/design-just-enough-architecture/">设计恰如其分的架构</a>》这篇博客来详细阐述我对演进式架构的理解。在2011年我参加的技术会议上，我也反复讲解了如何遵循简单之美的原则，运用风险驱动模型设计恰如其分的架构。2012年，在我参加的一个项目中需要针对遗留系统进行技术栈迁移。我撰写了文章《<a href="http://www.infoq.com/cn/articles/legacy-system-migration">遗留系统的技术栈迁移</a>》，提到了“风险驱动模型”，并在2013年的Scrum Gathering会议上分享了我的一些想法。当然，这个模型并不是锤子，更不是银弹。它更近似于质量属性驱动的架构设计，我们要满足的质量属性，可能就是我们在做架构时需要面对的风险；而在Roy Fielding的那篇关于REST的著名论文中，也提到了对约束的识别，并演示了如何从一个空约束，通过逐步添加约束演化为REST风格的架构。从某种程度上，架构的约束可能是一种风险，也可能成为设计的驱动力。</p>
<p>前几天，我参加Agile China 2013，与我新认识的一位朋友范钢聊到了关于架构重构的问题。事实上，面向对象软件开发到现在，已有十余年之久；各种经验、模式与原则甚嚣尘上并得到较好的推广。然而新的方法、新的语言乃至新的思想仍然层出不穷，尤其是在互联网开发、大数据处理以及移动开发的冲击下，传统软件开发似乎已经开始走向末路。“只见新人笑，不见旧人哭”！？？是，也不是。实际上，在传统的企业开发领域，各种大型系统仍然像一艘庞大如巨型海兽一般的船舰在海面缓缓行驶，它或许就是沉没之前的泰坦尼克，一切还都安然无恙，你甚至可以听到船头甲板传来的悠扬的小提琴声；然而，冰川就在远处出没，船长还未察觉。我们该怎么办？这样的巨型船舰，自然不可能如艨艟快艇那般的敏捷，即使是360度的转身，也可以玩得如此漂亮、优雅。这些大型的企业级软件系统已经走过了漫长的历程，它们如此巨大以至于我们只能看到它的一角，它们的零部件如此复杂以至于没有人能够彻底弄懂。我们必须认识到，这些系统是最有权力的系统，它们很有可能掌握了人类生活的根本命脉——金融管理、股市交易、生命健康、医疗管理、机械制造、国防安全、航空、航天……它们就像政治界、金融界的那些巨头，要是患了病咳嗽两声，也许世界都要抖一抖。它们可以轻易改变吗？不能！然而若是不寻求改变，这些系统会宿命地走向衰亡。若我们无法承受重写的成本，唯一的办法或许就是架构的重构。我们必须清晰地认识到这一点。而我认为，风险驱动模型恰恰可以作为架构重构的指导原则。在进行重构之前，我们需要充分评估重构的价值，回答“为什么我们需要重构”的问题；然后去识别风险。在开始重构之前，我们需要尽可能做到万无一失。风险自然是不可避免的，但如果我们能事先识别出这些风险，就能有的放矢地选择正确的技术。风险驱动模型的第三步，则是评估风险是否得到有效缓解。不要轻视这一步！重构往往意味着还债。可是，我们该用什么来说服管理者们付出成本去做一些看似没有产生直接利益的任务呢？答案就是用数据来说话，通过比较重构前后的系统健康指标，可以加重说服老板的砝码。当然，毫无疑问，这个过程一定是迭代的。</p>
<p>我想，通过这次交谈，我进一步找到了“风险驱动模型”适用的场景。而这正是我翻译并推荐本书的根本意义。</p>
<p>本书可以在<a href="http://product.dangdang.com/23320387.html">当当网</a>购买。</p>
]]></content>
      <categories>
        <category>Writing</category>
      </categories>
      <tags>
        <tag>Architecture</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>深入分析软件复杂度</title>
    <url>/anlysis-complexity-of-software/</url>
    <content><![CDATA[<h3 id="软件复杂度的成因"><a href="#软件复杂度的成因" class="headerlink" title="软件复杂度的成因"></a>软件复杂度的成因</h3><p>Eric Evans的经典著作《领域驱动设计》的副标题为“软件核心复杂性应对之道”，这说明了Eric对领域驱动设计的定位就是<strong>应对软件开发的复杂度</strong>。Eric甚至认为：“领域驱动设计只有应用在大型项目上才能产生最大的收益”。他通过Smart UI反模式逆向地说明了在软件设计与开发过程中如果出现了如下问题，就应该考虑运用领域驱动设计：</p>
<ul>
<li>没有对行为的重用，也没有对业务问题的抽象。每当操作用到业务规则时，都必须重复这些规则。</li>
<li>快速的原型建立和迭代很快会达到其极限，因为抽象的缺乏限制了重构的选择。</li>
<li>复杂的功能很快会让你无所适从，所以程序的扩展只能是增加简单的应用模块，没有很好的办法来实现更丰富的功能。</li>
</ul>
<p>因此，选择领域驱动设计，就是要与软件系统的复杂作一番殊死拼搏，以降低软件复杂度为己任。那么，什么才是复杂呢？</p>
<span id="more"></span>

<h3 id="什么是复杂？"><a href="#什么是复杂？" class="headerlink" title="什么是复杂？"></a>什么是复杂？</h3><p>即使是研究复杂系统的专家，如《复杂》一书的作者Melanie Mitchell，都认为复杂没有一个明确得到公认的定义。不过，Melanie Mitchell在接受Ubiquity杂志专访时，还是“勉为其难”地给出了一个通俗的复杂系统定义：由大量相互作用的部分组成的系统，与整个系统比起来，这些组成部分相对简单，没有中央控制，组成部分之间也没有全局性的通讯，并且组成部分的相互作用导致了复杂行为。</p>
<p>这个定义庶几可以表达软件复杂度的特征。定义中的组成部分对于软件系统，就是我所谓的“设计单元”，基于粒度的不同可以是函数、对象、模块、组件和服务。这些设计单元相对简单，然而彼此之间的相互作用却导致了软件系统的复杂行为。</p>
<p>Jurgen Appelo从理解力与预测能力两个维度分析了复杂系统理论，这两个维度又各自分为不同的复杂层次，其中，理解力维度分为simple与comlicated两个层次，预测能力维度则分为ordered，complex与chaotic三个层次，如下图所示：</p>
<img src="/anlysis-complexity-of-software/complex.png" class="">

<p>参考复杂的含义，complicated与simple（简单）相对，意指<strong>非常难以理解</strong>，而complex则介于ordered（有序的）与chaotic（混沌的）之间，认为<strong>在某种程度上可以预测，但会有很多出乎意料的事情发生</strong>。显然，对于大多数软件系统而言，系统的功能都是难以理解的；在对未来需求变化的把控上，虽然我们可以遵循一些设计原则来应对可能的变化，但未来的不可预测性使得软件系统的演进仍然存在不可预测的风险。因此，软件系统的所谓“<strong>复杂</strong>”其实覆盖了complicated与complex两个方面。要理解软件复杂度的成因，就应该结合<strong>理解力</strong>与<strong>预测能力</strong>这两个因素来帮助我们思考。</p>
<h3 id="理解力"><a href="#理解力" class="headerlink" title="理解力"></a>理解力</h3><p>在软件系统中，是什么阻碍了开发人员对它的理解？想象团队招入一位新人，就像一位游客来到了一座陌生的城市，他是否会迷失在阡陌交错的城市交通体系中，不辨方向？倘若这座城市实则是乡野郊外的一座村落，不过只有房屋数间，一条街道连通城市的两头，还会生出迷失之感吗？</p>
<p>因而，影响理解力的第一要素是<strong>规模</strong>。</p>
<h4 id="规模"><a href="#规模" class="headerlink" title="规模"></a>规模</h4><p>软件的需求决定了系统的规模。当需求呈现线性增长的趋势时，为了实现这些功能，软件规模也会以近似的速度增长。由于需求不可能做到完全独立，导致出现相互影响相互依赖的关系，修改一处就会牵一发而动全身。就好似城市的一条道路因为施工需要临时关闭，此路不通，通行的车辆只得改道绕行，这又导致了其他原本已经饱和的道路因为涌入更多车辆而超出道路的负载变得更加拥堵，这种拥堵现象又会顺势向这些道路的其他分叉道路蔓延，形成一种辐射效应的拥堵现象。</p>
<p>软件开发的拥堵现象或许更严重：</p>
<ul>
<li>函数存在副作用，调用时可能对函数的结果作了隐含的假设；</li>
<li>类的职责繁多，不敢轻易修改，因为不知这种变化会影响到哪些模块；</li>
<li>热点代码被频繁变更，职责被包裹了一层又一层，没有清晰的边界；</li>
<li>在系统某个角落，隐藏着伺机而动的Bug，当诱发条件具备时，就会让整条调用链瘫痪；</li>
<li>不同的业务场景包含了不同的例外场景，每种例外场景的处理方式都各不相同；</li>
<li>同步处理与异步处理代码纠缠在一起，不可预知程序执行的顺序。</li>
</ul>
<p>当需求增多时，软件系统的规模也会增大，且这种增长趋势并非线性增长，会更加陡峭。倘若需求还产生了事先未曾预料到的变化，我们又没有足够的风险应对措施，在时间紧迫的情况下，难免会对设计做出妥协，头疼医头，脚疼医脚，在系统的各个地方打上补丁，从而欠下技术债（Technical Debt）。当技术债务越欠越多，累计到某个临界点时，就会量变引起质变，整个软件系统的复杂度达到巅峰，步入衰亡的老年期，成为“可怕”的遗留系统。正如饲养场的“奶牛规则”：奶牛逐渐衰老，最终无奶可挤；然而与此同时，饲养成本却在上升。</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>你去过迷宫吗？相似而回旋繁复的结构使得本来封闭狭小的空间被魔法般地扩展为一个无限的空间，变得无穷大，仿佛这空间被安置了一个循环，倘若没有找到正确的退出条件，循环就会无休无止，永远无法退出。许多规模较小却格外复杂的软件系统，就好似这样的一座迷宫。</p>
<p>此时，<strong>结构</strong>成了决定系统复杂度的关键因素。</p>
<p>结构之所以变得复杂，多数情况下还是因为系统的质量属性决定的。例如，我们需要满足高性能、高并发的需求，就需要考虑在系统中引入缓存、并行处理、CDN、异步消息以及支持分区的可伸缩结构。倘若我们需要支持对海量数据的高效分析，就得考虑这些海量数据该如何分布存储，并如何有效地利用各个节点的内存与CPU资源执行运算。</p>
<p>从系统结构的视角看，单体架构一定比微服务架构更简单，更便于掌控，正如单细胞生物比人体的生理结构要简单数百倍；那么，为何还有这么多软件组织开始清算自己的软件资产，花费大量人力物力对现有的单体架构进行重构，走向微服务化？究其主因，不还是系统的质量属性在作祟吗？</p>
<p>纵观软件设计的历史，不是分久必合，合久必分，而是不断拆分继续拆分持续拆分的微型化过程。分解的软件元素不可能单兵作战。怎么协同，怎么通信，就成为了系统分解后面临的主要问题。如果没有控制好，这些问题固有的复杂度甚至会在某些场景下超过因为分解给我们带来的收益。</p>
<p>无论是优雅的设计，还是拙劣的设计，都可能因为某种设计权衡而导致系统结构变得复杂。唯一的区别在于前者是主动地控制结构的复杂度，而后者带来的复杂度是偶发的，是错误的滋生，是一种技术债，它可能会随着系统规模的增大而导致一种<strong>无序设计</strong>。</p>
<p>在Pete Goodliffe讲述的《两个系统的故事：现代软件神话》中详细地罗列了<strong>无序设计</strong>系统的几种警告信号：</p>
<ul>
<li>代码没有显而易见的进入系统中的路径；</li>
<li>不存在一致性、不存在风格、也没有统一的概念能够将不同的部分组织在一起</li>
<li>系统中的控制流让人觉得不舒服，无法预测</li>
<li>系统中有太多的“坏味道”，整个代码库散发着腐烂的气味，是在大热天里散发着刺激气体的一个垃圾堆</li>
<li>数据很少放在使用它的地方。经常引入额外的巴罗克式缓存层，目的是试图让数据停留在更方便的地方。</li>
</ul>
<p>我们看一个无序设计的软件系统，就好像隔着一层半透明的玻璃观察事物一般，系统中的软件元素都变得模糊不清，充斥着各种技术债。细节层面，代码污浊不堪，违背了“高内聚松耦合”的设计原则，导致许多代码要么放错了位置，要么出现重复的代码块；架构层面，缺乏清晰的边界，各种通信与调用依赖纠缠在一起，同一问题域的解决方案各式各样，让人眼花缭乱，仿佛进入了没有规则的无序社会。</p>
<h3 id="预测能力"><a href="#预测能力" class="headerlink" title="预测能力"></a>预测能力</h3><p>当我们掌握了事物发展的客观规律时，我们就具有了一定的对未来的预测能力。例如我们洞察了万有引力的本质，就可以对我们能够观察到的宇宙天体建立模型，相对准确地推测出各个天体在未来一段时间的运行轨迹。然而，宇宙空间变化莫测，或许因为一个星球的死亡产生黑洞的吸噬能力，就可能导致那一片星域产生剧烈的动荡，这种动荡会传递到更远的星空，从而干扰了我们的预测。坦白说，我们现在连自己居住的地球天气都不能做一个准确的预测，何敢妄谈对星空的预测？之所以如此，正是因为未知的变化的产生。</p>
<h4 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h4><p>未来总会出现不可预测的变化。这种<strong>不可预测性带来的复杂度</strong>，使得我们产生畏惧，因为我们不知道何时会发生变化，变化的方向又会走向哪里，这就导致心理滋生一种仿若失重一般的感觉。变化让事物失去控制，受到事物牵扯的我们会感到惶恐不安。</p>
<p>在设计软件系统时，变化让我们患得患失，不知道如何把握系统设计的度。若拒绝对变化做出理智的预测，系统的设计会变得僵化，一旦变化发生，修改的成本会非常的大；若过于看重变化产生的影响，渴望涵盖一切变化的可能，一旦预期的变化不曾发生，我们之前为变化付出的成本就再也补偿不回来了。这就是所谓的“过度设计”。</p>
<p>从需求的角度讲，变化可能来自业务需求，也可能来自质量属性。以对系统架构的影响而言，尤以后者为甚，因为它可能牵涉到整个基础架构的变更。George Fairbanks在《恰如其分的软件架构》一书中介绍了邮件托管服务公司RackSpace的日志架构变迁，业务功能没有任何变化，却因为邮件数量的持续增长，为满足性能需求，架构经历了三个完全不同解决方案的变迁：从最初的本地日志文件，到中央数据库，再到基于HDFS的分布式存储，整个系统几乎发生了颠覆性的变化。这并非RackSpace的设计师欠缺设计能力，而是在公司草创之初，他们没有能够高瞻远瞩地预见到客户数量的增长，导致日志数据增多，以至于超出了已有系统支持的能力范围。俗话说：“事后诸葛亮”，当我们在对一个软件系统的架构设计进行复盘时，总会发现许多设计决策是如此的愚昧。殊不知这并非愚昧，而是在设计当初，我们手中掌握的筹码不足以让自己赢下这场面对未来的战争罢了。</p>
<p>这就是变化之殇！</p>
<p>如果将软件系统中我们自己开发的部分都划归为需求的范畴，那么还有一种变化，则是因为我们依赖的第三方库、框架或平台、甚至语言版本的变化带来的连锁反应。例如，作为Java开发人员，一定更垂涎于Lambda表达式的简洁与抽象，又或者Jigsaw提供的模块定义能力，然而现实是我们看到多数的企业软件系统依旧在Java 6或者Java 7中裹足不前。</p>
<p>这还算是幸运的例子，因为我们尽可以满足这种故步自封，因为情况并没有到必须变化的境地。但当我们依赖的第三方有让我们不得不改变的理由时，难道我们还能拒绝变化吗？</p>
<p>许多软件在版本变迁过程中都尽量考虑到API变化对调用者带来的影响，因而尽可能保持版本向后兼容。我亲自参与过系统从Spring 2.0到4.0的升级，Spark从1.3.1到1.5再到1.6的升级，感谢这些框架或平台设计人员对兼容性的体贴照顾，使得我们的升级成本能够被降到最低；但是在升级之后，倘若没有对系统做全方位的回归测试，我们的内心始终是惴惴不安的。</p>
<p>对第三方的依赖看似简单，殊不知我们所依赖的库、平台或者框架又可能依赖了若干对于它们而言又份属第三方的更多库、平台和框架。每回初次构建软件系统时，我都为漫长等待的依赖下载过程而感觉烦躁不安。多种版本共存时可能带来的所谓<strong>依赖地狱</strong>，只要亲身经历过，就没有不感到不寒而栗的。倘若你运气欠佳，可能还会有各种古怪问题接踵而来，让你应接不暇，疲于奔命。</p>
<p>如果变化是不可预测的，那么软件系统也会变得不可预测。一方面我们要尽可能地控制变化，至少要将变化产生的影响限制在较小的空间范围内；另一方面又要保证系统不会因为满足可扩展性而变得更加复杂，最后背上<strong>过度设计</strong>的坏名声。软件设计者们就像走在高空钢缆的技巧挑战者，惊险地调整重心以维持行动的平衡。故而，变化之难，在于如何平衡。</p>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache下流处理项目巡览</title>
    <url>/apache-streaming-projects/</url>
    <content><![CDATA[<img src="/apache-streaming-projects/stream.jpg" class="">

<blockquote>
<p>我们的产品需要对来自不同数据源的大数据进行采集，从数据源的多样化以及处理数据的低延迟与可伸缩角度考虑，需要选择适合项目的大数据流处理平台。我最初列出的候选平台包括Flume、Flink、Kafka Streaming以及Spark Streaming。然而对产品架构而言，这个技术选型的决策可谓举足轻重，倘若选择不当，可能会导致较大的修改成本，须得慎之又慎。</p>
</blockquote>
<blockquote>
<p>我除了在项目中曾经使用过Flume、Kafka以及Spark Streaming之外，对其余平台并不甚了解。即便是用过的这几个平台，也了解得比较肤浅。因此我查阅了这些平台的官方文档以及相关文章，偶然发现有Janakiram在2016年7月8日发表在<a href="https://thenewstack.io/">The New Stack</a>网站上的这篇文章<a href="https://thenewstack.io/apache-streaming-projects-exploratory-guide">All the Apache Streaming Projects: An Exploratory Guid</a>，全(jian)面(dan)介绍了目前在Apache下主流的流处理项目，具有一定参考价值。因此摘译过来，以飧读者。</p>
</blockquote>
<p>最近几年，数据的生成、消费、处理以及分析的速度惊人地增长，社交媒体、物联网、游戏等领域产生的数据都需要以接近实时的速度处理和分析数据。这直接催生了<strong>流数据</strong>的处理范式。从Kafka到Beam，即使是在Apache基金下，已有多个流处理项目运用于不同的业务场景。</p>
<span id="more"></span>

<h3 id="Apache-Flume"><a href="#Apache-Flume" class="headerlink" title="Apache Flume"></a>Apache Flume</h3><p>Apache Flume或许是Apache众多项目中用于流数据处理的最古老项目了，其设计目的是针对诸如日志之类的数据进行采集、聚合和迁移。Flume基于<strong>agent-driven architecture</strong>，客户端生成的事件会以流的形式直接写入到Hive、HBase或者其他数据存储。</p>
<p>Flume由Source、Channel和Sink组成。Source可以是系统日志、Twitter流或者Avro。Channel定义了如何将流传输到目的地。Channel的可用选项包括Memory、JDBC、Kafka、文件等。Sink则决定了流传输的目的地。Flume支持如HDFS、Hive、HBase、ElasticSearch、Kafka等Sink。</p>
<img src="/apache-streaming-projects/flume.jpg" class="">

<p>使用Flume的最常见场景是从多个源头采集流日志汇总并持久化到数据中心，以便于进一步地处理与分析。</p>
<p><strong>典型用例：</strong>对来自于多个可以运行在JVM上的Source的日志进行流处理。</p>
<h3 id="Apache-Spark"><a href="#Apache-Spark" class="headerlink" title="Apache Spark"></a>Apache Spark</h3><p>Apache Spark为开发者提供了基于RDD的API，RDD被称为弹性分布式数据集，是一个只读的数据集，可以分布于多个机器集群，具有容错性。Spark的诞生本身是为了解决MapReduce的性能限制，它以内存模型对数据进行处理和分析，从而提高了处理的性能。</p>
<p>Spark使用Scala进行开发，但它也支持Java、Python和R语言，支持的数据源包括HDFS、Cassandra、HBase与Amazon S3等。</p>
<p>Spark Streaming是Spark其中的一个组件，用于高容错的流处理应用。由于它运行在Spark之上，因而允许开发人员重用批处理的相同代码，针对历史数据进行join流操作，或者针对流状态进行即刻查询。Spark Streaming采用了<strong>micro-batching模式</strong>，即本质上还是批处理，但处理的单元可以非常微小。</p>
<img src="/apache-streaming-projects/spark-streaming.jpg" class="">

<p>Spark还可以运行在已有的Hadoop与Mesos集群上，并为探索数据提供了声明式的shell编写能力。</p>
<p>Apache Spark可以与Apache Kafka配套，提供强大的流处理环境。</p>
<p><strong>典型用例：</strong>实时处理社交媒体的feed，以进行情感分析。</p>
<h3 id="Apache-Storm"><a href="#Apache-Storm" class="headerlink" title="Apache Storm"></a>Apache Storm</h3><p>Apache Storm最初由Twitter旗下的BackType公司员工Nathan Marz使用Clojure开发。在获得授权后，Twitter将Storm开源。它一诞生就几乎成为分布式的实时数据处理平台的标准。</p>
<p>Storm常常被认为是Hadoop下的实时处理平台，官方文档则宣称：它能够像Hadoop进行批处理那样对数据进行实时处理。</p>
<p>Apache Storm的主要设计目的是为了追求系统的可伸缩性与高容错性。它能够保证每条tuple数据至少能够被处理一次。虽然系统是由Clojure编写，但应用的编写却可以支持各种语言，只要这种语言能够读写标准的输入和输出流。</p>
<p>Storm连接的输入流称之为“spouts”和“bolts”，对应处理和输出模块。spouts和bolts的集合组成了有向无环图（DAG），在Storm中称之为拓扑（topology）。基于预先定义的配置，拓扑可以运行在集群上，根据scheduler对工作进行跨节点的分发。</p>
<img src="/apache-streaming-projects/storm.jpg" class="">

<p>Storm的拓扑常常与Hadoop MapReduce的Job对比。但是不同于Hadoop Job，拓扑可以持续不断地执行，直到它被终止。在拓扑中，Spouts获取数据并通过一系列的bolts进行传递。每个bolt会负责对数据的转换与处理。一些bolt还可以将数据写入到持久化的数据库或文件中，也可以调用第三方API对数据进行转换。</p>
<p>基于适配器的概念，Storm可以与HDFS文件系统协作，并作为Hadoop Job参与。</p>
<p>通常会将Storm与Apache Kafka和Apache Spark混合使用。Storm提供了可靠的、可伸缩的高容错分布式计算框架。</p>
<p><strong>典型用例：</strong>实时转换和处理社交媒体/物联网传感器流。</p>
<h3 id="Apache-NiFi"><a href="#Apache-NiFi" class="headerlink" title="Apache NiFi"></a>Apache NiFi</h3><p>和其他流处理方案相比，Apache NiFi相对较新，在2015年7月才成为Apache的顶级项目。它基于企业集成模式（Enterprise Integration Patterns, EIP），将数据流分为多个阶段和转换，最后到达目的地。</p>
<p>Apache NiFi提供了直观的图形界面，使得用户可以非常方便地设计数据流与转换。业务分析师和决策者可以使用这个工具来定义数据流。它还支持各种输入源包括静态和流的数据集。数据源可以是文件系统、社交媒体流、Kafka、FTP、HTTP、JMS，流向的目的地则包括ElasticSearch、Amazon S3、AWS Lambda、Splunk、Solr、SQL和NoSQL数据库。</p>
<p>在物联网领域，Apache NiFi有可能成为处理传感器数据的首选编排引擎。它提供了具有大数据处理能力的Node-Red简化，所谓<a href="https://nodered.org/">Node-Red</a>是面向物联网的基于流的编程模型。NiFi内建支持Kafka、JMS以及其他通道。</p>
<p>Apache NiFi的一个经典场景是用于对Hot Path与Cold Path的创建。数据集通常可以流经高速度的处理引擎，如Apache Kafka、Amazon Kinesis和Azure Event Hubs。Apache NiFi可以将相同的数据集分为两个独立的路径，一个用于近实时的处理（hot path），一个用于批处理（code path）。</p>
<p><strong>典型用例：</strong>一个交互式的规则引擎，用于定义物联网传感器数据流。</p>
<h3 id="Apache-Apex"><a href="#Apache-Apex" class="headerlink" title="Apache Apex"></a>Apache Apex</h3><p>Apache Apex由一家硅谷公司DataTorrent捐赠给Apache基金会，之前是实时流处理的商业产品。这是一个年轻的项目，刚刚（相对这篇文章的写作日期2016年）从孵化版本升级为顶级项目。它的定位就是在实时流处理上取代Storm与Spark，号称处理速度是Spark的10到100倍。</p>
<p>相较于Spark，Apex提供了一些企业特性，如事件处理、事件传递的顺序保证与高容错性。与Spark需要熟练的Scala技能不同，Apex更适合Java开发者。它可以运行在已有的Hadoop生态环境中，使用YARN用于扩容，使用HDFS用于容错。</p>
<p>Apache Apex的目标是打造企业级别的开源数据处理引擎，可以处理批量数据和流数据。使用时可以根据具体的业务场景选择所谓unbounded data的实时流处理或者传统文件形式的bounded data处理，且这两种处理方式在Apex下是统一的。</p>
<p>Apache Apex的架构可以读/写消息总线、文件系统、数据库或其他类型的源。只要这些源的客户端代码可以运行在JVM上，就可以无缝集成。</p>
<p>Apex使用了一个操作子（operators）库，称之为<a href="https://github.com/apache/apex-malhar">Malhar</a>，它为读写消息总线、文件系统和数据库提供了预先构建的操作子。这些操作子使得开发者能够快速构建业务逻辑，用于处理各种数据源。Apex的整体目标就是为了简化企业应用中大数据项目的复杂度。</p>
<p><strong>典型用例：</strong>运行在高容错基础设施之上的应用，需要以实时和批模式处理异构数据。</p>
<h3 id="Apache-Kafka-Streams"><a href="#Apache-Kafka-Streams" class="headerlink" title="Apache Kafka Streams"></a>Apache Kafka Streams</h3><p>Kafka Streams仅仅是构建在Apache Kafka之上的一个库，由Confluent贡献，这是一家由LinkedIn参与Kafka项目的早期开发者创建的初创公司。</p>
<p>在过去的几年内，Apache Kafka以实时与大规模消息系统著称，并变得越来越普及，快速成为了大数据平台的核心基础构件。它被广泛应用于各行各业的上千家公司，包括Netflix、Cisco、PayPal与Twitter。公有云的提供商在其提供的大数据分析平台之上，都将Kafka作为一个托管的服务。</p>
<p>Kafka Streams是一个用于构建流应用的库，特别用于处理将Kafka topics转换为输出的Kafka topics。它的设计初衷并不是为了大量分析任务，而是用于微服务架构，进行高效而精简的流处理。这意味着Kafka Streams库用于应用程序的核心业务逻辑集成，而非用于大量的分析Job。</p>
<p>Kafka Streams将用户从繁杂的安装、配置以及管理复杂Spark集群中解放出来。它简化了流处理，使其作为一个独立运行的应用编程模型，用于响应异步服务。开发者可以引入Kafka Streams满足其流处理的功能，却无需流处理的集群（因为Kafka已经提供）。除了Apache Kafka，在架构上并没有其他外部依赖。Kafka Streams提供的处理模型可以完全与Kafka的核心抽象整合。</p>
<p>在讨论Kafka Streams时，往往会谈及Kafka Connect。后者用于可靠地将Kafka与外部系统如数据库、Key-Value存储、检索索引与文件系统连接。</p>
<p>Kafka Streams最棒的一点是它可以作为容器打包到Docker中。DevOps团队也可以使用Ansible、Puppet、Chef、Salt甚或shell脚本部署和管理它的应用。一旦被打包为容器，它就可以与一些编排引擎集成，如Docker Swarm、Kubernetes、DC/OS、Yarn等。</p>
<img src="/apache-streaming-projects/kafka-streams.jpg" class="">

<p><strong>典型用例：</strong>需要进行流处理，但又不希望依赖复杂集群的微服务与独立部署的应用。</p>
<h3 id="Apache-Samza"><a href="#Apache-Samza" class="headerlink" title="Apache Samza"></a>Apache Samza</h3><p>Apache Samza由LinkedIn开发，目的是为了避免Hadoop批处理引入的长时运转时间（large turn-around times）问题。它构建于Kafka之上。Samza提供了持续数据处理的轻量级框架。</p>
<p>Kafka与Samza的搭配就好比HDFS与MapReduce的搭配。当数据到达时，Samza可以持续计算结果，并能达到亚秒级的响应时间。</p>
<p>在从流获得输入后，Samza会执行Job。可以通过编码实现Job对一系列输入流的消费与处理。编写Job可以使用Java、Scala或其他JVM下的编程语言。为了支持可伸缩性，Job也可以被分解为多个小的并行执行单元，称之为Task。每个Task可以消费其中一个分区传递的流数据。一个任务会顺序地处理来自其输入分区的数据，并保证消息的顺序。分区之间并没有定义顺序，因此允许每个任务独立对其进行操作。</p>
<p>Samza会在一个或多个容器（container）中将多个任务组合起来执行。在Samza中，容器是单个线程，负责管理任务的生命周期。</p>
<p>Samza与其他流处理技术的不同之处在于它的<strong>有状态流处理能力</strong>。Samza任务具有专门的key/value存储并作为任务放在相同的机器中。这一架构使得它比其他流处理平台具有更好的读/写性能。</p>
<p>当使用Kafka进行数据采集时，架构上Samza会是一个自然的选择。</p>
<p>Apache Samza与Kafka Streams解决的问题类似，在将来可能会被合并为一个项目。</p>
<p><strong>典型用例：</strong>使用Kafka进行数据采集的更优化流处理框架。</p>
<h3 id="Apache-Flink"><a href="#Apache-Flink" class="headerlink" title="Apache Flink"></a>Apache Flink</h3><p>Apache Flink在2014年12月成为Apache顶级项目。它的概念以及使用场景看起来与Spark相似，其目的在于提供运行批数据、流、交互式、图处理以及机器学习应用的一体化平台，但是二者在实现上存在差别。</p>
<p>Spark Streaming是以处理迷你批数据的方式实现准实时处理能力。Apache Flink则提供了实时处理能力，这源于其细粒度的事件级别处理架构（fine-grained event level processing architecture）。</p>
<p>Flink提供了消息处理恰好一次（exactly-once）的保证，这就使得开发者不用再处理冗余消息。它提供了高吞吐量的引擎，在事件发送到分布式网络之前提供了buffer功能。同时，它还具有灵活的windowing scheme，以支持强大的流编程模型。</p>
<p>Flink提供DataStream API用于流数据的分析，DataSet API用于批数据的分析，二者皆建立在底层的流处理引擎之上。</p>
<img src="/apache-streaming-projects/flink.jpg" class="">

<p>Apache Flink支持Java或Scala编程。它没有提供数据存储系统。输入数据可以来自于分布式存储系统如HDFS或HBase。针对流处理场景，Flink可以消费来自诸如Kafka之类的消息队列的数据。</p>
<p><strong>典型用例：</strong>实时处理信用卡交易。</p>
<h3 id="Apache-Beam"><a href="#Apache-Beam" class="headerlink" title="Apache Beam"></a>Apache Beam</h3><p>Apache Beam同样支持批处理和流处理模型，它基于一套定义和执行并行数据处理管道的统一模型。Beam提供了一套特定语言的SDK，用于构建管道和执行管道的特定运行时的运行器（Runner）。</p>
<p>Beam演化于Google的几个内部项目，包括MapReduce、FlumeJava和Millwheel。在Beam中，管道运行器（Pipeline Runners）会将数据处理管道翻译为与多个分布式处理后端兼容的API。管道是工作在数据集上的处理单元的链条。取决于管道执行的位置，每个Beam程序在后端都有一个运行器。当前的平台支持包括Google Cloud Dataflow、Apache Flink与Apache Spark的运行器。Storm和MapReduce的运行器孩还在开发中（译注：指撰写该文章的2016年。我通过查看Beam的官方网站，看到目前支持的runner还包含了Apex和Gearpump，似乎对Storm与MapReduce的支持仍然在研发中）。</p>
<p>Dataflow试图在代码与执行运行时之间建立一个抽象层。当代码在Dataflow SDK中被实现后，就可以运行在多个后端，如Flink和Spark。Beam支持Java和Python，其目的是将多语言、框架和SDK融合在一个统一的编程模型中。</p>
<img src="/apache-streaming-projects/beam.png" class="">

<p><strong>典型用例：</strong>依赖与多个框架如Spark和Flink的应用程序。</p>
<h3 id="Apache-Ignite"><a href="#Apache-Ignite" class="headerlink" title="Apache Ignite"></a>Apache Ignite</h3><p>Apache Ignite是搭建于分布式内存运算平台之上的内存层，它能够对实时处理大数据集进行性能优化。内存模型的架构比传统的基于磁盘或闪存的技术要快。</p>
<p>Apache Ignite于2015年9月从孵化版升级为Apache顶级项目。</p>
<p>虽然Spark与Ignite都是基于分布式的内存处理架构，但二者却存在差别。Spark主要用于交互式分析（interactive analytics）以及机器学习，而Ignite则提供编程式的实时分析、机器对机器的通信以及高性能的事务处理。</p>
<p>对于交易处理系统例如股票交易、反欺诈、实时建模与分析而言，Ignite可能会成为首选。它既支持通过添加硬件的方式进行水平伸缩，也支持在工作站以及专用服务器上的垂直伸缩。</p>
<p>Ignite的流处理特性能够支持持续不断地没有终止的数据流，并具有可伸缩和高容错的能力。</p>
<p><strong>典型用例：</strong>高度依赖于编程形式的实时分析应用，机器对机器的通信以及高性能的事务处理。</p>
<blockquote>
<p>这篇文章并没有为大数据流处理技术选型提供充分的证据支持，对这些项目的介绍仅仅是泛泛而谈，但它为选型提供了相对完整的列表，让我们知道了到底有多少主流的且较为成熟的流处理平台，因而仍然具有一定的参考价值。</p>
</blockquote>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Streaming</tag>
        <tag>Big Data</tag>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动设计中的架构要素</title>
    <url>/architectural-elements-of-ddd/</url>
    <content><![CDATA[<p>多数时候，领域驱动设计的分层架构并不能清晰表达各模块之间的依赖关系，以及这些模块在分层架构中所处的位置。因为我倾向于将Uncle Bob的Clean Architecture与DDD的分层架构整合起来，如下图所示：</p>
<img src="/architectural-elements-of-ddd/01.jpg" class="">

<p>在这个架构图中，基础设施层处于最外部，然后是应用层，最核心的是领域层。<strong>基础设施中的模块，我都称之为gateway。</strong>根据依赖方向，如果是被调用的方向，即由外至内的调用方向，就是北向，称之为北向网关。如果当前限界上下文是通过该网关调用外部资源或者别的限界上下文，即由内至外的调用方向，则是南向网关。例如图中的<code>OrderController</code>，会被别人调用，因而属于北向网关。注意，倘若<code>OrderController</code>通过RESTful方式暴露API，即为REST服务，也就是基于资源的服务。我们不能将它与DDD的应用服务混为一谈。</p>
<span id="more"></span>

<p>南向网关要特殊一些，它是打通应用层或领域层与外部资源（数据库、消息队列、第三方服务）的通道。根据整洁架构的设计原则，我们不能让内层依赖外层，以保证内层的纯粹性与稳定性。为了解除应用层或领域层与它的耦合，南向网关往往需要提供接口。这就说明，基础设施层的南向网关都是具体实现，内层对南向网关的调用则通过接口和依赖注入。至于它们的接口，就应该放在领域层或者应用层。例如，数据库的持久化属于南向网关，但它们的抽象Repository就属于领域层。</p>
<p>通过上图，可以帮助我们明确各个模块和各层之间的职责。下图则基于这样的内外层架构清晰地表达了限界上下文（Bounded Context，以下简称BC）之间的协作关系，即DDD中的Context Map：</p>
<img src="/architectural-elements-of-ddd/02.jpg" class="">

<p>Context Map中有两个常用的模式OHS（开放主机服务）与ACL（防腐层）。显然，OHS就对应前面提到的北向网关，ACL就对应着南向网关。</p>
<p>为了遵循整洁架构原则，就需要为ACL提供一个抽象。例如订单要调用商家BC的服务，就需要在订单BC中定义一个被调用服务的接口，然后在ACL中，通过具体框架提供的跨进程调用方式，去真正发起对商家BC服务的调用。所以，我通常将代表ACL的模块命名为Client。通过Client可以防止上游BC发生变化时对下游BC产生直接影响。一旦变化发生，我们仅需要修改南向网关中的client实现。如下图所示：</p>
<img src="/architectural-elements-of-ddd/03.jpg" class="">
<p>这张图体现了有ACL和无ACL的区别。</p>
<p>下图体现了BC对领域概念的控制，它是控制领域概念一致性的边界。在DDD中，最好的方式是不去跨BC重用一个相同的领域概念：</p>
<img src="/architectural-elements-of-ddd/04.jpg" class="">
<p>假设我们的BC都是微服务，就是零共享架构，数据库是独立的。那么，各自BC关心的Product属性应该放在各自数据库中，它们的ID要保持一致。</p>
<p>现在基于这些认识来讨论两个问题：</p>
<ul>
<li>一个BC如何发起对另一个BC的调用</li>
<li>调用时，是否会产生所谓的“领域模型”耦合</li>
</ul>
<p>例如在订单BC中，如果在获得订单信息的同时，还需要获得订单中商品的信息以及该商品所属商家的信息，那么该谁发起对商家BC和商品BC的调用？</p>
<p>首先，我们在订单BC中定义自己的模型，该模型除了Order之外，还包含了商家与商品的信息，但这些信息是Read Model，是不需要在订单BC中持久化的。这就遵循了“<strong>BC是控制领域概念一致性的边界</strong>”这一原则。由于商家与商品在订单BC中并没有持久化的需求，因此当修改发生时，并不会因此而产生数据的不一致，更不会产生领域模型的耦合。这些领域模型都各自被定义在自己的BC中，没有重用。</p>
<p>其次，该谁来发起商家和商品BC的调用呢？通过第一张图与第二张图的讨论，我们需要在订单BC中定义商家BC和商品BC对应服务的接口（即前面提到的Client的接口），然后在领域层的相关对象（通常是领域服务），发起对这些接口的调用。框架会通过IoC框架注入Client实现，以满足对外部服务的调用。调用后，会在订单BC将返回的结果转换为自己BC的模型对象。如果需要组装最后的DTO，则可以在领域服务之上再包装一个应用服务，完成整个完整用例的逻辑。这样，就可以让Controller只调用应用服务，减少Controller对领域层的理解，从而遵循“最小知识”法则。</p>
<p>基于这样的设计思想，DDD的代码模型就可以定义为：</p>
<img src="/architectural-elements-of-ddd/05.jpg" class="">

<p>以下是对代码结构的说明：</p>
<ul>
<li>application：对应了领域驱动设计的应用层，主要内容为该限界上下文中所有的应用服务。</li>
<li>interfaces：对gateways中除persistence之外的抽象，包括访问除数据库之外其他外部资源的抽象接口，以及对第三方服务或其他限界上下文服务的抽象接口。从分层架构的角度讲，interfaces应该属于应用层，但在实践时，往往会遭遇领域层需要访问这些抽象接口的情形，单独分离出interfaces，非常有必要。</li>
<li>domain：对应了领域驱动设计的领域层，但是我将repositories单独分了出来，目的是为了更好地体现它在基础设施层扮演的与外部资源打交道的网关语义。</li>
<li>repositories：代表了领域驱动设计中战术设计阶段的资源库，皆为抽象类型。如果该限界上下文的资源库并不复杂，可以将repositories合并到domain中。</li>
<li>gateways：对应了领域驱动设计的基础设施层，命名为gateways，则是为了更好地体现网关的语义，其下可以视外部资源的集成需求划分不同的包。其中，controllers相对特殊，它属于对客户端提供接口的北向网关，等同于上下文映射中“<strong>开放主机服务（OHS）</strong>”的概念。如果为了凸显它的重要性，可以将controllers提升到与application、domain、gateways同等层次。我之所以将其放在gateways之下，还是想体现它的网关本质。persistence对应了repositories抽象，至于其余网关，对应的则是application/interfaces下的抽象，包括消息队列以及与其他限界上下文交互的客户端，例如通过http通信的客户端。其中，client包下的实现类与interfaces下的对应接口组合起来，等同于上下文映射中“<strong>防腐层（ACL）</strong>”的概念。</li>
</ul>
<p>归根结底，在运用DDD进行架构设计，并通过BC映射到微服务设计时，要遵循两方面的设计原则。一个是<strong>普适性的架构与设计原则</strong>，例如整洁架构、分而治之思想、关注点分离、最小知识法则等。理解了这些原则，你就清楚该如何分配职责，如何解耦。另一个是DDD的设计原则，搞清楚每个层的职责，层之间的关系，BC之间的关系，领域模型是什么？在明白了这些设计原则的真谛时，当我们碰到DDD设计落地的问题时，不知道该如何处理时，都可以基于这些设计原则来做出符合当前场景的决策，而不要做个“寻章摘句老雕虫”，照搬书上的方法，只要书上未曾涉及到此问题，就无从应对了。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Architecture</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动设计基本概念答疑</title>
    <url>/basic-concepts-of-ddd/</url>
    <content><![CDATA[<img src="/basic-concepts-of-ddd/cover.jpg" class="">

<p>本文内容来自我的知识星球「逸派胡言」对群友提出的有关领域驱动设计基本概念的回答。</p>
<span id="more"></span>


<h3 id="实体与值对象"><a href="#实体与值对象" class="headerlink" title="实体与值对象"></a>实体与值对象</h3><p>问题：DDD实现中领域对象区分实体(Entity)和值对象(Value Object)的目的(Why)是什么?或者换一种问法：领域对象区分实体(Entity)和值对象(Value Object)之后，带来的好处和收益是什么?</p>
<p>回答：从DDD的概念上讲，实体（Entity）与值对象（Value Object）的本质区别仅在于后者无需identity（唯一标识）。这其实就是带来的价值——就是你设计的对象不需要去跟踪和管理这个唯一标识。</p>
<p>这是概念划分上，值对象带来的价值。</p>
<p>再来说设计层面。通常情况下，我们建议将值对象设计成一个不变（Immutable）对象。当一个对象是不变的时，你就基本不需要担心并发带来的诸如同步、冲突等问题了，这既降低了编程的难度，又可以无需引入额外的同步锁影响程序的性能。</p>
<p>反而过来说，之所以可以将值对象设计成不变的，其根本原因还是在于我们无需跟踪和管理唯一标识。</p>
<p>在领域驱动设计中，我们提倡的实践是尽量定义值对象来替代基本类型，原因在于基本类型无法体现统一语言中的领域概念。此外，在多数语言中，我们无法对基本类型做封装，就意味着一个领域概念缺乏领域行为来支持。假设一个实体定义了许多属性，如果这些属性都是基本类型，就会导致与这些属性相关的领域行为都要放到实体中，导致实体的职责变得不够单一。</p>
<p>引入值对象后，情况就不同了，因为我们可以利用合理的职责分配，将这些职责（领域行为）按照内聚性分配到各个值对象中，这个领域模型就能变得协作良好。</p>
<p>当然，反过来说，之所以可以这样设计，还是在于值对象无需承担跟踪和管理唯一标识的职责。</p>
<p>这也是为何Eric要将实体和值对象分开的主要原因，也是值对象给我们带来的价值所在。</p>
<h3 id="Repository与DAO"><a href="#Repository与DAO" class="headerlink" title="Repository与DAO"></a>Repository与DAO</h3><p>问题：Repository与DAO其实都是两种模式的名称。然而在领域驱动设计中，名称本身就是非常重要的。Dao即Data Access Object，即数据访问对象。从其命名上看，就应该属于数据访问层，即DDD中的基础设施层。</p>
<p>回答：在DDD中，所有的领域对象应该都属于领域层。那么，该如何访问这些领域对象呢？DDD希望解除领域层与基础设施层之间的关系，即将设计的注意力完全放在领域建模和领域设计上，思考领域逻辑的实现时，应尽可能地不要考虑领域对象的持久化（数据访问），于是就定义了Repository这个抽象。无论放在哪里（文件、DB或者内存），Repository都将其视为一个“资源库”的抽象。经过这么一层的抽象之后，获取领域对象，或者说管理领域对象生命周期的逻辑就应该属于领域层。</p>
<p>在实现上，你当然可以将这样的Repository接口命名为DAO，这本身没有问题，但名不正则言不顺，如果在领域层中夹杂了一个名为DAO的接口，仍然有“将基础设施混入领域层”的嫌疑。</p>
<p>所以，Repository是抽象，代表了对领域对象生命周期的管理，但并不等于是持久化，持久化只是Repository的其中一种实现。你可以假设一台服务器无比的强大，内存大且永远不会宕机，这时何须持久化呢？但无论怎么修改生命周期的具体管理方式，都不会影响到Repository的抽象。</p>
<h3 id="领域服务与应用服务"><a href="#领域服务与应用服务" class="headerlink" title="领域服务与应用服务"></a>领域服务与应用服务</h3><p>问题：应用服务与领域服务的区别在哪？</p>
<p>回答：从分层架构上，应用服务属于应用层，领域服务属于领域层。</p>
<p>从职责上看，应用服务只是一个门面（Facade），它具体并不做领域服务的活儿，也就是不提供领域实现，也就是不包含业务逻辑。之所以要引入应用服务，有两个原因：</p>
<p>领域服务或其他领域对象的粒度太细（便于协作、扩展和重用），不利于客户端的调用，基于“最小知识原则”，还是让客户端少知道这些领域对象协作的知识为好。此时的应用服务更像是对领域对象的一种“编排”。</p>
<p>在调用领域对象去完成一个用例时，不可避免地要牵涉到一些属于“横切关注点”的内容，如事务、异常处理、授权认证等。这些横切关注点从职责上看，不属于领域层，放在领域服务中可能会导致对领域逻辑的污染，这些职责就像砌砖墙时需要的水泥。水泥自身不提供砖头的职责，但没有水泥，墙就没法砌起来。</p>
<p>具体对领域服务和应用服务的阐述，可以看我的这篇文章《<a href="http://zhangyi.xyz/how-to-identify-application-service/">一篇文章教你分辨应用服务和领域服务</a>》。</p>
<p>请关注我的「知识星球」：</p>
<img src="/basic-concepts-of-ddd/zsxq_new.jpeg" class="">


]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
        <tag>知识星球</tag>
      </tags>
  </entry>
  <entry>
    <title>行为驱动开发的简要介绍</title>
    <url>/brief-introduce-bdd/</url>
    <content><![CDATA[<p>行为驱动开发（Behavior-Driven Development， BDD）的概念来自于测试驱动开发，强调<strong>使用DSL（Domain Specific Language，领域特定语言）描述用户行为，定义业务需求，是需求分析人员、开发人员与测试人员进行沟通的有效方法</strong>。DSL是一种编码实现，相比自然语言更加精确，又能以符合领域概念的形式满足所谓“活文档（Living Document）”的要求。可以说，行为驱动开发将编码实现与业务行为描述完美地结合起来，走出了一条业务分析人员、开发人员与测试人员都能接受的中庸之道。</p>
<span id="more"></span>

<p>行为驱动开发的核心在于“<strong>行为</strong>”。当业务需求被划分为不同的业务场景，并以“Given-When-Then”的形式描述出来时，就形成了一种范式化的领域建模规约。编写领域特定语言的过程，其实就是不断发现领域概念的过程。因此，采用BDD进行开发，最重要的产出不是可以自动运行的验收测试，而是它提供了团队交流的平台，并在其约束之下完成了领域建模。由于团队的不同角色都参与了这个过程，就保证了领域模型的一致性与准确性。</p>
<p>在进行行为驱动开发时，需要避免两种错误的倾向：</p>
<ul>
<li>从UI操作去表现业务行为</li>
<li>描述技术实现而非业务需求</li>
</ul>
<p>例如，我们要编写“发送邮件”这个业务场景，可能会写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scenario: send email</span><br><span class="line"></span><br><span class="line">Given a user &quot;James&quot; with password &quot;123456&quot;</span><br><span class="line">And I sign in</span><br><span class="line">And I fill in &quot;mike@dddpractice.com&quot; in &quot;to&quot; textbox </span><br><span class="line">And fill in &quot;test email&quot; in &quot;subject&quot; textbox</span><br><span class="line">And fill in &quot;This is a test email&quot; in &quot;body&quot; textarea</span><br><span class="line"></span><br><span class="line">When I click the &quot;send email&quot; button</span><br><span class="line"></span><br><span class="line">Then the email should be sent sucessfully</span><br><span class="line">And shown with message &quot;the email is sent sucessfully&quot;</span><br></pre></td></tr></table></figure>

<p>该业务场景描写的不是业务行为，而是用户通过UI进行交互的操作流程。这种方式实则是让用户界面捆绑了你对领域行为的认知。准确地说，这种UI交互操作并非业务行为，例如上述场景中提到的button与textbox控件，与发送邮件的功能并没有关系。或许换一个UI设计，使用的控件又完全不同了。</p>
<p>那么换成这样的写法呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scenario: send email</span><br><span class="line"></span><br><span class="line">Given a user &quot;James&quot; with password &quot;123456&quot;</span><br><span class="line">And I sign in after OAuth authentification</span><br><span class="line">And I fill in &quot;mike@dddpractice.com&quot; as receiver</span><br><span class="line">And &quot;test email&quot; as subject</span><br><span class="line">And &quot;This is a test email&quot; as email body</span><br><span class="line"></span><br><span class="line">When I send the email</span><br><span class="line"></span><br><span class="line">Then it should connect smtp server</span><br><span class="line">And all messages should be composed to email</span><br><span class="line">And a composed email should be sent to receiver via smtp protocal</span><br></pre></td></tr></table></figure>

<p>该场景的编写暴露了不必要的技术细节，如连接到smtp服务器、消息组合为邮件、邮件通过smtp协议发送等。<strong>对于BDD而言，场景应该关注于做什么（what），而不是怎么做（how）。</strong>如果在业务分析过程中，纠缠于技术细节，就可能导致我们忽略了业务价值。在业务建模阶段，业务才是重心，不能舍本逐末。</p>
<p>那么，该怎么写？当我们使用DSL编写业务场景时，不要考虑任何UI操作，甚至需要抛开业已设计好的UI原型，也不要考虑任何技术细节。在编写好业务场景之后，可以验证：如果我们更换了UI设计，调整了UI布局，是否需要修改业务场景？同理，如果我们改变了技术实现方案，是否需要修改业务场景？如下场景采用业务行为的形式编写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scenario: send email</span><br><span class="line"></span><br><span class="line">Given a user &quot;James&quot; with password &quot;123456&quot;</span><br><span class="line">And I sign in</span><br><span class="line">And I fill in a subject with &quot;test email&quot;</span><br><span class="line">And a body with &quot;This is a test email&quot;</span><br><span class="line"></span><br><span class="line">When I send the email to &quot;Mike&quot; with address &quot;mike@dddpractice.com&quot;</span><br><span class="line"></span><br><span class="line">Then the email should be sent sucessfully</span><br></pre></td></tr></table></figure>

<p>我们要将DSL描述的场景视为一种可读的需求规格（Specification），通过它准确地表现领域知识，就可以帮助我们提炼出隐含的领域概念。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scenario: validate the given date for reporting period </span><br><span class="line"></span><br><span class="line">Given the reporting period as prior 13 month to report month</span><br><span class="line">And the reporting month is &quot;April 2018&quot;</span><br><span class="line">When user choose the &quot;April 2017&quot;</span><br><span class="line">Then validation result is true</span><br><span class="line">When user choose &quot;March 2017&quot;</span><br><span class="line">Then validation result is false</span><br></pre></td></tr></table></figure>

<p>场景描述中的ReportingPeriod蕴含了与财务报表相关的领域知识，即有效报表周期为13个月，ReportingPeriod自身应该履行验证给定日期是否有效的职责。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Requirement</tag>
        <tag>BDD</tag>
        <tag>Agile</tag>
      </tags>
  </entry>
  <entry>
    <title>限界上下文的边界</title>
    <url>/boundary-of-bounded-context/</url>
    <content><![CDATA[<img src="/boundary-of-bounded-context/zhangyi.jpg" class="">

<p>边界通过限界上下文来确定，这在领域驱动设计中具有非凡的意义。对应于通用语言，限界上下文是语言的边界，对于领域模型，限界上下文是模型的边界，二者对应于问题空间（Problem Space）的界定。对于系统的架构，限界上下文还确定了应用边界和技术边界，进而帮助我们确定整个系统及各个限界上下文的解决方案。可以说，限界上下文是连接问题空间与解决方案空间的重要桥梁。</p>
<p>那么，限界上下文所界定的边界，究竟是逻辑边界，还是物理边界？这并没有定论，需得依据不同场景而做出不同的决策。</p>
<span id="more"></span>

<h3 id="逻辑边界"><a href="#逻辑边界" class="headerlink" title="逻辑边界"></a>逻辑边界</h3><p>根据业务对领域进行逻辑分解时，分与合是两个矛盾而又统一的概念。合是目标，分是降低复杂度的一种手段。分实则是为了更好的合。通过业务分解，每个分解出来的限界上下文规模就变得更小，因而更容易理解和把控。由于这种分解是从业务相关性来考虑的，使得领域可以更加细分，业务分析师或者领域专家就可以只要求掌握更加细分的专精领域。</p>
<p>从系统的代码模型（Code Model）看，所谓<strong>逻辑边界</strong>有两种表现形式。以Java为例，归纳如下：</p>
<ul>
<li>命名空间级别：逻辑边界仅仅通过命名空间进行界定，但是所有的限界上下文其实都处于同一个模块中，编译后都属于同一个Jar包。</li>
<li>模块级别：在命名空间上是逻辑分离的，而不同限界上下文则属于同一个项目的不同模块，编译后会生成各自的Jar包。若限界上下文之间存在依赖，则在运行时，这些Jar会被同时加载到同一个Java虚拟机中。这里所谓的“模块”，在Java代码中也可以创建为Jigsaw的module。</li>
</ul>
<p>将限定上下文的边界视为逻辑边界是最常见也是最简单的一种形式。一方面逻辑的分离可以保证系统代码的清晰结构，另一方面它也使得限界上下文之间的协作变得更加容易，更加高效。在物理上，限界上下文彼此之间的通信其实是无缝集成的，要重用的领域模型都可以直接访问，并对模型类进行实例化。如下是国际报税系统的逻辑边界（Java）：</p>
<img src="/boundary-of-bounded-context/pwc.jpg" class="">

<p>然而，正所谓<strong>越容易重用，就越容易产生耦合</strong>。编写代码时，我们需要谨守这条无形的逻辑边界，时刻注意不要逾界，并确定限界上下文各自对外公开的接口，避免对具体的实现产生依赖。</p>
<p><strong>采用逻辑边界划分限界上下文的系统架构是单块（Monolithic）架构</strong>，所有的限界上下文都部署在同一个进程中，因此不能针对某一个限界上下文进行水平伸缩。需要对限界上下文的实现进行替换或升级时，会影响到整个系统。即使我们守住了逻辑边界，这种耦合仍然存在，导致各个限界上下文的开发互相影响，团队之间的协调成本也随之而增加。</p>
<h3 id="物理边界"><a href="#物理边界" class="headerlink" title="物理边界"></a>物理边界</h3><p>逻辑边界的坏，正是物理边界的好；反过来，物理边界的坏，同样是逻辑边界的好。<strong>当我们将限界上下文的边界定义为物理边界时，每个限界上下文就变成了一个个细粒度的微服务。</strong></p>
<p>这里，我们需要针对Eric Evans提出的“限界上下文”概念做进一步澄清：<strong>限界上下文究竟是仅仅针对领域模型的边界划分，还是对整个架构（包括基础设施层以及需要使用的外部资源）垂直方向的划分？</strong>正如前面对Eric Evans观点的引用，他在《领域驱动设计》一书中明确地指出：“根据团队的组织、软件系统的各个部分的用法以及物理表现（代码和数据库模式等）来设置模型的边界。”显然，限界上下文不仅仅作用于领域层和应用层。<strong>它是架构设计而非仅仅是领域设计的关键因素。</strong></p>
<p>倘若我们将限界上下文的边界视为物理边界，则可以保证边界内的服务、基础设施乃至于存储资源、中间件等其他外部资源的完整性，最终形成自治的服务。限界上下文之间仅仅通过限定的方式以限定的通信协议和数据格式进行通信，除此之外，彼此没有任何共享，这种架构被称之为<strong>零共享架构</strong>。这种架构的表现形式为：每个限界上下文都有自己的代码库、数据存储以及开发团队，每个限界上下文选择的技术栈和语言平台也可以不同。当每个限界上下文都被物理隔离时，一个限界上下文的开发人员就不能调用另一个限界上下文的方法，或者将数据存储在共享结构中了，这可以避免因为共享带来的耦合。下图为危机分析系统的架构：</p>
<img src="/boundary-of-bounded-context/risk.jpg" class="">

<p>物理分隔开的限界上下文变得小而专，使得我们可以很好地安排遵循2PTs规则的小团队去治理它。然而，这种架构的复杂度也不可低估。限界上下文之间的通信是跨进程的，我们需要考虑通信的健壮性。数据库是完全分离的，当需要关联之间的数据时，需得跨限界上下文去访问，无法享受数据库自身提供的关联福利。由于每个限界上下文都是分布式的，如何保证数据的一致性也是一件棘手的问题。当整个系统都被分解成一个个可以独立部署的限界上下文时，运维与监控的复杂度也随之而剧增。</p>
<h3 id="数据库共享"><a href="#数据库共享" class="headerlink" title="数据库共享"></a>数据库共享</h3><p>在逻辑边界和物理边界中间，还存在一种折中的手段。在考虑限界上下文划分时，分开考虑代码模型与数据库模型，就可能出现在代码上分离，而在数据库层面却存在数据共享的形式，即多个限界上下文共享同一个数据库。</p>
<p>因为没有分库，在数据库层面就可以更好地保证事务的ACID。这或许是该方案最有说服力的证据，但也可以视为是对“一致性”约束的妥协。</p>
<p>数据库共享的问题在于数据库的变化方向与业务的变化方向会不一致。这种不一致性体现在两个方面：</p>
<ul>
<li>耦合：虽然业务上限界上下文之间是解耦的，但是在数据库层面依然存在强耦合关系</li>
<li>水平伸缩：部署在应用服务器的应用服务可以根据限界上下文的边界单独进行水平伸缩，但是在数据库层面却无法做到</li>
</ul>
<p>根据Netflix团队提出的微服务架构最佳实践，其中一个最重要特征就是“<strong>每个微服务的数据单独存储</strong>”。但是服务的分离并不绝对代表数据应该分离。数据库的样式（Schema）与领域模型未必存在一对一的映射关系。在对数据进行分库设计时，如果仅仅站在业务边界的角度去思考，可能会因为分库的粒度太小，导致不必要的跨库关联。因此，我们可以将“数据库共享”模式视为一种过渡方案，不要在一开始设计微服务的时候，就直接将数据彻底分开，而是采用演进式的设计。</p>
<p>为了便于在演进设计中将分表重构为分库，从一开始要<strong>注意避免在两个表之间建立外键约束关系</strong>。某些关系型数据库可能通过这种约束关系提供级联更新与删除的功能，这种功能反过来会影响代码的实现。一旦因为分库而去掉表之间的外键约束关系，需要修改的代码太多，会导致演进的成本太高，甚至可能因为某种疏漏带来隐藏的Bug。</p>
<p>没有外键约束关系可能在当前增加了开发成本，却为未来的演进打开了方便之门。例如，在针对某手机品牌开发的舆情分析系统中，危机查询服务提供对识别出来的危机的查询，需要通过userId获得危机处理人、危机汇报人的详细信息。左图为演进前直接通过数据库查询的方式，右图则切断了这种数据库耦合，改为服务调用的方式：</p>
<img src="/boundary-of-bounded-context/db.jpg" class="">

<p>倘若架构被设计为数据库共享，且两个服务需要操作同一张数据表（这张表被称之为“共享表”），则传递了一个信号，即我们的设计可能出现了错误：</p>
<ul>
<li>遗漏了一个限界上下文，共享表对应的是一个被重用的服务：买家在查询商品时，商品服务会查询价格表中的当前价格，而在提交订单时，订单服务也会查询价格表中的价格，计算当前的订单总额；共享价格数据的原因是我们遗漏了价格上下文，通过引入价格服务就可以解除这种不必要的数据共享。</li>
<li>职责分配出现了问题，操作共享表的职责应该分配给已有的服务：舆情服务与危机服务都需要从邮件模板表中获取模板数据，然后再调用邮件服务组合模板的内容发送邮件；实际上从邮件模板表获取模板数据的职责应该分配给已有的邮件服务。</li>
<li>共享表对应两个限界上下文的不同概念：仓储上下文与订单上下文都需要访问共享的产品表，但实际上这两个上下文需要的产品信息是完全不同的，应该按照限界上下文的边界分开为产品建表。</li>
</ul>
<p>为什么会出现这三种错误的设计？<strong>根本原因还是在于我们没有通过业务建模，而是在数据库中隐式地进行建模</strong>，因而在代码中没有体现正确的领域模型，从而导致了数据库层面的耦合或共享。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Micro Service</tag>
      </tags>
  </entry>
  <entry>
    <title>构建你的技术标签</title>
    <url>/build-your-tech-tag/</url>
    <content><![CDATA[<img src="/build-your-tech-tag/hungry.jpeg" class="">

<p>作为一名程序员，又或者IT工作者，拼搏在技术快速变迁的大潮流中，其实是一种幸运，毕竟我们无需陷入重复的枯燥生活之中。然而要跟上技术发展的脚步，真的太累了，就怕步伐太慢，一不留神你就落伍了。</p>
<p>或许有所谓通才与全才，又有那种最强大脑的天才们学什么都很快，除此之外，如我们这般的普通人，知识无涯生却有涯，就得聪明地利用有限的时间学习真正有用的。这种所谓“有用”，就是指学习之后能够给你贴上明显标签的那类知识。“标签”是一种信号，更像是某种声望。就是当团队面临对应问题时，人们会一拍脑袋首先想到你的那种声望。</p>
<span id="more"></span>

<p>例如说当我们遇见Java并发编程的问题时，我们会首先想到谁？当我们问到Spark数据分析的性能瓶颈时，我们会首先想到谁？当我们发现UI样式在陈旧的浏览器上总是显示混乱时，我们会首先想到谁？当我们因为分布式系统数据不一致问题而停滞不前时，我们会首先想到谁？这样的人，在团队中能找到吗？在公司中能找到吗？在社区中能找到吗？——如果能找到，这是我们的幸运，但为何我们不能成为这样的人？</p>
<p>回到学习问题上，其实就是专和博的问题。二者并不矛盾，但应该找到一个完美的结合点。博是应该的，因为广泛的知识有助于你开阔眼界，开拓思维。例如你可以没有掌握Scala的编程技巧，但并不妨碍你了解多一些Scala的函数特质，从而助力于你在Java中更好的实现。你可以没有使用MongoDB，但这种文档式NoSQL数据库总会给你打开另一扇窗。如果没有广博的知识，你又何从知道选择哪一个需要专精的方向呢？</p>
<p>如果只有博，没有专，就可能沦为“万精油”的角色。敏捷？懂一点；大数据？会一些皮毛；Rust和Go？学过它们的语法；AI？似乎用过TensorFlow；DevOps？使用过Docker算不算？真要碰到问题了，一个都解决不了！这是广博而不精专的悲哀。长此以往，缺乏技术深度的问题会让你在团队中渐渐失去信任感。<strong>做技术，没人耐烦听你的夸夸其谈，做事情才最重要。</strong></p>
<p>我们需要构建自己的技术标签！</p>
<p>现在的技术发展，真是乱花渐欲迷人眼，每一项技术都有十足的魅力和前景，不要做苞谷林的猴子，要做击穿石头的水滴。</p>
<p>这又牵涉到选择的问题。选择什么，这是一个问题。我也常常扣问自己的内心，但我也会坚定自己的底线，因为我明晓自己的优缺点。<strong>明智的选择，就是能够让自己的优势转化为胜势，且能跟进技术发展潮流的技术方向。</strong>AI算是这两年技术和投资的宠儿吧？但我深知自己在数学知识上的短板，与其穷尽经历才能达到AI技术的初级水平，倒不如把珍贵的时光用到能够增强我优势的地方。</p>
<p>除非做研究，<strong>选择的技术还得结合工作实践</strong>。可以事先学习项目用不到的知识，然而若是没有经过实践的锤炼，只靠书本和文章学到的知识，就如在水上漂着：纸上得来终觉浅，绝知此事要躬行。如果在工作中确实没有机会用到，而该技术又如此具有魅力和发展前途，该怎么办？答案是在开源社区中寻找锤炼自己的机会。</p>
<p>话说回来，我的技术标签又是什么？仔细琢磨，发现自己已经不幸沦为“万精油”的境地了。这么一发现，莫名让自己有了一种恐慌感，好像自己刚刚经历了数年的荒岛余生，突然获救回到现实世界一般的惶恐，周遭的情景是如此的陌生，若坠落一般无法掌控的失重感。</p>
<p>昨天，我在冷风中站路边等车，无聊中刷了一遍自己订阅的技术公众号，突然发现好多知识于我已经开始变得陌生了。当人们都在谈论热门的技术问题时，我在做什么？我成为了局外人！我成为了旁观者！</p>
<p>恐慌总要胜于淡漠，如此方能时刻保持对技术的饥饿感。Stay hungry, then keep moving on!</p>
]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>Thinking</tag>
        <tag>Career</tag>
      </tags>
  </entry>
  <entry>
    <title>迪米特法则与重构</title>
    <url>/demeter-law-and-refactoring/</url>
    <content><![CDATA[<p>在面向对象设计的世界里，有一个寻常却又常常为人所忽略的原则——“迪米特（Law of Demeter）”法则。这个原则认为，任何一个对象或者方法，它应该只能调用下列对象：</p>
<ul>
<li>该对象本身</li>
<li>作为参数传进来的对象（也可以是该对象的字段）</li>
<li>在方法内创建的对象</li>
</ul>
<span id="more"></span>

<p>这个原则用以指导<strong>正确的对象协作</strong>，分清楚哪些对象应该产生协作，哪些对象则对于该对象而言，又应该是无知的。如何理解这个原则？我们可以看看David Bock就该原则给出的一个<a href="http://www.ccs.neu.edu/research/demeter/demeter-method/LawOfDemeter/paper-boy/demeter.pdf">绝佳案例</a>。假设一个超市购物的场景，顾客（Customer）到收银台结账，收银员（Paper Boy）负责收钱。我们来看看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Wallet myWallet;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Wallet <span class="title">getWallet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myWallet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wallet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTotalMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalMoney</span><span class="params">(<span class="keyword">float</span> newValue)</span> </span>&#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">(<span class="keyword">float</span> deposit)</span> </span>&#123;</span><br><span class="line">        value += deposit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subtractMoney</span><span class="params">(<span class="keyword">float</span> debit)</span> </span>&#123;</span><br><span class="line">        value -= debit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Paperboy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(Customer myCustomer, <span class="keyword">double</span> payment)</span> </span>&#123;</span><br><span class="line">        Wallet theWallet = myCustomer.getWallet();</span><br><span class="line">        <span class="keyword">if</span> (theWallet.getTotalMoney() &gt; payment) &#123;</span><br><span class="line">            theWallet.subtractMoney(payment);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//money not enough</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们将PaperBoy中<code>charge()</code>方法的代码翻译成这幕小话剧的对白。</p>
<p>“把钱包交出来！”收银员算出顾客要买的商品总价后，“温柔”地对顾客说道。<br>顾客言听计从，赶紧将钱包掏出来，恭恭敬敬地递给收银员。<br>接过钱包，收银员毫不客气地打开，检查里面的钱够不够。噢，不错，钱够了。收银员从钱包取出钱，心满意足地笑了。</p>
<p>如果你是顾客，你敢去这样的超市shopping吗？</p>
<p>对于PaperBoy而言，Wallet不满足迪米特法则三个条件中的任何一个，因此让PaperBoy与Wallet对象直接交互是错误的行为。若从拟人化的角度思考，则Wallet其实属于Customer的<strong>隐私</strong>。如此重要的隐私，怎么能直接交给收银员这个陌生人呢？这里所谓的“隐私”，可以视为是“数据”，是“信息”，是“知识”，因此我们往往又将迪米特法则称之为<strong>“最小知识法则”</strong>。</p>
<p>当我们理解“最小知识法则”时，又可以从<strong>职责</strong>的角度去思考以上代码。对于收银员角色，他的职责应该是负责收钱，而不用去管钱包里的钱够不够，如果够了怎么办，如果不够又该怎么办，这些统统都不属于他的职责。设想一下，当超市里人流如织，大家都在购买商品时，如果每一个收银员都要承担这般的职责时，会出现什么样的景象？所以“最小知识法则”乃善法，在对象社区中，我们就应该刻意减少对象之间彼此深入的了解。了解最小的知识，就意味着依赖最小，彼此产生的影响就会最小。这实际上是KISS（keep it simple and stupid）原则的体现。</p>
<p><strong>信息专家模式</strong>告诉我们：“信息的持有者即为操作该信息的专家。”对于对象，所谓信息就是该对象内部的字段。在前面的例子中，Wallet是Customer的字段，那么操作Wallet的行为自然就应该分配给Customer了。这是题中应有之义。“信息专家模式”其实是面向对象最重要原则<strong>“数据与行为应该封装在一起”</strong>的别名。若在领域建模时能遵循该原则，则可以规避我们设计出贫血模型。</p>
<p>如何修改以上代码？注意，<code>charge()</code>行为仍然属于PaperBoy的职责，因此我们不应该将该方法整体搬迁到Customer中，而应该先进行方法的提取：</p>
<img src="/demeter-law-and-refactoring/demeter-refactor.jpg" class="">

<p>提取的<code>pay()</code>的方法体与<code>charge()</code>方法完全相同，但是在PaperBoy类中却保留了<code>charge()</code>方法，只是这个方法什么也没有做，在接收方法请求后，转而将请求委派给了<code>pay()</code>方法。我们可以这样理解：在抽象层面，收款是收银员的职责；在实现层面，是<code>pay()</code>方法支持了收款行为，该实现归属于顾客。</p>
<p>观察<code>pay()</code>方法，我们发现该方法操作的数据皆来自Customer。我们嗅到了一种坏味道，即Martin Fowler所谓的“特性依恋（Feature Envy）”。对于该坏味道，老马是这样阐释的：“函数对某个类的兴趣高过对自己所处类的兴趣。”不要再嫉妒了，桥归桥，路归路，让方法回到自己最喜欢的地方吧。运用“Move Method”重构手法，将<code>pay()</code>方法移动到Customer中：</p>
<img src="/demeter-law-and-refactoring/demeter-refactor02.jpg" class="">

<p>在将方法移到正确的位置后，我们发现暴露的<code>getWallet()</code>方法根本就没有意义。更何况，将钱包裸露出去，难道是想要炫富吗？还是低调一点为好，隐藏自己的“隐私”，总好过被人觊觎而招来飞来横祸之险。于是，内联（inline）之。</p>
<p>判断一段代码是否违背了迪米特法则，有一个小窍门，就是看调用代码是否出现形如<code>a.m1().m2().m3().m4()</code>之类的代码。这种代码在Martin Fowler《重构》一书中，被名为“消息链条（Message Chain）”，有人更加夸张地名其为“火车残骸”。车祸现场啊，真是惨不忍睹。</p>
<p>那么，如下代码是否这样的残骸呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str.split(<span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line">	.stream()</span><br><span class="line">	.map(str -&gt; str.contains(elementName) ? str.replace(elementName + <span class="string">&quot;=&quot;</span>, <span class="string">&quot;&quot;</span>) : <span class="string">&quot;&quot;</span>)</span><br><span class="line">	.filter(str -&gt; !str.isEmpty())</span><br><span class="line">	.reduce(<span class="string">&quot;&quot;</span>, (a, b) -&gt; a + <span class="string">&quot;,&quot;</span> + b);</span><br></pre></td></tr></table></figure>

<p>不是的。这样的代码我们一般称之为“流畅接口或连贯接口（Fluent Interface）”。二者的区别在于观察形成链条的每个方法返回的是别的对象，还是对象自身。如果返回的是别的对象，就是消息链条。所谓<code>m1().m2().m3().m4()</code>的调用，其实是调用者不需要也不想知道的“知识”，把这些中间过程的细节暴露出来没有意义，调用者关心的是最终结果；而上述代码中的<code>map()</code>与<code>filter()</code>等方法其实返回的还是Stream类。这一调用方式其初衷并非告知中间过程的细节，而是一种<strong>声明式</strong>的DSL表达，调用者可以自由地组合它们。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>Refactoring</tag>
        <tag>Clean Code</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动战略设计工作坊</title>
    <url>/ddd-strategic-design-workshop/</url>
    <content><![CDATA[<img src="/ddd-strategic-design-workshop/01.jpg" class="">

<p>在2018年第二届领域驱动设计中国峰会，我作为讲师做了一个领域驱动战略设计工作坊——再现具有实操价值的架构方案。在这个工作坊中，我将敏捷实践中的Inception与领域驱动战略设计结合起来，并引入Event Storming和用例场景分析等方法，带着大家一起糊了墙，玩风暴，算是满意地完成了战略设计的预期目标。在这次工作坊的参与者中，我欣喜地看到了业务同学的加入。这些业务同学敏锐的分析目光与业务感给我们的用例场景分析带来了极好的助力，也为整个工作坊增加了不少亮点。</p>
<p>我把整个工作坊分为了十个步骤，依次为：</p>
<ul>
<li>确定利益相关人</li>
<li>确定业务期望和愿景</li>
<li>对问题域的共同理解</li>
<li>确定项目的业务范围</li>
<li>确定业务流程</li>
<li>史诗级故事和主故事</li>
<li>运用用例分析场景</li>
<li>通过边界识别限界上下文</li>
<li>上下文映射</li>
<li>领域架构</li>
</ul>
<p>我选择一些重要步骤对整个工作坊做一个简单的回顾。</p>
<span id="more"></span>

<h3 id="对问题域的共同理解"><a href="#对问题域的共同理解" class="headerlink" title="对问题域的共同理解"></a>对问题域的共同理解</h3><p>我认为：“对问题域（Problem Domain）的识别其实就是对客户痛点的识别。之所以要开发这个软件，目的就是解决这些痛点，为应对这些问题提供具有业务价值的功能。在识别痛点的过程中，需要始终从业务期望与愿景出发，与不同的利益相关人进行交流，如此才能达成对问题域的共同理解。”在工作坊中，一位业务人员补充了我对问题域定义的不足，她认为问题域不仅是对<strong>痛点</strong>的识别，还包括系统所要提供的<strong>价值</strong>。</p>
<p>ThoughtWorks的禚娴静则以淘宝和京东的例子提出了她对问题域的看法，她认为，虽然这两家都是电商系统，但二者的核心价值并不相同。淘宝的核心价值是为买家提供物美价廉的商品，京东的核心价值则是提供快速便捷的物流。对于京东而言，物流问题域会作为一个核心领域而存在。</p>
<p>通过分析系统的业务期望和愿景，有团队针对问题域做出了颇具价值的抽象，如下图所示，他们提炼出“需、控、供、决策”这四个核心问题域：</p>
<img src="/ddd-strategic-design-workshop/02.jpg" class="">

<p>另一个团队则从价值和服务两个维度对整个系统的问题域进行了清晰的划分：</p>
<img src="/ddd-strategic-design-workshop/03.jpg" class="">

<p>现场探讨了问题域与解决方案域之间的区别，进而也谈到了核心域、子域与限界上下文之间的关系。我的观点可以用这样一幅图来表达：</p>
<img src="/ddd-strategic-design-workshop/04.jpg" class="">

<h3 id="确定项目的业务范围"><a href="#确定项目的业务范围" class="headerlink" title="确定项目的业务范围"></a>确定项目的业务范围</h3><p>之所以要确定项目的业务范围，是为了明确整个系统的边界。明确系统边界是架构设计的重要前提，它一方面可以明确职责划分，了解哪些内容才属于领域驱动设计的范畴；另一方面则可以事先明确当前系统需要与哪些外部系统集成。</p>
<p>我引入了Simon C4模型中的System Context来确定系统的边界：</p>
<img src="/ddd-strategic-design-workshop/05.jpg" class="">

<p>在这个过程中，我们要将自己设计的系统视为一个黑盒子，假设它已经实现，再来考虑它需要与哪些角色以及外部系统、外部资源进行协作。System Context除了可以帮助我们确定系统的边界之外，还有利于推动我们开展build vs buy的决策。如果是购买第三方软件系统或服务，则该系统或服务就将作为本系统协作的外部系统。</p>
<h3 id="运用用例分析场景"><a href="#运用用例分析场景" class="headerlink" title="运用用例分析场景"></a>运用用例分析场景</h3><p>一个主用例可以认为是一个具有业务价值的业务功能。我提出的用例场景分析步骤为：</p>
<ul>
<li>确定业务流程，通过业务流程识别参与者（Actor）；</li>
<li>根据每个参与者识别属于该参与者的用例，遵循一个参与者一张用例图的原则，保证用例图的直观与清晰；</li>
<li>对识别出来的用例根据语义相关性和功能相关性进行分类，确定用例的主题边界，并对每个主题进行命名。</li>
</ul>
<p>首先，我让学员通过识别系统的参与者驱动用例的识别。一个参与者一个用例图，可以让我们的用例分析既有清晰的分析起点，又能保证用例图的清晰直观：</p>
<img src="/ddd-strategic-design-workshop/06.jpg" class="">

<p>运用用例进行场景分析时，不必死板地抱着UML的规则行事，但用例图的根本价值仍然值得重视。例如参与者与用例的use关系体现了用例的价值（Why），用例的描述应采用简洁明了的动宾短语，识别用例之间的包含与扩展关系等。在工作坊演练过程中，我让学员使用不同颜色的即时贴来表达用例，例如黄色代表Actor，蓝色代表主用例，绿色代表扩展或包含用例。这样就有助于整个团队在进行场景分析时的沟通与协作，俗称“糊墙”：</p>
<img src="/ddd-strategic-design-workshop/07.jpg" class="">

<p>当然，你也可以放在桌面上进行：</p>
<img src="/ddd-strategic-design-workshop/08.jpg" class="">

<p>一旦准确地识别出用例，再根据语义相关性和功能相关性对这些用例进行分组，最后，确定主题边界（Subject Boundary）就变得相对容易了。以下是其中四个团队分别给出的主题边界分组：</p>
<img src="/ddd-strategic-design-workshop/09.jpg" class="">
<img src="/ddd-strategic-design-workshop/10.jpg" class="">
<img src="/ddd-strategic-design-workshop/11.jpg" class="">
<img src="/ddd-strategic-design-workshop/12.jpg" class="">

<p>这些识别出来的主题边界其实就是限界上下文的候选了。可以看到，不同团队因为需求理解的不同，识别出来的主题边界确实存在差别，但这个差别是非常细微的，基本能就限界上下文的边界达成一致。这些识别出来的用例同时也将作为统一语言的一部分，在后续的领域建模和战术设计中提供非常有价值的指导。</p>
<h3 id="领域架构"><a href="#领域架构" class="headerlink" title="领域架构"></a>领域架构</h3><p>在架构层面，我引入了RUP的4+1视图，这样可以使得领域驱动战略设计的成果显得更加系统化，能够为业务人员、开发人员、运维人员提供不同视角的架构指导。例如获得的逻辑视图可以非常清晰地表达系统层面与限界上下文层面各自的逻辑组成：</p>
<img src="/ddd-strategic-design-workshop/13.jpg" class="">

<p>进程视图则使用时序图针对那些需要异步处理或分布式通信的用例进行了清晰刻画：</p>
<img src="/ddd-strategic-design-workshop/14.jpg" class="">

<p>至于开发视图则为后续的领域驱动战术设计提供了重要的指导，明确了每个模块（包）的职责以及它们在逻辑架构中所处的位置：</p>
<img src="/ddd-strategic-design-workshop/15.jpg" class="">

<p>针对这样的战略设计工作坊，我们既要有高屋建瓴的系统理论，又需要让这些理论和方法能够落地，成为具有实操价值的一种工作坊形式。我充分借鉴了事件风暴这种新方法，却又未完全抛弃UML这种老方法，采用各取所长的手段将二者结合起来，形成一种行之有效的设计手法，有助于大家清晰地认识问题域，并通过场景分析寻找解决方案域中最重要的限界上下文。这一方法同样可以帮助我们进行微服务设计，毕竟，从某种角度讲，一个限界上下文就可以等于是一个微服务。</p>
<p>特别强调的是，在整个工作坊设计过程中，我们需要抛开技术因素对我们的干扰，只能由业务来驱动我们的设计。这就需要团队充分地与领域专家或需求分析人员进行沟通和交流。只有在最后确定限界上下文的粒度与边界，以及探讨限界上下文之间的协作时，我们才能揭开技术的面纱，从技术复杂度的角度去进一步地分析，直到得到就目前而言恰如其分的领域架构。</p>
<p><strong>说明：</strong>工作坊用到的系统需求文档以及工作坊讲义可以通过关注我的微信公众号。发送“工作坊”消息可获得工作坊讲义，发送“需求”可获得工作坊用到的系统需求文档。</p>
<img src="/ddd-strategic-design-workshop/qrcode_rabbit.jpg" class="">

]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Architecture</tag>
        <tag>Micro Service</tag>
      </tags>
  </entry>
  <entry>
    <title>限界上下文的菱形对称架构</title>
    <url>/diamond-symmetry-architecture-of-bounded-context/</url>
    <content><![CDATA[<img src="/diamond-symmetry-architecture-of-bounded-context/chat.jpg" class="">



<p>我在GitChat上最新开通了一个Chat，主题为：限界上下文的菱形对称架构。为有利于搜索，更名为：领域驱动设计的菱形对称架构，但主要针对的是领域驱动设计的核心模式：限界上下文（Bounded Context）。订阅链接为：<a href="https://gitbook.cn/m/mazi/activity/5e55150b238b2a7efa28c297?sut=a4e7d37057cd11ea9c3fc7812f451dce&amp;utm_source=chatweixinshare">https://gitbook.cn/m/mazi/activity/5e55150b238b2a7efa28c297?sut=a4e7d37057cd11ea9c3fc7812f451dce&amp;utm_source=chatweixinshare</a></p>
<p>在实施领域驱动设计的过程中，限界上下文扮演了关键角色：它既是维护领域模型完整性与一致性的重要边界，又是系统架构的重要组成部分。随着社区对限界上下文的重视，越来越多的人开始尝试将更多的架构实践与限界上下文融合在一起，创造出符合领域驱动设计的架构模式。</p>
<p><strong>菱形对称架构（Diamond Symmetry Architecture）模式</strong>脱胎于六边形架构与分层架构，它以领域为核心对限界上下文的关注点进行划分，建立了由<strong>内部领域模型</strong>与<strong>外部网关</strong>组成的内外分层架构，以菱形的对称结构清晰展现了限界上下文的内部结构，指导着限界上下文的协作关系。引入菱形对称架构有助于促进团队对限界上下文与上下文映射的一致理解，并促成团队形成统一的代码模型。</p>
<img src="/diamond-symmetry-architecture-of-bounded-context/diamond.png" class="">



<p>在本场Chat中，会讲到如下内容：</p>
<ul>
<li><p>六边形架构与整洁架构</p>
</li>
<li><p>领域驱动设计分层架构</p>
</li>
<li><p>菱形对称架构的形成</p>
</li>
<li><p>菱形对称架构对元设计模型的改造</p>
</li>
<li><p>菱形对称模型对架构的指导</p>
</li>
</ul>
<p><strong>适合人群：</strong>具有领域驱动设计基础的架构师、开发人员</p>
<p>如果订阅人数在六天内达到120人，本次Chat就算成功，接下来就是发布这次分享内容的文章。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Architecture</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>讨论实际项目的工厂模式</title>
    <url>/discuss-with-factory-pattern-in-real-project/</url>
    <content><![CDATA[<img src="/discuss-with-factory-pattern-in-real-project/2021-02-01.jpeg" class="">

<p>大思接了满满一杯热咖啡，正欲离去，转身时，偶然瞥见茶水间的白板画满了类图，定睛一看，感慨地说道：“蔡了，你还真是幸福啊！马大叔亲自给你讲解工厂模式。”</p>
<p>蔡了刚刚意识到自己说错了话，还在尴尬中，赶紧说道：“是啊，是啊！”一边说着，一边还使劲地点着头，希望通过过分的礼貌来化解刚才的口不择言。</p>
<p>成大思想到了自己过去学习设计模式的经历，悠悠地说道：“说起来，当初我学设计模式时，可没有你这么好的待遇了。”</p>
<p>这一番话倒是勾起了蔡了的好奇心，赶紧问道：“大思，那你当时是怎么学的呢？”</p>
<span id="more"></span>

<p>既然有了谈兴，成大思也在沙发坐下来，慢条斯理地说道：“当初我刚入行没多久，就接到一个开发任务，让我独自完成一个报表组件的设计与开发。这一报表组件是公司应用框架的一部分，需要支持微软的水晶报表和用友的华表。说起来，现在的程序员可能都没听说过这两款报表产品了吧。”谈到过去，同样作为职场老人的马丁花似乎深有同感，举起手里的咖啡，如饮酒一般向大思隔空敬过，二人各自仰头吞了大大一口苦涩的浓咖啡，长吁短叹，对视无言，油然而生英雄迟暮之感。</p>
<p>95后的蔡了哪里能体悟IT历史的往昔与荣光，继续如好奇宝宝地追问：“后来呢？”</p>
<p>大思回过神，继续讲道：“我接到任务后，想了许久，也不知该如何设计才能灵活地支持各种报表，无奈之下，只得去寻求项目经理的帮助。项目经理听了我的问题，丢下一句‘用工厂模式可以解决’，然后就酷酷地抛下我不管了。没有办法，好歹给我指点了明灯，于是我就开始上穷碧落下黄泉地寻找工厂模式的资料。那时候，哪有这么多讲解设计模式的资料？主要的参考资料还是GOF的《设计模式》。说起来，虽然这本书的讲解稍显晦涩，但它才是设计模式的正宗心法啊！蔡了，你可以好好读读这本书！”</p>
<img src="/discuss-with-factory-pattern-in-real-project/design-patterns.jpeg" class="">

<p>蔡了谢过大思的推荐，继续追问：“那你最后是如何设计的呢？”</p>
<p>“真要理解了工厂方法模式，说起来也不难。我对这两种报表进行了抽象，分别定义了报表对象（<code>ReportObject</code>）、报表处理器（<code>ReportProcessor</code>）和报表格式器（<code>ReportFormatter</code>），毫无疑问，它们都具有各自的继承体系，可以引入工厂来创建它们。”</p>
<p>说到这里，大思拿起板擦，问道：“白板上的内容可以擦掉吧？”这时的蔡了倒是学会了察言观色，赶紧抢过大思手中的板擦，说道：“我来！我来！”三下五除二，白板擦得干干净净。大思在白板上画下了这样的类图：</p>
<img src="/discuss-with-factory-pattern-in-real-project/report-factory.png" class="">

<p>“这不就是抽象工厂模式吗？”蔡了惊喜地嚷道。</p>
<p>“不错！”成大思答道，“说起来，这一设计方案都过去十多年了，我至今对这一方案依旧历历在目，毕竟这是我第一次独立设计一个组件。”</p>
<p>“所以说，还是要做实际的项目才能锻炼人！”马丁花补充道，然后对蔡了道：“听别人讲授设计知识固然能快速帮助你理清思路，掌握知识窍门，但没有经过你自己的思考，不可能真正掌握，更不用说合理地运用到项目中。这样吧，给你布置一个学习任务，利用业余时间学习slf4j日志框架。我们项目也使用了这一框架，你应该知道它的用法，对吧？”</p>
<p>蔡了点头称是。</p>
<p>马丁花继续说道：“slf4j框架灵活地运用了设计模式，也包括今天提到的工厂模式。针对slf4j如何创建一个<code>Logger</code>，你可以查阅相关资料，并阅读slf4j的源代码，深入了解其设计手段，写一份学习笔记。”</p>
<p>三人结束了这番在茶水间的谈话，留给蔡了的又是一份没法拒绝的学习礼物。</p>
<hr>
<p>三天后，蔡了向马丁花交付了一份学习笔记。内容如下：</p>
<p>slf4j本身是一个日志框架，为了让Java开发人员可以采用同一种方式使用日志，它又很好地集成了logback、log4j等其他日志框架。为此，它定义了标准的日志接口，slf4j的slf4j-simple日志框架与logback都实现了日志接口。由于log4j的诞生要早于slf4j，则专门提供了slf4j-log4j12将log4j整合到slf4j中。</p>
<p>不管是什么样的日志框架，只要使用slf4j，都可以通过如下代码来创建<code>Logger</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Demo.class);</span><br></pre></td></tr></table></figure>

<p><code>LoggerFactory</code>的<code>getLogger()</code>方法就是简单工厂模式的体现。在<code>getLogger()</code>方法内部，具体创建什么样的<code>Logger</code>，又由<code>ILoggerFactory</code>工厂来决定的。<code>ILoggerFactory</code>工厂和它创建的<code>Logger</code>就是slf4j定义的通用日志对象接口。以logback为例，它定义了自己的日志工厂和日志对象，实现了slf4j的接口，如果其他日志框架，如log4j需要slf4j作为统一的日志入口，也需要实现这些接口。</p>
<img src="/discuss-with-factory-pattern-in-real-project/logger.png" class="">


<p>这实际上是工厂方法模式的体现。</p>
<p>slf4j具体使用了哪一个日志框架，取决于项目依赖的日志包。只要将对应的日志系统jar包加入到项目中，slf4j就会自动选择使用它。例如，倘若添加这样的Maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;logback.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>意味着slf4j会使用logback日志框架。</p>
<p><code>ILoggerFactory</code>对象的创建由slf4j来决定，不需要进行配置，更不需要人为的修改创建代码。怎么才能做到这一点呢？</p>
<p>我仔细阅读了slf4j的源代码，又查阅了相关的资料，发现slf4j具体选择哪一个<code>ILoggerFactory</code>，是由<code>LoggerFactoryBinder</code>决定的，可以将它理解为是日志工厂的工厂，在slf4j框架中，将其形象地称之为一种绑定（bind）操作。</p>
<p>根据这一设计，我最初以为slf4j要通过反射创建不同日志框架的<code>LoggerFactoryBinder</code>对象，后来发现<code>LoggerFactoryBinder</code>接口只有一个实现类，即<code>StaticLoggerBinder</code>。<code>LoggerFactory</code>调用了它的<code>getSingleton()</code>方法获得<code>StaticLoggerBinder</code>对象，再由此获得<code>ILoggerFactory</code>工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StaticLoggerBinder.getSingleton().getLoggerFactory()</span><br></pre></td></tr></table></figure>

<p>我翻阅了成大思推荐的《设计模式》，了解到创建<code>StaticLoggerBinder</code>对象的这种方式称之为单例模式。我站在调用者的角度去思考，发现这一设计可以高效地获得<code>StaticLoggerBinder</code>对象，因为它可以避免对象的频繁创建。</p>
<p>由于<code>getSingleton()</code>是<code>StaticLoggerBinder</code>的静态方法，因此<code>LoggerFactory</code>对它是类型依赖的，做不到实例方法的多态扩展。实际上，这个类的名称也说明了它采用了静态方式绑定了日志工厂。这就要求所有实现了slf4j接口的日志框架，都需要定义这个类，且这个类的classpath应该保持一致。在slf4j的<code>LoggerFactory</code>中定义了这个类的路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String STATIC_LOGGER_BINDER_PATH = <span class="string">&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>查看logback的JAR包，确实在指定位置发现了该类：</p>
<img src="/discuss-with-factory-pattern-in-real-project/binder.png" class="">


<hr>
<p>马丁花收到这份作业后，不禁抓了抓已经日渐稀薄的头发，心里哀叹，要培养一个新人，还有很长的一条路要走。是否让蔡了继续深入研究slf4j这一框架呢？马丁花陷入了沉思中。</p>
]]></content>
      <categories>
        <category>蔡了成长记</category>
      </categories>
      <tags>
        <tag>Design, OO</tag>
      </tags>
  </entry>
  <entry>
    <title>事件风暴的设计要素与驱动力</title>
    <url>/event-storming-distill/</url>
    <content><![CDATA[<img src="/event-storming-distill/cover.jpg" class="">

<p>个人认为，相比较传统领域分析方法，<a href="https://www.eventstorming.com/">事件风暴</a>的革命意义在于它建立了以“领域事件”为核心的建模思路，这相当于改变了我们观察业务领域的世界观。当我们在理解业务需求时，我们看到的常常是功能、流程，并通过从需求描述中梳理领域概念，进而借助这些概念去识别那些参与到业务场景中互为协作的领域对象，这往往让我们忽略了一个在任何领域中都必须存在的概念，即“<strong>事件</strong>”。这些事件是每次用户操作、业务活动留下来的不可磨灭的足迹，它牵涉到状态的迁移，业务事实的发生，忠实地记录了每次执行命令后可能产生的结果。倘若这些事件还直接影响到该领域的运营和管理时，则可以将它们认为是“关键事件”。</p>
<p>正如Martin Fowler对领域事件的定义：“重要的事件肯定会在系统其它地方引起反应，因此理解为什么会有这些反应同样也很重要。”在识别和理解事件时，正是要从这样的因果关系着手，考虑为什么要产生这一事件，以及为什么要响应这一事件，进而思考如何响应这个事件，驱动着设计者的“心流”不断思考下去，就像搅动了一场激荡湍急的风暴一般。我想着或许是Alberto Brandolini将其命名为事件风暴的缘由吧。</p>
<span id="more"></span>

<p>在事件风暴中，往往使用橙色标签来代表一个“关键事件”。由于事件代表的是一个已经发生的事实（fact），所以往往用动词的过去时态来表达，例如<code>OrderConfirmed</code>事件。</p>
<p>在识别“事件”时，团队应与业务人员一起通过梳理业务流程，在统一语言的指导下共同寻找这些可能直接影响业务价值与运营目的的“关键事件”。在一个业务场景中，一系列“关键事件”连接起来，会形成明显的基于一条时间线的状态迁移过程。如下图所示：</p>
<img src="/event-storming-distill/01.png" class="">

<p>这种状态迁移过程体现了业务的<strong>因果关系</strong>。这种因果关系是一种不断传递的过程，导致事件发生的因，在事件风暴中被称之为<strong>命令（Command）</strong>，相当于事件的发布者，在事件风暴中使用蓝色标签来表示。一旦事件发生，作为该命令的结果又可能引起别的业务反应，事件的订阅者关心这一结果，然后触发新的命令，变成了下一个流程的起因。命令往往由动宾短语组成，例如Place Order、Send Invitation等。</p>
<p>注意，在识别事件时，要注意区分触发事件的四种情形：</p>
<ul>
<li>由用户活动触发：例如用户将商品加入到购物车</li>
<li>外部系统：支付系统返回交易凭证</li>
<li>时间消逝导致：订单的支付时间超时</li>
<li>另一个领域事件的结果：支付命令产生支付完成事件（PaymentProcessed），该事件导致订单完成事件（OrderCompleted）</li>
</ul>
<p>事件由命令触发，那么谁又是命令的发起者呢？答案是<strong>参与者（Actor）</strong>。参与者的引入就将对事件的分析与业务场景结合起来，这就驱动着参与事件风暴的所有成员要对业务达成一致（形成统一语言），并从用户体验（User Experience）的角度去分析每个业务场景。这时作为参与者对业务的参与，就不再是发起一个业务流程，执行一个业务动作，而是<strong>做出决策（Decision）</strong>。在事件风暴中，决策就是命令，但“决策”更具有拟人化的意义，正如在现实生活中，当一个管理者要做出决策时，需要如下两方面数据的支撑：</p>
<ul>
<li>信息：必须基于足够充分的信息才能做出正确的决策，提供这些信息的对象就称之为<strong>读模型（Read Model）</strong>，在事件风暴中用绿色标签表示。</li>
<li>策略：一旦做出决策就会触发一个业务流程，流程的执行暗含了业务规则，该规则被命名为<strong>策略（Policy）</strong>，在事件风暴中用紫色标签表示。</li>
</ul>
<p>描述策略时，往往可以使用“一旦（Whenever）”这个关键字来引导对策略规则的描述。策略引发的决策可以是自动的，也可以是参与者人为触发的。Alberto Brandolini给出了描述策略的实例，如：</p>
<ul>
<li>whenever the exposure passes the given threshold, we need to notify the risk manager.  一旦关注的值超出给定的阈值，我们就需要通知风险管理者。</li>
<li>whenever a user logs in from an new device, we send him an SMS warning. 一旦用户从一个新设备中登录，我们就应该给用户发送一条短信警告。</li>
</ul>
<p>在运用事件风暴时，我们可以通过用户体验（例如用户旅程等UX方法）剖析业务场景，从参与者到命令再到事件，又可以围绕着表达状态迁移的事件为核心，将策略与读模型组合在一起帮助我们推导出命令对象。Alberto Brandolini整体描述了事件风暴的驱动过程：</p>
<img src="/event-storming-distill/02.jpg" class="">

<p>一旦我们识别了事件和对应的命令，我们就可以根据这些对象的生命周期与职责内聚性识别出<strong>聚合（Aggregate）</strong>与聚合根。聚合在事件风暴中使用黄色标签来表示。聚合是命令的<strong>真正</strong>发起者，这是相对于前面提到的参与者而言。在问题域中，是由参与者（用户、系统或其他特殊组件，如定时器）发起命令来“开启”一个业务流程。但在解决方案域，我们是从职责的角度去看待命令的，这就需要在领域模型中去寻找履行该职责的对象，即聚合。例如，在电商系统的业务流程中，问题域表达的是“买家购买了商品”，对应的解决方案域，则是“购物车添加了购物项”，因此分析获得<code>ShoppingCart</code>这个聚合对象。</p>
<p>一旦获得了这些内聚的聚合，就可以根据各自的相关性对聚合进行分组，从而获得限界上下文。在获得限界上下文的过程中，可以从业务、团队合作与技术实现等诸多方面进行判定。由于限界上下文属于解决方案域的内容，在初步获得限界上下文之后，团队就可以考虑这些限界上下文的技术实现。尤其是在微服务架构下，需要针对微服务特征来确定限界上下文的粒度与边界是否合理。此时，我们可以引入上下文映射，通过识别限界上下文之间的协作关系进一步确认它的合理性。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
        <tag>Event Storming</tag>
      </tags>
  </entry>
  <entry>
    <title>运用事件风暴进行领域分析建模</title>
    <url>/event-storming-with-domain-model/</url>
    <content><![CDATA[<img src="/event-storming-with-domain-model/10.png" class="">

<p>在确定了全景事件流之后，可以在战略设计层面继续精进，鉴别出领域与限界上下文的边界。这里略过不提，且进入战术设计阶段的领域分析建模。</p>
<span id="more"></span>

<h3 id="事件风暴的分析模型要素"><a href="#事件风暴的分析模型要素" class="headerlink" title="事件风暴的分析模型要素"></a>事件风暴的分析模型要素</h3><p>通过事件风暴进行领域分析建模，其核心的模型要素就是“事件”。除此之外，参与事件风暴的分析模型要素还包括决策命令、读模型、策略和聚合。其中，事件和策略已经在探索业务全景的时候进行了初步识别。</p>
<h4 id="决策命令"><a href="#决策命令" class="headerlink" title="决策命令"></a>决策命令</h4><p>通观事件之起因，除了外部系统是直接发布事件之外，无论是用户活动，还是满足某个条件，都需要一个<strong>命令（Command）</strong>来响应，它才是直接导致事件发生的“因”。在事件风暴中，Alberto Brandolini将命令称之为“决策命令（Decision Command）”，使用<strong>浅蓝色即时贴</strong>表示。决策命令往往由动宾短语组成，例如Place Order、Send Invitation等。</p>
<p>由于决策命令和事件存在因果关系，因此二者往往是一一对应的。例如，Cancel Order决策命令会触发OrderCancelled事件，Subscribe Course决策命令会触发CourseSubscribed事件。正是这种一一对应关系，使得它们存在语义上的重叠，区别仅在于时态。故而有的事件风暴实践者认为可以在事件风暴中省略决策命令。我并不敢苟同这一观点，相反，我反而极为强调<strong>决策命令在事件风暴中的重要性</strong>，它是领域分析建模的一个重要驱动力，因为通过<strong>它连接了用户、策略、聚合、读模型和事件</strong>，如下图所示：</p>
<img src="/event-storming-with-domain-model/01.jpg" class="">

<p>从图中可以看出，由<strong>事件</strong>可以驱动出<strong>决策命令</strong>，在它们之间籍由<strong>聚合</strong>对象来发布事件。当事件发生后，如果某个<strong>策略</strong>满足条件，也会引发决策命令，而<strong>用户</strong>在引发决策命令时，需要足够的<strong>读模型</strong>来帮助它做出正确的决策。</p>
<p>那么，该如何正确地理解决策命令？显然，Alberto Brandolini使用决策来修饰命令并非空穴来风，因为这一名词突出了命令往往需要更多的信息来帮助参与者（Actor）做出决策。参与者是用例图的设计要素，在事件风暴中，可以认为是对所有事件起因的抽象：用户、条件满足（如定时器）与外部系统。其中，外部系统对我们而言是一个黑盒子，不用考虑它是如何触发了事件，因而可以忽略。因此，参与者在基于业务场景做出决策时，需要如下两方面数据的支撑：</p>
<ul>
<li>信息：必须基于足够充分的信息才能做出正确的决策，提供这些信息的对象被称之为<strong>读模型（Read Model）</strong>，在事件风暴中用<strong>浅绿色即时贴</strong>表示。</li>
<li>策略：根据业务规则，当某个条件满足时，会触发一个决策命令，这个业务规则被命名为<strong>策略（Policy）</strong>，在事件风暴中用<strong>紫色标签</strong>表示。</li>
</ul>
<h4 id="读模型和策略"><a href="#读模型和策略" class="headerlink" title="读模型和策略"></a>读模型和策略</h4><p>当决策命令由用户引发时，可以确认该决策命令的发生是否需要提供足够的读模型信息。读模型是用户通过查询（读）操作获得的。若不具备这一信息，可能不足以支持用户执行决策命令。例如买家希望提交订单，就需要先查看购物车获得购物车内容，然后才能执行下订单（Place Order）的决策命令，触发OrderCreated事件。这时，查看购物车获得的结果ShoppingCart就是读模型：</p>
<img src="/event-storming-with-domain-model/02.jpg" class="">

<p>读模型是用户执行决策命令必需的输入信息，在代码层面，这些读模型就是执行决策命令的领域行为所需的输入参数。用户发起决策命令的方式是因为执行了某个活动，例如决策命令“提交订单”实则是因为用户点击了“提交订单”按钮。用户活动的执行与用户体验（User eXerperience，UX）直接有关。现实世界的业务场景通过用户体验将用户与读模型结合起来，把信息传输给事件风暴的决策命令。这一过程牵涉到用户、查询和命令操作，恰好符合组成用例的要素。若建模人员熟悉用例，也可借助用例图来分析。</p>
<p>注意，上图是将读模型ShoppingCart提供给Place Order决策命令，而非查询操作与命令操作之间的交互。有的事件风暴实践者将查询操作也纳入到事件风暴的模型中，认为是用户执行查询操作获得读模型后，触发了决策命令，如下图所示：</p>
<img src="/event-storming-with-domain-model/03.jpg" class="">

<p>我认为这样的模型设计并不恰当，因为它<strong>将活动流程图与事件的因果关系混为一谈</strong>了。实际上，活动流程图反应了现实世界的问题域，事件风暴表现的事件因果关系却是解决方案域的内容，这是领域建模活动中两个不同的层次。买家先查询购物车，然后提交订单，这是买家的操作流程。但从事件的因果关系看，并非“查询购物车”触发了“提交订单”这个决策命令，而是用户通过查询获得了购物车读模型之后，由用户发起“提交订单”的决策命令，再通过订单聚合发布了OrderCreated事件。“查询购物车”和“提交订单”是两个不同的用户活动，它们并不具有时序上的连续性，可以认为是两个独立的业务场景。由于查询操作并不会触发事件的发生，从模型上看，它也不会导致命令的发生，因而在事件风暴中，<strong>并没有查询操作的位置</strong>，而是以读模型的形式出现。这也变相地促使建模人员在识别用户活动时，需要分辨该活动究竟是查询还是命令，有利于CQRS模式的落地。</p>
<p>当决策命令由策略引发时，就表示事件发生后某些数据满足了某条业务规则。一旦该策略被满足，就会引起目标对象的状态变更，然后根据业务规则的规定触发下一个决策命令。例如，策略“提交订单后，一旦超过规定时间未支付，则取消订单”会触发Cancel Order命令，从而引起OrderCancelled事件的发生。策略引发的决策可以是自动的，如定时器检测到支付时间超时；也可以是用户手动触发，如用户登录时输入错误密码的次数太多；还可以二者并存，如在取消订单业务场景中，Cancel Order命令既可以由定时器自动触发，也可以由用户手动触发。</p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>虽然决策命令和事件之间存在因果关系，但事件并非直接由决策命令发布，而是借助一个“媒介”来发布事件。这个媒介就是“聚合（Aggregate）”。聚合在事件风暴中使用<strong>黄色大即时贴</strong>来表示。<strong>聚合划分了现实世界和模型世界之间的界线</strong>。在现实世界，是用户执行了决策命令触发了事件；在模型世界，是聚合履行了发布事件的职责。例如，在电商系统的业务流程中，现实世界的用户活动是用户提交了订单；在模型世界，是Order聚合发布了OrderCreated事件。</p>
<p>寻找聚合的过程可能是一个艰难的过程。由于聚合是构成领域分析模型的核心要素，识别聚合需要审慎，不要轻易下结论。若未寻找到它，可以先贴上一个空白的黄色大即时贴表示这里存在一个聚合，但目前还不知道它的名字。</p>
<p>在事件风暴中，我们也可以利用事件来反向寻找聚合。分析事件的特征，由于它是由决策命令触发的，意味着事件的产生会带来<strong>目标对象状态的变化</strong>。状态的变化分为三种形式：</p>
<ul>
<li>从无到有：意味着创建，例如“订单已创建”事件标志着新订单的产生；</li>
<li>修改属性值：意味着值的更新，例如“订单已取消”事件使得订单从之前的状态变更为“已取消”状态；也可能意味着内容的变化，例如“商品被加入到购物车”事件，说明购物车增加了一个新的条目；</li>
<li>从有到无：意味着删除，不过在多数项目中并不存在这种状态变化；表面是删除，实际是修改属性值。例如“会员已注销”事件和“商品已下架”事件，实则都不是直接删除会员和商品记录，而是将该记录的状态置为“已注销/已下架”状态。</li>
</ul>
<p>显然，发生状态变更的对象有很大几率就是我们要寻找的聚合对象。毕竟聚合对象承担了发布事件的职责，而事件又是由于状态变更而产生。谁能准确地侦知状态是否变更以及何时发生变更？我想，只有拥有状态的聚合对象自身才具备这一能力。</p>
<h3 id="事件风暴的领域分析建模过程"><a href="#事件风暴的领域分析建模过程" class="headerlink" title="事件风暴的领域分析建模过程"></a>事件风暴的领域分析建模过程</h3><p>显然，围绕着“事件”为中心，事件风暴给出了一条有章可循的领域分析建模路径。领域分析建模的基础是探索业务全景的产出物，即业已识别出来的事件流，以及参与事件流的用户、策略与外部系统。整个领域分析建模的过程如下：</p>
<ul>
<li>第一步：挑选任意一个与用户有关的事件，反向驱动出决策命令，该用户就是发出决策命令的人（角色）。从事件驱动出决策命令非常容易，就是将事件的过去时态转换为动宾形式的决策命令即可。</li>
<li>第二步：根据决策命令与事件之间的因果关系，推导出要发布该事件必须的前置信息，即决策所需的读模型。读模型通常由用户通过查询操作获得，可以理解为是决策命令行为的输入参数。</li>
<li>第三步：根据事件状态变更的目标，决定决策命令与事件之间的聚合对象。若无法确定，则保留一个空的黄色即时贴，待以后确定。</li>
<li>第四步：选择当前事件的后置事件。若后置事件仍然与用户有关，则重复第一步；若后置事件与外部系统有关，可以跳过该事件的建模，继续选择下一个后置事件。若事件与策略有关，在进一步细化策略对象之后，驱动出决策命令，重复第三步。</li>
</ul>
<p>以前面所示的信用卡开卡事件流为例，我们依次选择以下三个事件：</p>
<img src="/event-storming-with-domain-model/04.jpg" class="">

<p>首先是审批人参与的“开卡申请已审批”事件，执行第一步，由该事件可以反向驱动出决策命令“审批开卡申请”。第二步是根据决策命令推导出触发事件需要的读模型。审批开卡申请的前置信息是“申请”和“用户征信”，若缺乏这两个信息，审批人无法做出“审批开卡申请”的决策。第三步是确定决策命令与事件之间的聚合对象。显然，“开卡申请已审批”事件影响到的就是申请的状态，它就是我们要寻找的聚合对象：</p>
<img src="/event-storming-with-domain-model/05.png" class="">

<p>接着进入第四步，选择下一个后置事件“卡号已生成”。该事件与策略有关，细化策略为“卡号规则”。由事件驱动出决策命令为“生成卡号”，进入第三步，识别两者之间的聚合对象。卡号的生成影响了信用卡的属性，可以认为该事件影响状态的目标对象为“信用卡”：</p>
<img src="/event-storming-with-domain-model/06.png" class="">

<p>继续第四步，选择下一个后置事件“信用卡制作完毕”。由于该事件由外部系统发布，可以忽略该建模过程，仅仅标记外部系统即可：</p>
<img src="/event-storming-with-domain-model/07.png" class="">

<p>通过这个简单案例，可以清晰地看到我总结的领域分析建模过程具有一定的可操作性。事件风暴工作坊的参与人员可以按照建模步骤一步一步执行。执行每一步都需要团队与领域专家进一步讨论和确认，保证识别出来的模型对象遵循该领域的统一语言。在这个分析建模过程中，每个模型对象都有着建模的参考依据，包括模型对象的身份特征、彼此之间的关系、承担的职责，这就在一定程度上减轻了对建模人员经验的依赖。</p>
<p>事件风暴的两个层次恰好可以对应领域驱动设计的战略阶段与战术阶段。前者主要用于识别限界上下文，后者主要用于建立领域分析模型，这恰恰填补了Eric Evans《领域驱动设计》书中的关键空白。当然，Alberto Brandolini提出的事件风暴不仅于此，它还能用于企业的流程改进、业务创新和对新型服务的探索。这些实践与领域驱动设计没有直接关系，这里就不再叙述。若有兴趣了解事件风暴的更多内容，可以访问<a href="https://www.eventstorming.com/">事件风暴的官方网站</a>。</p>
<hr>
<p>我在知识星球「TOP DDD」开始了一个事件风暴工作坊，就是由我给出需求，要求星球的童鞋根据我的需求在线下完成一个人的事件风暴，然后提交各自分析获得的模型。我在线上对大家提交的模型进行点评，并给出修改意见。以下是这次活动的内容截图：</p>
<img src="/event-storming-with-domain-model/08.jpg" class="">
<img src="/event-storming-with-domain-model/09.jpg" class="">

<p>以下是知识星球的童鞋提交的部分作业：</p>
<img src="/event-storming-with-domain-model/10.png" class="">
<img src="/event-storming-with-domain-model/11.jpeg" class="">

<p>若有兴趣加入「TOP DDD」，与我一起探讨和学习DDD，请扫描下方图片二维码。期待你的加入！</p>
<img src="/event-storming-with-domain-model/icon.jpeg" class="">

]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
        <tag>Event Storming</tag>
      </tags>
  </entry>
  <entry>
    <title>何时定义领域服务</title>
    <url>/example-of-define-domain-service/</url>
    <content><![CDATA[<p>若遵循基于面向对象设计范式的领域驱动设计，并用以应对纷繁复杂的业务逻辑，则强调领域模型的充血设计模型已成为社区不争事实。我将Eric提及的战术设计要素如Entity、Value Object、Domain Service、Aggregate、Repository与Factory视为<strong>设计模型</strong>。这其中，只有Entity、Value Object和Domain Service才能表达领域逻辑。</p>
<span id="more"></span>

<p>为避免贫血模型，在封装领域逻辑时，考虑设计要素的顺序为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Value Object -&gt; Entity -&gt; Domain Service</span><br></pre></td></tr></table></figure>

<p>切记，我们必须将Domain Service作为承担业务逻辑的最后的救命稻草。之所以把Domain Service放在最后，是因为我太清楚领域服务的强大“魔力”了。开发人员总会有一种惰性，很多时候不愿意仔细思考所谓“职责（封装领域逻辑的行为）”的正确履行者，而领域服务恰恰是最便捷的选择。</p>
<p>就我个人的理解，<strong>只有满足如下三个特征的领域行为才应该放到领域服务中</strong>：</p>
<ul>
<li>领域行为需要多个领域实体参与协作</li>
<li>领域行为与状态无关</li>
<li>领域行为需要与外部资源（尤其是DB）协作</li>
</ul>
<p>假设某系统的合同管理功能允许客户输入自编码，该自编码需要遵循一定的编码格式。在创建新合同时，客户输入自编码，系统需要检测该自编码是否在已有合同中已经存在。针对该需求，可以提炼出两个领域行为：</p>
<ul>
<li>验证输入的自编码是否符合业务规则</li>
<li>检查自编码是否重复</li>
</ul>
<p>在寻找职责的履行者时，我们应首先遵循“<strong>信息专家模式</strong>”，即“拥有信息的对象就是操作该信息的专家”，因此可以提出一个问题：领域行为要操作的数据由谁拥有？针对第一个领域行为，就是要确认谁拥有自编码格式的验证规则？有两个候选：</p>
<ul>
<li>拥有自编码信息的“合同(Contract)”对象</li>
<li>体现自编码知识概念自身的“自编码（CustomizedNumber）”对象</li>
</ul>
<p>我倾向于定义CustomizedNumber值对象，将该检测规则封装其内，并在构造函数中对其进行验证。在领域驱动设计中，值对象往往用于封装这些基础概念。由于自定义的类型可以封装领域行为，就可以有效地实现职责的“分治”，实现对象的协作。</p>
<p>若要检查自编码是否重复，则需要从数据库中查找，这就需要通过Repository与DB协作。基于前面总结的三个特征，则该职责应该分配给一个领域服务，例如DuplicatedNumberChecker。</p>
<p>从职责分配的角度看，实体Contract又或者值对象CustomizedNumber才应该是承担该职责的合理选择。为何我却定义了这么一条例外原则呢？究其原因，就是在领域驱动设计中，我们应尽量保证实体与值对象的纯粹性，尤其不应该依赖于Repository（资源库）。继续深挖根本原因，是因为<strong>实体与值对象的生命周期是由Repository管理的</strong>。倘若被管理的实体对象还依赖了Repository，就要求该实体对应的Repository在管理实体对象的生命周期的同时，还需要管理它与Repository的依赖，这并不合理。值对象在一个聚合（Aggregate)边界之内，道理相同。</p>
<p>举例来说，假设Contract是聚合根，如果将检查重复编码的职责分配给该实体对象（或值对象CustomizedNumber），内部就需要依赖ContractRepository。然而，Contract的获取也是通过Repository得到，在基础设施层对ContractRepository的实现时，其实<strong>并不知道该如何管理二者之间的依赖</strong>。如果Contract实体还要依赖其他Repository，就更不可能了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContractRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">ContractRepository</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contract <span class="title">contractById</span><span class="params">(Identity contractId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里并不知道Contract对象需要注入ContractRepository对象自身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若真要解决此依赖管理问题，较简单的做法是为Contract提供一个<code>setContractRepository()</code>的依赖注入方法。不过，当Contract是通过Repository来获得时，如Spring、Guice之类的DI框架都无法注入这一依赖，因而需要显式调用，这就会引入对Repository具体实现的耦合。这样的耦合放在领域层，会导致本来单纯的领域层内核依赖了外部资源。倘若将这种具体耦合往外推，例如推到应用层，又会加重调用者的负担。</p>
<p>领域服务则不存在此问题，因为它的生命周期不是由Repository管理。如下的领域服务定义是合情合理的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuplicatedNumberChecker</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="meta">@Repository</span></span><br><span class="line">    <span class="keyword">private</span> ContractRepository repository;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDuplicate</span><span class="params">(CustomizedNumber number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> repository.existsNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在分配领域逻辑时，领域服务是最轻易也是最便宜的首选。这会导致领域服务的泛滥，长此以往，对领域层的开发又会走向“贫血模型”的老路。所谓“服务”本身就是一个抽象概念。越抽象就越显得包容并蓄。例如定义一个OrderService，那么所有和订单有关的逻辑都可以往这个服务里面塞，而诸如Order之类的实体对象终归有不少限制，分配职责时需得思虑再三。因此，倘若在设计与开发时对职责的分配不加约束，所谓的“职责分治”就不过是一句空话罢了。</p>
<p>归根结底，主流的领域驱动设计在战术层面考察的其实是面向对象的设计能力。我认为，所谓面向对象设计，核心就是<strong>角色</strong>、<strong>职责</strong>与<strong>协作</strong>。在分配职责时，应考虑将<strong>数据与行为封装在一起</strong>，这是面向对象设计的首要原则。</p>
<p>为了避免程序员把领域服务当做一个“筐”，什么逻辑都往里面装，除了需要提高团队成员面向对象的设计能力，并加强代码评审之外，还有一个方法，就是对领域服务加以约束。</p>
<p>没有任何语言可以在DDD设计要素上施加约束。Mat Wall与Nik Silver在对Guardian.co.uk网站推行DDD时的实践值得我们借鉴。他们在文章《<a href="http://www.infoq.com/cn/articles/ddd-evolving-architecture">演进架构中的领域驱动设计</a>》中建议：</p>
<blockquote>
<p>为了对付这一行为，我们对应用中的所有服务进行了代码评审，并进行重构，将逻辑移到适当的领域对象中。我们还制定了一个新的规则：任何服务对象在其名称中必须包含一个动词。这一简单的规则阻止了开发人员去创建类似于ArticleService的类。取而代之，我们创建 ArticlePublishingService和ArticleDeletionService这样的类。推动这一简单的命名规范的确帮助我们将领域逻辑移到了正确的地方，但我们仍要求对服务进行定期的代码评审，以确保我们在正轨上，以及对领域的建模接近于实际的业务观点。</p>
</blockquote>
<p>其实，这一别具一格的约束形式其实与服务的本质是一脉相承的，即服务应代表无状态的领域行为，甚至可以说领域服务是领域层面用例的体现。</p>
<p>这一实践可能会导致更多细粒度的领域服务产生，但更有可能的结果是，当我们在创建一个新的领域服务时，可能会考虑暂时停下来，想一想，要分配给这个新服务的领域逻辑是否有更好的去处呢？即使因为该逻辑可能牵涉到多个领域实体，又或者需要与Repository协作而不得不放入到领域服务中，似乎也可以考虑将领域逻辑中与实体（或值对象）数据强相关的内容”摘“出来，分配到合适的地方，保证职责分配的合理均衡。<strong>和谐的协作机制</strong>是好的面向对象设计。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink分布式程序的异常处理</title>
    <url>/exception-handling-in-flink/</url>
    <content><![CDATA[<img src="/exception-handling-in-flink/cover.jpg" class="">



<p>在我们的数据平台产品中，为了简化开发，对Flink做了一层封装，定义了<code>Job</code>和<code>Flow</code>的抽象。一个Job其实就是Flink的一个作业，每个Job可以定义多个Flow，一个Flow可以理解为是Flink的一个<code>DataStream</code>，利用Job传递的<code>StreamExecutionEnvironment</code>可以在Flow中添加包括<code>Source</code>与<code>Sink</code>的多个算子。</p>
<p>Job与Flow之间的关系可以利用自定义的<code>@JobFlow</code>注解进行配置，如此就可以在执行抽象的<code>AbstractJob</code>的<code>run()</code>方法时，利用反射获得该Job下的所有Flow，遍历执行每个Flow的<code>run()</code>方法。在Flow的<code>run()</code>方法中，才会真正根据<code>StreamExecutionEnvironment</code>执行多个算子。</p>
<p>Flink为了保证计算的稳定性，提供了不同的重启策略。例如，当我们将重启策略设置为失败率（failure-rate）时，如果执行的任务出错次数达到了失败率配置的要求，Flink的Worker节点的TaskManager就会重启。如果超过重启次数，Task Manager就会停止运行。</p>
<span id="more"></span>



<p>失败的原因可能有很多，例如资源不足、网络通信出现故障等Flink集群环境导致的故障，但是也可能是我们编写的作业在处理流式数据时，因为处理数据不当抛出了业务异常，使得Flink将其视为一次失败。</p>
<p>为了减少因为业务原因抛出异常导致Task Manager的不必要重启，需要规定我们编写的Flink程序的异常处理机制。由于封装了Flink的Job，从一开始，我就考虑一劳永逸地解决业务异常的问题，即在<code>AbstractJob</code>的<code>run()</code>方法中，捕获我们自定义的业务异常，在日志记录了错误信息后，把该异常“吃”掉，避免异常的抛出导致执行失败，造成TaskManager的重启，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFlow</span> <span class="keyword">implements</span> <span class="title">Flow</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runBare();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DomainException ex) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">runBare</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>哪知道这一处理机制压根儿就无法捕获业务异常！</strong>为什么呢？这就要从Flink的分布式机制说起了。</p>
<p>在Flink集群上执行任务，需要Client将作业提交给Flink集群的Master节点。Master的Dispatcher接收到Job并启动JobManager，通过解析Job的逻辑视图，了解Job对资源的要求，然后向ResourceManager（Standalone模式，如果是YARN，则由YARN管理和调度资源）申请本次Job需要的资源。JobManager将Job的逻辑视图转换为物理视图，并<strong>将计算任务分发部署到Flink集群的TaskManager上</strong>。整个执行过程如下图所示：</p>
<img src="/exception-handling-in-flink/flink-execution.png" class="">



<p>我们封装的一个Flow，在物理视图中，其实就是一个作业，即前面所说的计算任务。一个作业可以包含多个算子。如果相邻算子之间不存在数据Shuffle、并行度相同，则会合并为算子链（Operator Chain）。每个算子或算子链组成一个JobVertex，在执行时作为一个任务（Task）。根据并行度的设置，每个任务包含并行度数目的子任务（SubTask），这些子任务就是作业调度的最小逻辑单元，对应于进程资源中的一个线程，在Flink中，就是一个Slot（如果不考虑Slot共享的话）。</p>
<p>假定Flink环境的并行度设置为1，作业的前面两个算子满足合并算子链的要求，且并行度设置为2；之后，通过<code>keyBy()</code>之类的算子完成了数据的Shuffle，然后再合并到同一个Sink中。那么它们的关系如下图所示：</p>
<img src="/exception-handling-in-flink/flink-job.png" class="">



<p>显然，Flink集群在执行作业时，会对作业进行划分，并将划分后的各个子任务分发到TaskManager中的每个Slot。一个TaskManager就是一个JVM，Slot则是进程中的一个线程。</p>
<p>答案不言而喻。<code>AbstractFlow</code>之所以无法捕获到各个算子执行任务时抛出的业务异常，是因为它们根本就没有执行在一个JVM上，也没有运行在同一个线程中。这正是分布式开发与本地开发的本质区别。如果不了解Flink的执行原理，可能就会困惑Java的异常处理机制为何不生效。在进行分布式开发时，如果还是照搬本地开发的经验，可能真的会撞得头碰血流才会看清真相。因此，正确的做法是在每个算子的实现中捕获各自的异常，也就是要保证每个算子自身都是健壮的，如此才能保证作业尽可能健壮。</p>
<p>当然，分布式开发与本地开发的本质区别不只限于此，例如分布式开发跨进程调用对序列化的要求，对数据一致性的不同要求，对异步通信机制以及阻塞调用的认识，都可能给程序员带来不同的体验。归根结底，了解分布式开发或分布式系统的底层原理，可以让我们尽早看到真相，避免调到坑里而不自知。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Flink</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title>使用事件风暴探索业务全景</title>
    <url>/explore-big-picture-by-event-storming/</url>
    <content><![CDATA[<img src="/explore-big-picture-by-event-storming/06.jpg" class="">

<p>事件风暴是一种高度强调交流与协作的可视化工作坊，是大白纸与各色即时贴的重度使用者。面对着糊满整面墙的大白纸，工作坊的参与人员通过充分地交流与沟通，然后用马克笔在各色即时贴上写下各个领域模型概念，贴在墙上呈现生动的模型。由于这些模型都是可视化的，就可以给团队直观印象。大家站在墙面前，观察这些模型，及时开展讨论。若发现有误，就可以通过移动即时贴来调整与更新，也可以随时贴上新的即时贴完善建模结果。</p>
<p>Alberto Brandolini设计的事件风暴通常分为两个层次。如果在工作坊过程中将主要的精力用于寻找业务流程中产生的领域事件，则这个过程可以认为是宏观级别的事件风暴，其目的是<strong>探索业务全景（Big Picture Exploration）</strong>。在识别出全景事件流之后，就可以标记时间轴的关键时间点作为划分领域边界和限界上下文边界的依据；同时也可以基于事件表达的业务概念对领域进行划分，最终确定候选的子领域和限界上下文。另一个层次则属于设计级别（Design-level）的领域分析建模方法，通过探索业务全景获得的事件流，<strong>围绕着事件获得领域分析模型</strong>。这些领域分析建模要素除了领域事件之外，还包括决策命令、读模型和聚合。事件风暴的领域分析建模方法通常会以业务全景探索的结果作为领域分析建模的基础。</p>
<span id="more"></span>

<h4 id="探索业务全景"><a href="#探索业务全景" class="headerlink" title="探索业务全景"></a>探索业务全景</h4><p>在探索业务全景的过程中，为了使每个人保持专注，一开始要排除其余领域概念的干扰，一心寻找沿着时间轴发展的事件。事件是事件风暴的主要驱动力，寻找出来的事件则是领域分析模型的骨架。事件风暴使用<strong>橙色即时贴</strong>来代表一个<strong>事件（Event）</strong>。</p>
<p>事件风暴工作坊要求沿着时间轴对事件进行识别。通常的做法是由领域专家贴上第一张他/她最为关心的事件，然后由大家分头围绕该事件写出在它之前和之后发生的事件，并按照时间顺序由左向右排列。以信用卡申请开卡的业务为例，领域专家认为“开卡申请已审批”是我们关注的核心事件，于是就可以在整面墙的中间贴上橙色即时贴，上面写上“开卡申请已审批”事件：</p>
<img src="/explore-big-picture-by-event-storming/01.png" class="">

<p>在确定这个核心事件之后，我们就要以此为中心，向前推导它的起因，向后推导它的结果，根据这种因果关系层层推进，逐渐形成一条或多条沿着时间轴且彼此之间存在因果关系的事件流：</p>
<img src="/explore-big-picture-by-event-storming/02.png" class="">

<p>在识别事件的过程中，工作坊的参与人员应尽可能<strong>站在管理和运营的角度去思考领域事件</strong>。这里所谓的“因果关系”，也可以理解为产生事件的前置条件是什么，由此推导出前置事件；事件导致的后置条件是什么，由此推导出后置事件。</p>
<p>从“开卡申请已审批”事件往前推导，它的前置条件是什么呢？显然，只有在信用卡申请人提交了开卡申请之后才可能审批申请，由此得到前置事件“开卡申请已提交”。以此类推，“开卡申请已提交”的前置条件又是什么呢？申请人在提交申请信息之前，需要通过征信系统对填写的内容做征信预检，于是可推导出前置事件“征信预检已完成”：</p>
<img src="/explore-big-picture-by-event-storming/03.png" class="">

<p>从“开卡申请已审批”事件往后推导，它的后置条件是什么呢？如果开卡申请通过了，一方面保证申请人收到审批结果通知，另一方面则开始制卡，首先就需要保证信用卡号已经生成，由此得到两个并行的后置事件“卡号已生成”和“审批结果已通知”。接着，在“卡号已生成”事件之后，就是等待制作信用卡的结果，由此获得后置事件“信用卡制作完毕”：</p>
<img src="/explore-big-picture-by-event-storming/04.png" class="">

<p><strong>事件风暴是一种探索性的建模活动</strong>。在探索事件的过程中，我们不要急于去识别其他的领域对象，基于事件结果，也不要急于去寻找导致事件发生的起因。尤其是在探索业务全景期间，更要如此。毕竟人的注意力是有限的。从一开始，就应该让工作坊的参与人员集中精力专注于事件。倘若存在疑问，又或者需要提醒业务人员或技术人员特别注意，可以用<strong>粉红色即时贴</strong>来表达该警告信息，Alberto Brandolini将其称之为“热点Hot Spot”。例如针对“开卡申请已审批”事件，需要考虑审批未通过的异常情况；“卡号已生成”事件需要考虑不同类型的信用卡需遵循不同的卡号生成规则；“审批结果已通知”事件可以标记系统支持的通知方式：</p>
<img src="/explore-big-picture-by-event-storming/05.png" class="">

<p>如前所述，触发事件的起因包括三种可能。在事件风暴业务全景探索过程中，可以在获得全景事件流之后，判断各个事件的起因，并分别用不同颜色的即时贴进行标记：</p>
<ul>
<li>由用户活动触发：标记参与事件的用户角色，用<strong>黄色小即时贴</strong>绘制火柴棍人表示</li>
<li>当条件满足时：标记引起事件的策略，用<strong>紫色即时贴</strong>表示</li>
<li>外部系统：标记引起事件的外部系统，用<strong>浅粉色即时贴</strong>表示</li>
</ul>
<p>前面获得的事件流可以表示为：</p>
<img src="/explore-big-picture-by-event-storming/07.png" class="">

<p>不要小看对这些事件起因的标记。在完成全景事件流之后，对事件的起因进行再一次梳理有助于团队就识别的事件达成一致，检查事件是否存在疏漏、谬误之处。作为事件起因的用户、外部系统与策略还为后面的领域分析建模奠定基础。其中，识别出的外部系统也有助于未来的架构设计，帮助我们绘制《<a href="https://gitbook.cn/gitchat/columns?tag=DDD">领域驱动战略设计实践</a>》课程中讲到的C4模型中的系统上下文（System Context）图。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Architecture</tag>
        <tag>Event Storming</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark Streaming中foreachRDD的陷阱</title>
    <url>/foreachrdd-of-spark-streaming/</url>
    <content><![CDATA[<p>我们的项目需要从Kafka消费消息，在对消息进行处理后，再写入到ActiveMQ，以作为外部系统的数据源。基于这样的逻辑，我们就需要通过Spark Streaming读取Kafka的消息，获得的结果其实是一个RDD。DStream提供了<code>foreachRDD(func)</code>方法，通过该方法可以遍历RDD的每条记录，然后再通过ActiveMQ的Producer将处理后的消息发送到ActiveMQ。</p>
<span id="more"></span>

<p>要将消息发送到ActiveMQ，就需要建立与消息队列的连接。在传统编程实现中，最直观的做法一定是将获取连接的代码放在<code>foreachRDD(func)</code>方法之外，如此可以避免不必要的资源消耗与时间消耗。例如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">dstream.foreachRDD &#123; rdd =&gt;</span><br><span class="line">  <span class="keyword">val</span> producer = createProducer()</span><br><span class="line">  rdd.foreach &#123; message =&gt;</span><br><span class="line">    producer.send(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createProducer</span></span>(): <span class="type">MessageProducer</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> conn = createActiveMQConnection()</span><br><span class="line">  <span class="keyword">val</span> session = sessionFrom(conn)</span><br><span class="line">  producerFrom(session)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这一做法在Spark Streaming中却行不通。原因在于：**<code>foreachRDD(func)</code>方法中的func是在调用Spark流式计算程序的Driver进程中执行的，而遍历得到的RDD中的操作却是在worker中执行**：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">dstream.foreachRDD &#123; rdd =&gt;</span><br><span class="line">  <span class="keyword">val</span> producer = createProducer()  <span class="comment">//在driver进程执行</span></span><br><span class="line">  rdd.foreach &#123; message =&gt;</span><br><span class="line">    producer.send(message)  <span class="comment">//在worker进程执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就需要将获得的对象（例子中包括了Connection、Session和Producer）进行序列化，使其能够从driver发送到worker。然而，连接等于资源相关的对象往往无法支持序列化，也无法在worker正确的初始化。</p>
<p>为了避免这种情况，一种做法是将前面的<code>createProducer()</code>方法搬到内部的<code>rdd.foreach(fn)</code>中来。可是，创建一个connection对象往往既费时间又费资源，针对每个RDD不停地创建连接，然后又关闭连接，会影响到整个系统的吞吐量和性能。</p>
<p>解决方案是使用<code>foreachPartition(func)</code>方法，通过它创建一个单独的connection对象，然后在RDD分区里使用这个连接对象将所有数据发送出去：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">dstream.foreachRDD &#123; rdd =&gt;</span><br><span class="line">  rdd.foreachPartition &#123; partitionOfRecords =&gt;</span><br><span class="line">    sendToActiveMQ &#123; producer =&gt;</span><br><span class="line">      partitionOfRecords.foreach(record =&gt; producer.send(record))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendToActiveMQ</span></span>(send: <span class="type">MessageProducer</span> =&gt; <span class="type">Unit</span>):<span class="type">Unit</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> conn = createActiveMQConnection()</span><br><span class="line">  <span class="keyword">val</span> session = sessionFrom(conn)</span><br><span class="line">  <span class="keyword">val</span> producer = producerFrom(session)</span><br><span class="line">  send(producer)</span><br><span class="line">  conn.close()</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>为了避免过多的创建和释放connection对象，还有一个更好的方案是使用连接池。由于我在前面的代码已经将连接创建与关闭提取出专门的方法，因此只需要修改前面的<code>sendToActiveMQ()</code>即可：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendToActiveMQ</span></span>(send: <span class="type">MessageProducer</span> =&gt; <span class="type">Unit</span>):<span class="type">Unit</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> conn = <span class="type">ActiveMQConnectionPool</span>.getConnection()</span><br><span class="line">  <span class="keyword">val</span> session = sessionFrom(conn)</span><br><span class="line">  <span class="keyword">val</span> producer = producerFrom(session)</span><br><span class="line">  send(producer)</span><br><span class="line">  <span class="type">ActiveMQConnectionPool</span>.returnConnnection(conn)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Spark这种Driver与Worker互相协作的分布式架构，与单节点的编程模型存在细微差异。开发时，稍不注意就可能出现问题。当然，面对这些问题，最根本的还是要从Spark的设计本质来理解，问题也就迎刃而解了。</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Streaming</tag>
        <tag>Big Data</tag>
        <tag>Spark</tag>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala实现DSL的框架案例</title>
    <url>/framework-example-of-scala-dsl/</url>
    <content><![CDATA[<p>在skinny.validator框架中，提供如下的一种DSL调用方式来验证Map的值：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validationRules</span> </span>= <span class="type">Validator</span>(</span><br><span class="line">  param(<span class="string">&quot;name&quot;</span> -&gt; name) is notEmpty,</span><br><span class="line">  param(<span class="string">&quot;dataSourceId&quot;</span> -&gt; dataSourceId) is checkAll(intValue, intMinValue(<span class="number">0</span>)),</span><br><span class="line">  param(<span class="string">&quot;sql&quot;</span> -&gt; sql) is notEmpty,</span><br><span class="line">  param(<span class="string">&quot;fields&quot;</span> -&gt; fields) is checkAll(notNull, notEmpty)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><code>param()</code>方法返回的类型为<code>ParamDefinition</code>。<code>is</code>之类的方法看起来应该是<code>ParamDefinition</code>的DSL方法。不过在实现中，却提供了一个私有类来定义这些DSL方法，然后再定义一个隐式转换将私有类转换为<code>ParamDefinition</code>：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Param definition which has #is and #are DSL methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param paramDef param definition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>[validator] <span class="class"><span class="keyword">class</span> <span class="title">ParamDefinitionWithIsDSL</span>(<span class="params">paramDef: <span class="type">ParamDefinition</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is</span></span>(validations: <span class="type">ValidationRule</span>): <span class="type">NewValidation</span> = <span class="type">NewValidation</span>(paramDef, validations)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">are</span></span>(validations: <span class="type">ValidationRule</span>): <span class="type">NewValidation</span> = <span class="type">NewValidation</span>(paramDef, validations)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Converts ParamDefinition to ParamDefinitionWithIsDSL implicitly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param paramDef param definition</span></span><br><span class="line"><span class="comment"> * @return with dsl</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convertParamDefinitionToParamDefinitionWithIs</span></span>(paramDef: <span class="type">ParamDefinition</span>): <span class="type">ParamDefinitionWithIsDSL</span>  = &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="type">ParamDefinitionWithIsDSL</span>(paramDef)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式既可以将对应的DSL方法进行归类，又可以很好地支持DSL的编码形式，算是DSL的一种最佳实践。</p>
<p><code>is</code>或<code>are</code>等DSL方法接收的参数类型为<code>ValidationRule</code>（因为Scala允许以空格而非括号形式去调用，从而能够以自然语言的方式来表达）。<code>ValidationRule</code>的定义比较特殊，它本身是一个trait，但却继承自一个函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ValidationRule</span> <span class="keyword">extends</span> (<span class="params">(<span class="type">KeyValueParamDefinition</span></span>) <span class="title">=&gt;</span> <span class="title">ValidationState</span>) <span class="keyword">with</span> <span class="title">ErrorLike</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>看起来比较奇怪，其实不过是一种语法糖，因为在Scala中，函数就是一个定义了<code>apply()</code>方法的接口。这里之所以直接继承一个函数，倒也不是卖弄语法，而是因为作者压根就不想为这个函数定义一个类型。这也是FP的好处，因为函数自身就已经表达了一种最高层抽象，为什么还要多此一举去定义一个类型呢？对于一些不支持函数为一等公民的语言，才会这样行无奈之举。例如我需要抽象这么一个函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">() =&gt; <span class="type">Unit</span></span><br></pre></td></tr></table></figure>

<p>在Java语言中，由于不支持函数作为参数或返回值，那就只有无奈地寻找到一个所谓Action的概念，定义接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ValidationRule</code>的定义实则是一个模板方法模式，该类的<code>apply()</code>方法就是模板方法（template method），而<code>isValid()</code>方法就是基本方法（primitive method），交给实现<code>ValidationRule</code>的类去具体实现：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ValidationRule</span> <span class="keyword">extends</span> (<span class="params">(<span class="type">KeyValueParamDefinition</span></span>) <span class="title">=&gt;</span> <span class="title">ValidationState</span>) <span class="keyword">with</span> <span class="title">ErrorLike</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Validation itself.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param value any value</span></span><br><span class="line"><span class="comment">   * @return valid if true</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isValid</span></span>(value: <span class="type">Any</span>): <span class="type">Boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Applies this validation rule to parameter.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param paramDef param definition</span></span><br><span class="line"><span class="comment">   * @return validation</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(paramDef: <span class="type">KeyValueParamDefinition</span>): <span class="type">ValidationState</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (isValid(paramDef.value)) <span class="type">ValidationSuccess</span>(paramDef)</span><br><span class="line">    <span class="keyword">else</span> <span class="type">ValidationFailure</span>(paramDef, <span class="type">Seq</span>(<span class="type">Error</span>(<span class="keyword">this</span>.name, <span class="keyword">this</span>.messageParams)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>skinny.validator框架提供了诸多内建的验证规则，并以case class或object（如果为单例）形式定义：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">notNull</span> <span class="keyword">extends</span> <span class="title">ValidationRule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= <span class="string">&quot;notNull&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isValid</span></span>(v: <span class="type">Any</span>) = v != <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// param(&quot;x&quot; -&gt; &quot;y&quot;) is required</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">required</span> <span class="keyword">extends</span> <span class="title">required</span>(<span class="params">true</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">required</span>(<span class="params">trim: <span class="type">Boolean</span> = true</span>) <span class="keyword">extends</span> <span class="title">ValidationRule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= <span class="string">&quot;required&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isValid</span></span>(v: <span class="type">Any</span>) = !isEmpty(v) &amp;&amp; &#123;</span><br><span class="line">    <span class="keyword">if</span> (trim) v.toString.trim.length &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> v.toString.length &gt; <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// param(&quot;x&quot; -&gt; &quot;y&quot;) is notEmpty</span></span><br><span class="line"><span class="comment">// param(&quot;list&quot; -&gt; Seq(1,2,3)) is notEmpty</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">notEmpty</span> <span class="keyword">extends</span> <span class="title">notEmpty</span>(<span class="params">true</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">notEmpty</span>(<span class="params">trim: <span class="type">Boolean</span> = true</span>) <span class="keyword">extends</span> <span class="title">ValidationRule</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= <span class="string">&quot;notEmpty&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isValid</span></span>(v: <span class="type">Any</span>) = !isEmpty(v) &amp;&amp; &#123;</span><br><span class="line">    toHasSize(v).map(x =&gt; x.size &gt; <span class="number">0</span>).getOrElse &#123;</span><br><span class="line">      <span class="keyword">if</span> (trim) v.toString.trim.length &gt; <span class="number">0</span></span><br><span class="line">      <span class="keyword">else</span> v.toString.length &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>(v: <span class="type">Any</span>): <span class="type">Boolean</span> = v == <span class="literal">null</span> || v == <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>诸如<code>notNull</code>、<code>required</code>与<code>notEmpty</code>之类的object或case class都继承自<code>ValidationRule</code>，但它们本质上都是函数，接受的参数为<code>KeyValueParamDefinition</code>类型，返回<code>ValidationState</code>。在这些方法调用的背后，隐含地使用到了Scala的特殊语法：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">param(<span class="string">&quot;x&quot;</span> -&gt; <span class="string">&quot;y&quot;</span>) is notEmpty</span><br></pre></td></tr></table></figure>

<p><code>param(&quot;x&quot; -&gt; &quot;y&quot;)</code>是<code>ParamDefinition</code>类型，然后利用隐式转换的方式，使其拥有了<code>is</code>方法。因此前面的调用相当于：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">param(<span class="string">&quot;x&quot;</span> -&gt; <span class="string">&quot;y&quot;</span>).is(notEmpty)</span><br></pre></td></tr></table></figure>

<p>该方法接收的参数表面上是<code>ValidationRule</code>类型，实则是一个函数，函数参数类型为<code>KeyValueParamDefinition</code>，它是<code>ParamDefinition</code>的实现类。<code>param</code>方法在返回<code>KeyValueParamDefinition</code>时，对应的实现是将传入的key/value键值对传递给了<code>KeyValueParamDefinition</code>：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param</span></span>(kv: (<span class="type">String</span>, <span class="type">Any</span>)): <span class="type">KeyValueParamDefinition</span> = <span class="type">KeyValueParamDefinition</span>(kv._1, kv._2)</span><br></pre></td></tr></table></figure>

<p>因此，就相当于把<code>(x, y)</code>这个键值对传递给了<code>notEmpty()</code>方法。由于scala的方法默认是strict方法，所以在将<code>notEmpty</code>函数传递给<code>is</code>方法时，就会去执行<code>notEmpty</code>的<code>apply()</code>方法，内部就是调用它的<code>isValid()</code>方法，进而调用<code>isEmpty(v: Any)</code>方法，并将传递进来key/value键值对的value（即这里的y值）进行非空判断。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Scala</tag>
        <tag>FP</tag>
        <tag>Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>从单体架构到微服务架构</title>
    <url>/how-to-break-monolith-into-microservices/</url>
    <content><![CDATA[<img src="/how-to-break-monolith-into-microservices/cover.jpg" class="">
<p>我在Martin Fowler网站上读到一篇名为<a href="https://martinfowler.com/articles/break-monolith-into-microservices.html">How to break a Monolith into Microservices</a>的微服务文章，作者为ThoughtWorks的咨询师Zhamak Dehghani，介绍了如何从单体架构演进到微服务架构。</p>
<span id="more"></span>

<h3 id="微服务生态系统"><a href="#微服务生态系统" class="headerlink" title="微服务生态系统"></a>微服务生态系统</h3><p>在讲解如何拆分之前，Dehghani首先介绍了微服务生态系统（microservices ecosystem），她认为微服务生态系统是“封装了<strong>业务能力</strong>的服务平台”。Martin Fowler与James Lewis总结的微服务特征中，也提及“通过业务能力组织服务”。认识到这一点，对于微服务拆分而言非常重要。<strong>微服务首先是业务手段，然后才是技术手段。</strong>Dehghani定义了“业务能力”：</p>
<blockquote>
<p>A business capability represents what a business does in a particular domain to fulfill its objectives and responsibilities. 业务能力体现为在特定领域为达成其目标与职责的相关业务。</p>
</blockquote>
<p>微服务生态系统如下图所示：</p>
<img src="/how-to-break-monolith-into-microservices/01.png" class="">

<p>该生态系统牵涉到微服务的特征，团队的职责和组织结构，开发实践等，这些因素横跨业务、组织与技术诸方面，说明系统的微服务架构迁移不仅仅需要在技术层面做好准备，还需要在整个企业或团队层面做好充分准备，否则就可能“出师未捷身先死”！</p>
<h3 id="旅程的开始"><a href="#旅程的开始" class="headerlink" title="旅程的开始"></a>旅程的开始</h3><p>从单体架构到微服务架构是一个漫长的旅程。在开始演进之前，Dehghani建议最好结合Martin Fowler给出的<a href="https://martinfowler.com/bliki/MicroservicePrerequisites.html">微服务前提条件</a>对系统和团队进行评估。在开始拆分第一个服务之前，开发与运维团队应该事先准备好系统的基础设施、持续交付管道以及API的管理系统。这样可以尽可能地保证单体系统的客户端不会受到服务拆分的影响。</p>
<p>在开始拆分单体架构的服务时，需得小心行事。如果从一开始就选择拆分核心领域的微服务，风险就太大了。Dehghani建议从一些边界服务（edge services）开始着手，例如认证服务。拆分这样的服务难度低，对整个系统的影响也较小，方便团队快速上手，算是拆分服务的一次“热身”。一旦拆分出一个微服务，就开始了架构风格的转换，与此同时，就可以测试微服务的整体架构是否正确。这就好像在单元测试中运行第一个测试一般，哪怕测试变红了，它也是有价值的，因为通过它的成功运行可以确认测试环境是正确的。这个演进过程如下图所示：</p>
<img src="/how-to-break-monolith-into-microservices/02.png" class="">

<h3 id="降低对单体系统的依赖"><a href="#降低对单体系统的依赖" class="headerlink" title="降低对单体系统的依赖"></a>降低对单体系统的依赖</h3><p>在拆分微服务时，处理依赖是至关重要的一点。我们必须确保一个微服务<strong>具有快速而独立的发布周期</strong>。由于单体架构与微服务架构粒度的不同，必然会导致二者在相当长的一段时间内存在依赖关系。要注意彼此之间的依赖方向！Dehghani认为应该<strong>减少微服务对单体系统的依赖</strong>。换言之，对付依赖的原则是：</p>
<ul>
<li>首先尽可能去掉二者之间不必要的依赖关系</li>
<li>如果需要依赖，应优先考虑单体系统依赖微服务，而不是微服务依赖单体系统</li>
</ul>
<p>例如针对一个零售在线系统，“购买”和“促销”都是系统的核心业务能力，在顾客付款的过程中，“购买”会调用“促销”以获得最佳的促销优惠。如果我们需要将这两个核心能力作为微服务从单体系统中拆分出来，那么拆分的顺序应该怎样？Dehghani认为应该先拆分“促销”，此时“购买”服务仍然在单体系统中，且依赖于新分离出来的“促销”服务。这样的拆分顺序可以减少对单体系统的依赖。</p>
<p>为何要遵循这样的原则？正如文中所说：“微服务需要具有快速而独立的发布周期”，如果让微服务依赖单体系统，就会让微服务变得很笨重。这就好似一只本该灵活飞翔的蝴蝶，正摇摇欲坠地拉着一头笨重的大象。</p>
<p>倘若无法避免新的微服务对单体系统的依赖呢？这就需要引入领域驱动设计介绍的防腐层（anti-corruption layer），即在单体系统中定义一个新的API，然后让新的微服务通过这个新API访问单体系统。新的API应遵循微服务API的设计原则，体现该服务的领域概念和结构。之所以引入防腐层，目标有二：</p>
<ul>
<li>避免单体系统的代码实现直接泄漏给微服务</li>
<li>便于在未来用新的微服务实现替换单体系统的实现</li>
</ul>
<p>这两种依赖方向如下图所示：</p>
<img src="/how-to-break-monolith-into-microservices/03.png" class="">

<h3 id="优先分离黏合逻辑"><a href="#优先分离黏合逻辑" class="headerlink" title="优先分离黏合逻辑"></a>优先分离黏合逻辑</h3><p>单体架构为人诟病的一点在于它太容易随着时间推移而变成一个高度耦合的“毛线球”。各个功能纠缠在一起，没有体现出清晰的领域逻辑，这会给微服务拆分带来很大的障碍。因此，Dehghani建议优先识别出单体系统中的这些黏合逻辑（Sticky Capabilities），分解它们，并定义出良好的领域概念，然后再将这些领域概念分解到各自独立的微服务中。</p>
<p>如何来理解“黏合逻辑（Sticky Capabilities）”？我个人认为文中提到的“黏合逻辑”，并非系统的核心业务能力，而是一种近乎于横切关注点的功能，又或者说是一个全局的数据结构（变量）。文中以session为例，单体系统中的客户属性、期望列表、支付偏好等信息都放在session之中。这时，我们就应该从具有session的这段黏合逻辑中识别领域逻辑，然后依次将这些领域逻辑分离出来形成独立的微服务：</p>
<img src="/how-to-break-monolith-into-microservices/04.png" class="">

<p>注意，这块黏合逻辑并不需要分解为专门的微服务，例如分解为会话服务。</p>
<p>我在为客户做的一次微服务迁移时，也遭遇了同等问题。在原有的单体架构中，定义了诸多全局变量，并被系统中的大多数业务功能使用。这些全局变量就像一个公共澡堂，谁都可以进来泡澡。微服务是独立而私有的，当然应该在自家宅里修建自己的浴室了。所以这一原则的确立，其实是从解耦的角度思考的。</p>
<p>解耦的一个前提是识别依赖，Dehghani推荐诸如<a href="http://structure101.com/">Structure101</a>这样的依赖分析工具来识别单体系统中耦合最为紧密的代码。</p>
<h3 id="纵向解耦并尽早发布数据"><a href="#纵向解耦并尽早发布数据" class="headerlink" title="纵向解耦并尽早发布数据"></a>纵向解耦并尽早发布数据</h3><p>这里所谓的“纵向（Vertically）”解耦，就是从客户端发起调用的服务API到数据库进行“一刀切”。这一原则颇让我出乎意料，因为我个人认为：数据库共享架构可以作为从单体架构到微服务架构的一个过渡；但是，Dehghani认为从微服务的“<a href="https://martinfowler.com/articles/microservices.html#DecentralizedDataManagement">去中心化数据管理（Decentralized Data Management）</a>”特征看，应尽早解耦数据库。</p>
<p>在解耦数据库时，若单体系统中的多个功能都需要访问一些共享数据，这部分功能就会制造障碍。在拆分之前，与这些功能相关的所有团队需要讨论确定数据迁移的策略，然后再对服务加数据进行拆分：</p>
<img src="/how-to-break-monolith-into-microservices/05.png" class="">

<p>注意，在拆分服务和数据时，需要确定数据访问的边界。一个原则是<strong>数据库中的数据只能被一个微服务调用</strong>，如果其他微服务也需要访问这些数据，则应该通过拥有这些数据的微服务进行访问。因此，我们需要在拆分时弄清楚数据的归属权。</p>
<h3 id="解耦核心领域和变化频繁的领域"><a href="#解耦核心领域和变化频繁的领域" class="headerlink" title="解耦核心领域和变化频繁的领域"></a>解耦核心领域和变化频繁的领域</h3><p>从单体系统演进到微服务时，需要叩问自身：为什么要演进到微服务？不能为了拆分而拆分，而应该在拆分微服务时，随时<strong>权衡拆分的成本与收益</strong>。这就充分地解答了本原则的缘由。为何要重点解耦核心领域以及变化频繁的领域？因为核心领域的价值要远超其他子领域，因为变化频繁的领域在单体架构中的维护成本太高。前者是因为拆分后的收益高，后者是因为不拆分带来的成本高。</p>
<p>要应用这一原则，可以引入领域驱动设计的战略设计，通过识别系统的核心领域与子领域，由此确定提取微服务的边界和目标。领域是否为核心领域，与痛点和价值有关，这需要结合客户的愿景、目标和经营模式等因素综合考量。例如在文中，Dehghani认为“客户个性化”是核心领域，因为它能够为客户提供更好的用户体验，有助于提高客户的黏度。</p>
<h3 id="依据能力而非代码去解耦"><a href="#依据能力而非代码去解耦" class="headerlink" title="依据能力而非代码去解耦"></a>依据能力而非代码去解耦</h3><p>当开发人员从已有系统中提取服务时，无非两种形式：提取代码或重写能力。多数情况下，技术人员往往采用提取方式来重用现有实现。这其实是一种感知偏见（cognitive bias），对于自己设计和编写的代码抱有偏执的热爱。这种感知偏见在心理学中被称之为“<a href="https://en.wikipedia.org/wiki/IKEA_effect">宜家效应</a>”。</p>
<p>我们应该抛开这种偏见，重新审视这二者带来的成本和价值。重写未必代价高昂，毕竟我们可以抛开过去的技术债务轻装前行，正所谓“无债一身轻”嘛。所以Dehghani给出了一个原则：<strong>重用和提取高价值低毒性的代码，重写和废弃低价值高毒性的代码。</strong>什么是代码毒性（code toxicity）？我想，应该就是Martin Fowler在《重构》一书中提及的代码坏味道。若需评估代码毒性的高低，可以使用CheckStyle等工具。</p>
<h3 id="先宏观再微观"><a href="#先宏观再微观" class="headerlink" title="先宏观再微观"></a>先宏观再微观</h3><p>识别微服务边界的常见方法是运用领域驱动设计的限界上下文（Bounded Context）。虽然名为微服务，但服务的粒度不能没有原则的追求“微小”。过于微小的服务既会带来服务的“大爆炸”，还会出现大量只有CRUD操作的贫血服务（<a href="https://www.martinfowler.com/bliki/AnemicDomainModel.html">anemic service</a>）。</p>
<p>微服务到底有多“微”，这是一个问题。衡量的指标包括团队的规模、重写一个服务花费的时间、服务封装了多少行为。但这些指标并无客观的量化值，同时，还得取决于这个系统自身的规模与业务复杂性。例如，我们自己开发一个学习型电商系统，它所拆分的微服务粒度与数量显然不能与天猫、京东这样的大型电商系统相提并论。在没有量化指标的指导下，若需要凭经验设计，就应该遵循Dehghani给出的建议：先从更大的服务开始，直到微服务的基础条件都满足了，再寻求对大的服务进行拆分。这些基本条件包括团队对业务的理解、对单体系统的理解、持续交付环境的准备等。</p>
<p>例如，在解耦零售系统时，团队最初提取的“购买”服务包含了购物车与结账功能。随着团队的微服务成熟度越来越高，也能够轻易地分解团队，形成小快灵的微服务团队，这时就可以考虑将购物车与结账功能分解出来，形成专门的微服务：</p>
<img src="/how-to-break-monolith-into-microservices/06.png" class="">

<h3 id="架构演化的原子步伐迁移"><a href="#架构演化的原子步伐迁移" class="headerlink" title="架构演化的原子步伐迁移"></a>架构演化的原子步伐迁移</h3><p>重构教导我们要“小步前行”，但真正的意图是要保持重构步伐的原子性（atomic），这样就能保证进可攻退可守的态势。单体架构向微服务架构的演进也需要遵循这一原则。若前进的步伐是正确的，且演进的内容是完整的，则意味着我们向着演进目标又靠近了一步；若前进的步伐出现了偏差，我们也能够轻易回滚。</p>
<p>Dehghani在文中给出了一个案例来阐释这一理念。假定微服务架构的目标是提高开发人员修改整个系统的速度，快速交付价值。团队决定将用户认证分解为一个服务，并基于OAuth 2.0协议来实现。该服务的目的是替换单体系统中的认证功能，那么演进的步骤就分为：</p>
<ul>
<li>构建一个Auth服务，采用OAuth 2.0来实现</li>
<li>在单体系统中添加一个新的认证路径，然后调用新实现的认证服务</li>
</ul>
<p>如果演进到这一步，团队的工作暂时停止，那么这个演进步伐就不是原子的，因为它使得系统处于一种不稳定的“中间状态”，单体系统的开发人员需要同时维护两条认证路径，增加了开发、测试和维护的成本。因此，我们不应该停下演进的步伐，而应继续前行：</p>
<ul>
<li>用新服务替换单体系统中旧有的基于用户名/密码的认证</li>
<li>从单体系统中去掉旧有的认证实现代码</li>
</ul>
<p>文中总结了单体系统分解的原子单元：</p>
<ul>
<li>解耦新服务</li>
<li>将所有消费者指向新服务</li>
<li>废弃单体系统中的旧代码</li>
</ul>
<p>2013年，我在Scrum Gathering大会上的演讲《引入敏捷实践完成技术栈迁移》讲述了类似步骤，遵循的原则其实就是“<a href="https://www.martinfowler.com/bliki/BranchByAbstraction.html">抽象分支（Branch of Abstraction）</a>”，在针对遗留系统进行解耦或旧代码替换时，往往会采用这种手法。故而步骤不是关键的，关键的是如何认识“原子性”。我认为，原子性就应该保证演进的功能是最小粒度的完整，且不允许新旧代码同时存在。</p>
<p><strong>说明：</strong>本文中的插图全部来自于Zhamak Dehghani的原文。</p>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Architecture</tag>
        <tag>Micro Service</tag>
      </tags>
  </entry>
  <entry>
    <title>如何分辨应用服务与领域服务</title>
    <url>/how-to-identify-application-service/</url>
    <content><![CDATA[<img src="/how-to-identify-application-service/logo.jpg" class="">
<p>判断什么时候应该定义领域服务，什么时候应该定义应用服务，一个根本的判断依据是看<strong>需要封装的职责是否与领域相关</strong>。</p>
<span id="more"></span>

<h3 id="横切关注点"><a href="#横切关注点" class="headerlink" title="横切关注点"></a>横切关注点</h3><p>在应用服务中，我们往往需要和如下逻辑进行协作：</p>
<ul>
<li>消息验证</li>
<li>错误处理</li>
<li>监控</li>
<li>事务</li>
<li>认证与授权</li>
</ul>
<p>在《领域驱动设计模式、原理与实践》一书中，将以上内容视为<strong>基础架构问题</strong>。这些关注点与具体的业务逻辑无关，且在整个系统中，可能会被诸多服务调用（以便于重用），因此可以认为这些关注点为<strong>横切关注点</strong>。</p>
<img src="/how-to-identify-application-service/ppp-of-ddd.jpg" class="">

<p>从AOP的角度看，所谓“横切关注点”就是那些在职责上是内聚的，但在使用上又会散布在所有对象层次中，且与所散布到的对象的核心功能毫无关系的关注点。与“横切关注点”对应的是“核心关注点”，就是与系统业务有关的领域逻辑。例如订单业务是核心关注点，插入订单时的事务管理则是横切关注点。</p>
<p>横切关注点与核心关注点是分离的，因此与具体的业务无关。于是，我们可以得到应用服务设计的第一条原则：<strong>与横切关注点协作的服务应被定义为应用服务</strong>。</p>
<h3 id="Clean-Architecture"><a href="#Clean-Architecture" class="headerlink" title="Clean Architecture"></a>Clean Architecture</h3><p>如果参考Robert Martin的Clean Architecture以及Cockburn的六边形架构，我们可以将分层架构的应用层对应到Clean Architecture内核中的Use Case层，如下图所示：</p>
<img src="/how-to-identify-application-service/clean-arch.jpg" class="">

<p>据上图，Robert Martin认为Use Case层封装了“Application Business Rules”。我们在分析建模时，一个Use Case往往代表一个完整的业务场景。</p>
<p>对外部的客户而言，DDD的应用层代表了与客户协作的应用服务，接口表达的其实是业务的含义。DDD分层架构的主要目的是要将业务复杂度与技术复杂度分离，应用层扮演的正是这样的一条分界线。从设计模式的角度讲，应用层的应用服务就是一个Facade：对外，它提供代表Use Case的整体应用；对内，它负责整合领域层的领域逻辑与其他基础架构层面的横切关注点。应用服务封装的业务含义，其实仅仅是一个转手的买卖，并不真正具有领域逻辑。因此可以得到应用服务设计的第二条准则：<strong>不包含领域逻辑的业务服务应被定义为应用服务</strong>。</p>
<h3 id="与领域的交互"><a href="#与领域的交互" class="headerlink" title="与领域的交互"></a>与领域的交互</h3><p>第二条设计准则容易造成困惑。虽然单个领域行为确定无误地属于领域逻辑，然而将多个领域行为组合起来的协调行为，算不算是领域逻辑呢？例如对于“下订单”用例而言，如果我们在各自的领域对象中定义了如下行为：</p>
<ul>
<li>验证订单是否有效</li>
<li>提交订单</li>
<li>移除购物车中已购商品</li>
<li>发送邮件通知买家</li>
</ul>
<p>这些行为的组合正好满足了“下订单”这个完整用例的需求，同时也为了保证客户调用的简便性，我们需要对这四个领域行为进行封装。由于这些行为可能牵涉到不同的领域对象，因此只能定义为服务。那么，这个服务应该是应用服务，还是领域服务？</p>
<p>《领域驱动设计模式、原理与实践》一书将这种封装认为是<strong>与领域的交互</strong>。该书作者给出了自己的一个判断标准：</p>
<blockquote>
<p>决定一系列交互是否属于领域的一种方式是提出“这种情况总是会出现吗？”或者“这些步骤无法分开吗？”的问题。如果答案是肯定的，那么这看起来就是一个领域策略，因为那些步骤总是必须一起发生。然而，如果那些步骤可以用若干方式重新组合，那么可能它就不是一个领域概念。</p>
</blockquote>
<p>但我认为这种判断标准并不准确，至少并非充分必要条件。也就是说，可以分开的领域行为组合在一起未必一定就是应用服务；反过来，一个应用服务封装的领域行为组合也未必一定具有高内聚性。</p>
<p>如果这个判断标准不成立，在牵涉到领域逻辑的协调与交互时，领域逻辑与应用服务的边界就变得非常模糊了。一种观点是在微服务架构中，由于一个Bounded Context的粒度变得越来越小，且代表了跨进程的物理边界，使得区分领域服务与应用服务变得不再那么重要了。换言之，因为微服务的粒度较小，又有着严格的边界控制，业务复杂度与技术复杂度二者的混合产生的负面影响也变得越来越小。</p>
<p>然而，我们不能轻言妥协。只要在微服务边界内依然采用了DDD设计过程，则提炼出一个专门的应用层仍有必要。结合我对DDD的认识，我觉得可以<strong>给应用服务做如下边界定义</strong>：</p>
<ul>
<li>与横切关注点进行协作的只能是应用服务</li>
<li>若应用服务要与领域交互，则尽可能将与横切关注点无关的纯领域行为往领域服务下推</li>
</ul>
<p>基于这个定义，以前面的“下订单”用例为例，对这四个领域行为的封装就应该放在领域服务中（关于邮件通知功能是否属于领域服务，后面有深入讨论）。倘若封装在领域服务中的整体逻辑还需要事务管理，又或者在执行下订单任务之前，需要进行身份认证与授权，则需要将这些逻辑的整合放到应用服务中。</p>
<h3 id="纠结的横切关注点"><a href="#纠结的横切关注点" class="headerlink" title="纠结的横切关注点"></a>纠结的横切关注点</h3><p>假设这个定义是切实可行的，可以作为判断一个服务是否为应用服务的标准，则需要先明确什么是“横切关注点”。前面已经明确给出了“横切关注点”的定义，且说明它应该与业务逻辑无关。但是在判断横切关注点以及整合横切关注点时，除了前面提到的事务、监控、身份验证与授权没有争议之外，DDD社区对如下关注点普遍存在困惑与纠结。</p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>毫无疑问，日志属于横切关注点的范畴。然而，倘若将日志功能仅仅放在应用层，又可能无法准确详细地记录操作行为与错误信息。很多语言都提供了基础的日志框架，将日志混杂在领域对象中，会影响领域的纯粹性，也带来了系统与日志框架的耦合，除非采用AOP的方式。目前看来，这是一种编码取舍，即倾向于代码的纯粹性，还是代码的高质量。我个人还是更看重代码的质量，尤其是丰富的日志内容还有助于运维时的排错，因此建议将对日志共的调用放在领域服务中，算是上述应用服务边界定义的特例。</p>
<p>当然，这个划分并非排他性的。在应用服务中，同样需要调用日志功能，这是记录的信息与粒度与领域服务不尽相同罢了。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>如果是验证外部客户传递过来的消息，例如对RESTful服务的Request请求的验证，则该验证功能属于横切关注点，对它的调用就应该放在应用服务边界。如果验证逻辑属于领域范畴，例如验证订单有效性，这种验证体现的是一种业务规则，则验证逻辑的实现就应该放在领域层，对验证逻辑的调用也应该属于领域对象，包括领域服务。</p>
<h4 id="分布式通信"><a href="#分布式通信" class="headerlink" title="分布式通信"></a>分布式通信</h4><p>微服务缩小了架构设计上的物理边界，使得分布式通信变得更为常见。对于分布式通信的实现毫无疑问属于基础设置层，但在很多情况下，在当前领域中，需要通过分布式通信去访问别的领域提供的服务接口。例如针对“下订单用例”，假设订单、购物车、库存属于不同的微服务，那么在验证订单有效性时，就需要分布式调用库存提供的服务；在提交了订单后，需要分布式调用购物车提供的服务。</p>
<p>这种调用属于对横切关注点的调用吗？<strong>显然不是。</strong>因为从抽象层面讲，这个调用其实是一个业务行为；从实现层面讲，又属于基础设施的技术内容。因此，正确的做法是在领域层定义一个抽象的服务接口，然后通过依赖注入的方式注入到领域服务中。微服务框架Spring Cloud的Feign就支持这种形式的协作。</p>
<p>针对这种分布式通信，Martin Fowler的建议是将消息协议的转换部分（包括验证）放在Gateway模块，而将对外部服务的调用放在Http Client模块中，如下图所示：</p>
<img src="/how-to-identify-application-service/layered-arch.jpg" class="">

<p>从分层的角度讲，Gateway与HTTP Client两个模块都应该属于基础设施层，但代表外部服务业务的接口，应该定义在领域层中。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>与领域逻辑有关的错误与异常，应该以自定义异常形式表达业务含义，并被定义在领域层。此外，如果该异常表达了业务含义，那么在领域层中，可以将异常定义为Checked Exception，以保证业务的健壮性。由于该异常与业务有关，即使被定义在方法接口中，也不存在异常对接口的污染，即可以将异常视为接口契约的一部分。但是，在领域服务中，不应该将与业务无关的Checked Exception定义在领域服务的方法中，否则就会导致业务逻辑（领域）与技术实现（基础设施）的混合。</p>
<p>在应用层中，应尽可能保证应用服务的通用性，因而需要在应用服务中将与业务有关的自定义异常转换成标准格式的异常，例如统一定义为ApplicationException，然后在message或cause中包含具体的业务含义。因此，针对异常处理，只有这部分与业务无关的处理与转换功能，才属于横切关注点的范畴，并放在应用层中，其余异常处理逻辑都属于领域层。</p>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>通知关注点包括邮件通知、短信通知等功能。对于通知服务的实现，由于需要用到邮件或短信网关等具体技术，因此实现细节属于基础设施层。但是，对通知功能的调用，究竟算不算领域行为，却存在着争议。</p>
<p>由于身份验证服务确定属于应用服务，因此我们可以对比身份验证服务与通知服务，或许能从二者的区别中发现蛛丝马迹。分为如下三个角度去对比：</p>
<ul>
<li>DDD的设计角度：通知服务属于Support SubDomain，而身份验证服务则属于Generic SubDomain。</li>
<li>微服务的设计角度：在微服务架构中，通知服务与身份验证服务相同，都属于Infrastructure Service的范畴。从这个角度讲，似乎应该将通知功能视为关注点。不同之处在于，身份验证服务通常会在服务网关中被调用，且实现方式都是被定义为一个filter，放到对Request进行处理的管道上。通知服务则不同，总是与具体业务绑定在一起，只是它的应用范围更加广泛，不特定在某个具体的业务。</li>
<li>用例的设计角度：我们通常将身份验证视为主用例的包含用例（include use case），而将通知服务视为主用例的扩展用例（extend use case）。</li>
</ul>
<p>显然，通知服务与身份验证服务都具有一定的通用性，但本质上又存在一定的区别。</p>
<p>此外，客户对通知服务的调用可能还存在变化，例如针对不同的业务场景，有的需要邮件通知，有的需要短信通知，有的需要组合两种形式。因此，通知服务体现了某种似是而非的朦胧感：</p>
<ul>
<li>与领域相关，但并非核心领域</li>
<li>实现可能存在变化</li>
<li>往往被实现为单独的服务</li>
<li>通知服务自身可能与主业务强相关</li>
</ul>
<p>因为这一点朦胧感，我们不能武断地认为对通知服务的调用一定应该放在领域服务或应用服务。我个人倾向于<strong>将调用通知服务的逻辑放在应用服务中，除非通知服务自身可能与主业务强相关</strong>。例如在“下订单”用例中，假设通知逻辑为：当订单总额达到实现设置的阈值时，应采用邮件通知和短信通知两种形式通知买家发货，否则仅采用邮件通知。这时，通知服务自己形成了业务逻辑，且与下订单主业务直接相关，那么，对通知服务的调用就应该被定义在领域服务中。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>识别实体与值对象的特征</title>
    <url>/how-to-identify-entity-and-value-object/</url>
    <content><![CDATA[<img src="/how-to-identify-entity-and-value-object/cover.jpg" class="">

<p>甄别实体与值对象非常重要，正确与否会直接影响聚合的设计。</p>
<h3 id="聚合是边界"><a href="#聚合是边界" class="headerlink" title="聚合是边界"></a>聚合是边界</h3><p>在DDD中，聚合是实体与值对象的边界。一个聚合对外代表了一个完整的领域概念，遵循面向对象设计的基本原则，聚合内部往往由多个细小的高内聚领域概念组成。聚合内部的领域模型形成了一棵树，树的根必须是实体，可以称之为是<strong>聚合根（Aggregate Root）</strong>，当然，也可以称之为<strong>根实体（Root Entity）</strong>，它是聚合的唯一入口或出口。例如订单聚合定义了<code>Order</code>根实体，它就是订单聚合的唯一代言人。</p>
<p>在一个限界上下文的所有领域模型（实体和值对象）中，按照关系的强弱与概念的完整性，将其划分为多个聚合，就好像草原部落由一个个蒙古包构成了松散的聚居社群一般。</p>
<span id="more"></span>

<p>考虑到值对象与实体的差异，倘若需要管理它们的生命周期，则值对象不可能脱离聚合的边界单独存在。这就意味着，当我们要识别领域模型的聚合时，<strong>实体与值对象之间的强弱关系并不会影响到对聚合边界的界定</strong>。只要实体与值对象之间存在关系，无论关系强弱，该值对象都必须与存在关系的实体放在同一个聚合。如果一个值对象与多个实体之间存在关系，要么说明多个实体都属于一个聚合；要么意味着该值对象需要复制为多份，放到不同的聚合中，如下图所示：</p>
<img src="/how-to-identify-entity-and-value-object/entity-vo.png" class="">



<p>如此一来，对于聚合边界的识别，就变成了<strong>对实体关系强弱的判断</strong>。只要我们正确地甄别了实体与值对象，在识别聚合时，就可以不再考虑值对象，如此就能降低识别的难度。</p>
<h3 id="上下文的影响"><a href="#上下文的影响" class="headerlink" title="上下文的影响"></a>上下文的影响</h3><p>虽然我们知道实体与值对象之间的本质差异在于是否具备唯一的身份标识（identity），然而许多时候，这一差异仍然显得似是而非。更何况，实体与值对象的定义并非绝对，在不同的上下文，同一个领域概念也可能定义为不同的设计类型。例如下图所示的钞票一枚：</p>
<img src="/how-to-identify-entity-and-value-object/money.png" class="">



<p>在购买上下文，买卖双方只关注钞票的面值与货币类型，只要值相等，即可认为是同一个对象，因而需定义为值对象；在印钞上下文，每张钞票都具有一个唯一的标识，即使同为100元的人民币，只要ID不同，也会认为是不同的对象，故而定义为实体。因此，要正确地甄别实体与值对象，需要结合具体的上下文。</p>
<h3 id="识别的特征"><a href="#识别的特征" class="headerlink" title="识别的特征"></a>识别的特征</h3><p>即便如此，仍然缺乏相对客观的判断标准。为此，我总结了如下几个特征。</p>
<h4 id="相等性"><a href="#相等性" class="headerlink" title="相等性"></a>相等性</h4><p>甄别实体与值对象，可以首先从<strong>相等性</strong>进行判断。只要一个领域模型对象的属性值相等，就认为是同一个对象，应优先考虑建模为值对象；否则，需要为领域模型对象定义唯一标识，并建模为实体。</p>
<p><strong>注意：</strong>在进行相等性判断时，不能将作为唯一标识的ID视为领域模型的属性。</p>
<p>例如地址领域概念，只要其属性值国家、省份、城市、街道与邮政编码相等，就可以认为是同一个地址，应将<code>Address</code>类定义为值对象。对于大家耳熟能详的订单领域概念，显然需要为其分配一个唯一的订单编号，因为理论上可能存在除订单编号外其他属性都相同的两个不同订单，应将<code>Order</code>定义为实体。</p>
<p>然而，在对相等性进行判断时，可能出现ID与属性存在一种隐含的对应关系。例如，出版行业中作为正规出版物的图书，具有唯一的ISBN号，它相当于是图书领域概念的ID，所以<code>Book</code>应定义为实体。可在对<code>Book</code>相等性进行判断时，也可以不通过ISBN进行相等性判断，基本上，只要书名、作者（译者）、出版社、价格、出版日期、版次、页数、字数等属性值相同，也可以认为是同一本书，那是否意味着可以将<code>Book</code>定义为值对象呢？</p>
<p>显然，在进行相等性判断时，考虑的属性越多，就会出现多个组合的属性形成一种“隐藏”的唯一标识特征，有一些体现业务规则的ID，自身就是根据属性值来定义的。例如，航班的唯一标识就可以根据承运公司二字码、航班号、起降机场三字码与执飞日期来决定。通过唯一标识固然可以决定是否同一个航班，根据映射的多个属性值，也可以判断相等性。这会让人在甄别实体与值对象时，显得摇摆不定。例如，腾讯会议的会议号是<code>Meeting</code>的身份标识，在比较会议的相等性时，倘若我们考虑了除会议号之外的其他属性，如会议名称、会议类型、开始时间、结束时间、创建人、创建时间等属性，不一样可以确定会议的相等性吗？</p>
<p>因此，除了判断相等性，还需考虑<strong>不变性</strong>。</p>
<h4 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h4><p>Eric Evans建议将值对象定义为不变的类，实则是因为根据值判等的值对象就应该具有不变性。仍以购买上下文的钞票为例，<code>50元+50元=100元</code>，这100元与原来的50元是另一张不同的钞票：</p>
<img src="/how-to-identify-entity-and-value-object/money-plus.png" class="">



<p>反之，一个对象除了ID，其余属性值都可以修改，不需要创建一个新的对象，就可以认为该领域对象是可变的，应考虑定义为实体。如前所述的<code>Meeting</code>对象，只要<code>meetingId</code>值不变，如会议名称、会议类型、开始时间、结束时间这样的属性值即使发生了天翻地覆的变化，我们也认为它是同一个会议。显然，应将<code>Meeting</code>定义为实体。</p>
<p>再考虑一个典型的订单聚合：</p>
<img src="/how-to-identify-entity-and-value-object/order.png" class="">



<p>为什么我们要将订单聚合中的<code>OrderItem</code>定义为实体？如果不考虑ID属性，只要<code>orderId</code>、<code>product</code>与<code>quantity</code>值相同，完全可以认为是同一个订单项。然则，订单项的<code>quantity</code>值是可以更改的，更改了数量的订单项也不会认为是不同的订单项。订单项的可变性决定了它应该定义为实体。</p>
<p>为何要将<code>OrderItem</code>的<code>Product</code>属性定义为值对象呢？要知道，该<code>Product</code>类型还定义了<code>productId</code>属性，既然具有身份标识，不应该定义为实体吗？因为在订单上下文中，商品的<code>productId</code>来自于商品上下文的商品ID，在订单聚合中，可以将<code>productId</code>视为<code>Product</code>类的属性值。只要<code>productId</code>、<code>name</code>和<code>price</code>值相同，就可以认为是同一个商品，且它们的值是不变的。这正是将<code>Product</code>定义为值对象的原因所在。</p>
<h4 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h4><p>即使考虑了相等性和不变性，仍有一种例外情形，那就是考虑<strong>独立性</strong>特征。值对象作为实体的属性必定附属于实体，不能单独存在；如果一个领域对象既满足了相等性，又满足了不变性，可定义为值对象；可是，如果它单独存在，且需要管理其生命周期，就需要将这样的类“升级”为实体。</p>
<p>考虑考勤上下文的假期领域概念。由于中国农历假期的缘故，每年都需要配置新的假期。假期概念对应的<code>Holiday</code>类定义为：</p>
<img src="/how-to-identify-entity-and-value-object/holiday.png" class="">



<p>显然，该类的所有属性值相等，即可认为是同一个假期，一旦修改了假期的值，也可以认为是不同的假期，即<code>Holiday</code>类同时满足相等性和不变性，应定义为值对象。可是，在考勤上下文的领域模型中，<code>Holiday</code>类是完全独立的，不依附于其他任何实体，而它也需要管理生命周期。这时，就应遵循独立性特征，将其“升级”为实体。</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p> 以上三个特征并无重要性排列，需综合考虑。如果仍然无法判断，就遵循<strong>优先级</strong>原则：优先将领域概念建模为值对象。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>面向接口设计与角色接口</title>
    <url>/interface-oriented-design-and-role-interface/</url>
    <content><![CDATA[<p><strong>问题：</strong>在做项目的时候，是不是所有包含非静态方法的类，都要写一个接口？是因为这样的目的是为了解耦，然后通过DI注入实现吗？</p>
<p><strong>回答：</strong></p>
<p>这不是提取接口的根本原因。因为要做到解耦和DI，直接用类也是可以的，尤其Java的普通方法都是允许子类override的。此外，如果你的接口永远都只有一个实现类，并没有任何可能的需求变化，那么还有必要解耦吗？</p>
<span id="more"></span>

<p>所以说，不能死板的将类的方法提取接口，然后美其名曰为<strong>面向接口设计</strong>。我们不能误解“面向接口设计”原则，该原则所指的“接口”并非Java语言中的interface类型，而是指面向调用者对外暴露的接口，代表一种交互与协作，是对信息的隐藏和封装，而不是具体的interface类型。即使是普通的java方法仍然满足隐藏细节的原则，如果是public的，就可以认为该方法是“面向接口设计”中的接口，也就是说：不要针对实现细节编程，而是针对接口编程。</p>
<p>针对java中的interface类型，包含了两种含义：</p>
<ul>
<li>接口代表一种能力。例如在Java JDK中定义了很多这种接口，如<code>Runnable</code>, <code>Cloneable</code>, <code>Seriazable</code>。</li>
<li>接口代表业务场景中与其他类型协作的角色。从语法特性看，就是对履行职责的角色的抽象。Martin Fowler将其称之为Role Interface（角色接口）。</li>
</ul>
<p>例如邮件的收发业务。如果收邮件和发邮件可能会被用到不同的使用场景，换言之，这两个方法不会要求必须同时出现，那么就可以分别为其定义两个接口<code>EmailSender</code>, <code>EmailReceiver</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmailSender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmailReciever</span> </span>&#123;</span><br><span class="line">    Message[] receive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，我们可以定义一个类<code>EmailService</code>同时实现这两个接口，这就是所谓的“大对象、小接口”，又或者说是<strong>接口隔离原则</strong>的体现。</p>
<p>如果你先定义了一个类叫<code>EmailService</code>，然后因为你需要定义接口对其抽象，然后就简单地将这个类的所有公有方法都提取到抽象的接口中，这样设计的接口，被Martin Fowler称为Header Interface。欲知Role Interface与Header Interface，可以参考Martin Fowler的<a href="https://www.martinfowler.com/bliki/RoleInterface.html">这篇文章 </a>。</p>
<p><strong>问题：</strong>收发邮件被用到不同的使用场景，怎么理解？</p>
<p><strong>回答：</strong></p>
<p>比如说，在通知模块中，就只会用到发邮件这个方法，不会用到收邮件；在垃圾邮件识别器功能中，就只会用到收邮件这个功能。</p>
<p><strong>问题：</strong>那这样做有什么好处？</p>
<p><strong>回答：</strong></p>
<p>好处包括：</p>
<ul>
<li>分解到不同的独立接口，你就可以针对不同变化独立演化，而不是让收与发同时变化。</li>
<li>你可以有效地重用，而不是非得把包含所有方法的类都放进去。</li>
<li>可以更好地提高编码可读性，以及类型验证，保证代码的健壮性。</li>
</ul>
<p>例如说转账服务，一个是转出(credit)，一个是转入(debit)。一种方法是定义一个接口<code>Account</code>，提供转入和转出的方法。定义的转账服务方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">credit</span><span class="params">(Money amount)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debit</span><span class="params">(Money amount)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account source, Account destination)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个方法只是从形参的名称体现了转出源与转入目标，这种依靠参数名称对转入和转出账户的顺序做约束是不可靠的。当我们在实现<code>transfer()</code>方法时，也有可能错误地调用<code>Account</code>的方法，导致潜在的bug。</p>
<p>如果我们基于转出上下文和转入上下文分别识别参与的角色，就可以提出两个接口<code>Source</code>与<code>Destination</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">credit</span><span class="params">(Money amount)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Destination</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debit</span><span class="params">(Money amount)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转账的服务方法就可以定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Source source, Destination destination)</span></span>;</span><br></pre></td></tr></table></figure>

<p>你觉得哪个方法更安全、更可读？显然是后者，这就是建立角色接口的好处。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据平台日志存储分析系统解决方案</title>
    <url>/log-storage-and-analysis-based-on-big-data/</url>
    <content><![CDATA[<p>大数据平台日志存储分析系统是在大数据平台下，针对业务系统产生的日志记录进行存储和分析。日志数据来自ElasticSearch存储的日志历史数据，并将需要存储和分析的日志数据从ElasticSearch中读取到Kafka中。Kafka的消费者在侦听到数据消息进入后，以流方式获取数据写入到HBase中。存储在HBase中的数据则是为日志数据的检索与分析提供服务。Web前端通过调用后端API检索HBase中的数据，并进行透视表的可视化展现，展现后的数据支持CSV导出功能。</p>
<span id="more"></span>

<p>本解决方案包括的系统功能为：</p>
<ul>
<li>读取Kafka消息，存储到HBase</li>
<li>检索HBase数据，提供API</li>
<li>显示内容的CSV导出</li>
</ul>
<h3 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h3><p>确定该技术方案的前置条件包括：</p>
<ul>
<li>推送到Kafka的消息已经准备就绪</li>
<li>HBase的数据结构已经确定</li>
<li>日志检索条件固定</li>
<li>后端API已经确定，Web前端会调用该API</li>
<li>Web前端开发已经就绪</li>
</ul>
<h4 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h4><p>整个技术架构如下图所示：</p>
<img src="/log-storage-and-analysis-based-on-big-data/architecture.png" class="">

<p>系统分为三个模块：</p>
<ul>
<li>LogData Collector：通过Spark Streaming订阅Kafka的Topic，收集业务需要的日志数据，然后写入到HBase中。HBase搭建在HDFS的集群中。</li>
<li>LogData Searching：这是一个Spring Boot服务，通过<code>@RestController</code>暴露API接口给前端。其内部则集成Spark，利用Spark SQL查询HBase数据库。</li>
<li>Web UI前端：负责调用LogData Searching服务，并将数据呈现到UI上，并在前端实现显示数据的导出。</li>
</ul>
<p><strong>说明：</strong>导出功能可能有一个变化，倘若前端是分页显示，而导出的数据是符合检索条件的全量数据，则需要在导出时调用LogData Searching服务，获得导出所需的数据，而非前端已经显示的数据。</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Streaming</tag>
        <tag>Big Data</tag>
        <tag>Spark</tag>
        <tag>Kafka</tag>
        <tag>HBase</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>业务架构映射为应用架构</title>
    <url>/mapping-to-application-architecture-from-business-architecture/</url>
    <content><![CDATA[<img src="/mapping-to-application-architecture-from-business-architecture/cover.jpg" class="">

<p>通过《<a href="http://zhangyi.xyz/multi-views-of-business-architecture/">多维度规划业务架构</a>》，我们获得了由业务领域-业务组件-业务服务三个层次组成的业务架构。虽然是架构，但其本质仍然属于问题空间，其目的在于真实地探索问题空间，了解我们要解决什么样的问题。我们用到“分解”的方法，并非在解决问题，而是希望通过横向分层与纵向切分让问题空间变得更小，降低业务复杂度罢了。</p>
<p>这种分解层次体现为：</p>
<ul>
<li>业务领域是对目标系统之系统范围进行划分，划分依据为价值高低</li>
<li>业务组件是对业务领域的划分，划分依据在于业务相关性</li>
<li>业务服务是对业务组件的划分，划分依据在于领域模型的知识语境</li>
</ul>
<p>领域驱动进行的业务分解，既是对问题空间的探索，又自然地暗合确定解决方案的思路。由于有清晰的边界存在，这一做法并未混淆问题空间与解空间，却天然地搭建了一种映射方法，使得我们能够以较小成本将业务架构<strong>映射</strong>为IT架构中的应用架构。</p>
<span id="more"></span>



<p>映射体系如下图所示：</p>
<img src="/mapping-to-application-architecture-from-business-architecture/mapping.png" class="">



<p>在图右侧所示的应用架构中，我旗帜鲜明地标记了前台、中台与后台，意味着我对应用架构的划分遵循了中台战略规划的思想。</p>
<p>我所理解的“<strong>中台</strong>”，满足以下定义：</p>
<ul>
<li>中台是企业数字化转型的能力复用战略规划体系</li>
<li>中台是演进式的能力复用战略动态规划过程</li>
</ul>
<p>显然，<strong>中台不是产品，也不是平台，而是一种规划体系</strong>。在企业架构的应用架构中，中台仅占据了中间代表了“能力服务层”的一部分，体现为由应用组件构成的能力中心。所谓的“能力复用战略动态规划过程”，就是在企业战略愿景的指导下，以能力复用为最终目的：</p>
<ul>
<li>对于产品服务层，通过识别变化频率与复用粒度，逐步将前台的产品特性<strong>沉淀</strong>为可复用的业务能力中心</li>
<li>对于基础服务层，通过识别企业IT资产，逐步从后台的工具与框架中<strong>提炼</strong>出可复用的业务能力中心</li>
</ul>
<p>换言之，中台不是独立的，随着时间的推移，应形成前台、中台和后台（统称为“三台”）职责之间联动；中台也不是静态不变的，同样随着时间的推移，三台的边界发生动态变化。</p>
<p>之所以要为应用架构建立中台，是以复用为目的，提升研发的效率和质量。能力中心的构成，使得整个企业的系统架构可以打破烟囱系统天然构成的壁垒，也有利于它的快速演化，适应企业高速发展的业务需要。</p>
<p>中台战略体系保留了前台，主要是为了适应创新型产品的演变。前台的设计属于产品思维的范畴，因为它牵涉到快速试错的成本，没有时间和成本考虑对复用能力的沉淀，然而，对于中台已经具备的能力中心，不妨取“拿来主义”的态度，直接复用。如此既保证了快，又保证了稳。</p>
<p>在我认为的“三台”中，后台<strong>并非</strong>基础设施，它同样属于业务范畴。从Pace-Layer Architecture的角度讲，后台提供的业务其区别主要在于它的变化频率更低，甚至可能几乎不变；从领域驱动设计的子领域角度讲，后台提供的业务更加通用，以至于考虑购买而非自己构建的方式实现。</p>
<p>如果后台稳定地提供了业务支撑，其收益高于维护成本，则不必一定要将其提炼为能力中心，甚至于它就是一个或多个相对独立而封闭的IT系统，对它的改造存在诸多阻力，改造成本极高，就得允许在企业IT系统生态中继续存在这样的遗留烟囱系统。</p>
<p>不管是前台的产品，还是中台的能力中心，抑或后台的工具或框架，其解决方案皆由应用组件构成，它由业务组件映射而得。本质上，业务组件与应用组件都是限界上下文，但前者对应的限界上下文只考虑了业务边界，后者对应的限界上下文在此基础上继续深化，分别考虑团队角度的工作边界和技术角度的应用边界，进一步梳理限界上下文的边界，使其与应用架构相匹配。为示区分，我将其命名为“应用组件”。</p>
<p>应用组件与限界上下文也有不同之处。在领域驱动设计中，限界上下文确定的是逻辑边界，而在应用架构中，还需要确定它的物理边界。物理边界的确定是从质量属性角度考虑的，例如对可扩展性、可伸缩性、低延迟、高并发的响应，技术栈的限制，资源独立性的要求，可以确定该应用组件究竟应定义为服务（Service），还是库（library）。</p>
<p>通常，中台能力中心的应用组件应考虑微服务化，后台工具或框架则不然，大多数时候，定义为库可能更合适。对于前台，可以考虑一个产品对应一个微服务，也可以考虑一个产品的特性对应一个微服务。这取决于前台产品的粒度。</p>
<p>业务架构中纯粹表达业务的业务服务，在映射到应用架构时，被定义为应用组件需要公开在外的服务接口，我将其称之为“服务契约”，目的是体现服务调用者与服务提供者之间的一种”契约“关系。</p>
<p>一个业务服务映射到解空间，会定义一个服务契约；反之，一个服务契约却未必对应问题空间的业务服务——因为业务服务中的一个执行步骤也可能映射为一个服务契约。应用组件之间存在协作关系，根据<strong>业务服务</strong>的定义，如果一个业务服务的某个执行步骤由另外一个应用组件提供，就需要将其定义为另一个服务契约，但它并非业务服务。例如，“提交订单”业务服务对应于订单应用组件，需要对外公开”提交订单“的服务契约；在执行提交订单的流程时，需要验证库存，该功能由库存应用组件承担。由于订单应用组件会调用它，因而需要对外公开”验证库存“的服务契约，但”验证库存“并非一个业务服务，如下图所示：</p>
<img src="/mapping-to-application-architecture-from-business-architecture/business-service.png" class="">



<p>业务服务属于问题空间的范畴，服务契约属于解空间的范畴，如此才是合理的。</p>
<p>服务契约对应于我提出的《<a href="http://zhangyi.xyz/rhombic-symmetric-architecture/">菱形对称架构</a>》中的北向网关。若应用组件为服务，则对应远程服务；为库，则对应本地服务。它们都不属于领域层的内容。业务服务的需求表现为业务服务规约，它的输入成为领域分析建模的基础；服务契约需要构成菱形对称架构的角色构造型共同协作完成，利用服务驱动设计可以驱动出领域设计模型，进而对其进行建模实现。</p>
<p>从产品/能力中心/工具/框架到应用组件，再从应用组件到服务契约，都有领域驱动设计的对应模式或方法去实现，由此就能实现应用架构的真正落地。若按照中台战略思想规划应用架构，意味着中台的落地也有了可供参考的实现过程与方法。当然，通常所谓的”中台“，都会建立双中台，即业务中台和数据中台。这里参考了领域驱动设计的方法，针对的是业务中台的落地，亦可以理解为是应用架构的微服务化。至于数据中台，它关注的是全域数据的生命周期管理、数据资产的梳理与建设、全域数据分析与数据智能挖掘的数据服务，其着眼点显然和业务中台有着天壤之别，需要另外的设计方法与实现手段。</p>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Architecture</tag>
        <tag>EA</tag>
      </tags>
  </entry>
  <entry>
    <title>设计一个小接口展开的讨论</title>
    <url>/discuss-about-interface-design/</url>
    <content><![CDATA[<p>蔡了戴着耳机一边哼着歌一边晃着头沉浸在自己的音乐世界里。8点45分，距离早会还有半个多小时，放松一下，抽空自娱自乐！</p>
<p>“蔡了！”办公室传来中气十足的呼唤声，似乎整个写字楼都回荡着蔡了的名字。</p>
<p>“哎，明明就只隔几个工位，还要吼得整栋楼都听得到，不明真相的，还以为我又犯什么错了呢！”蔡了一边腹诽着，一边回应着“来了来了”，丢下耳机就向马大叔的工位跑去——没办法，头儿的呼唤，怎敢不从？</p>
<p>“马大叔！什么事啊？不会我的代码又没写好吧？”蔡了看着电脑屏幕的光线投射在马丁花那张老脸上，阴晴不明，心里一紧，说话也变得小心翼翼起来。</p>
<p>“没事就不能叫你？”马丁花脸一板，像指挥军队的将军一般将手一挥，说到：“过来，过来！我今早一来就pull了代码，正好看到你提交的代码。”</p>
<span id="more"></span>

<p>蔡了一听，知道老马又要上课了，赶紧推了一把椅子，收了心里的腹诽，像个乖乖女一般规规矩矩地坐下来，看着老马屏幕上打开的一个类。正是昨天自己写的一个工厂类<code>Kafka251Factory</code>。</p>
<p>“这样的工厂类我们写了很多，按理说你可以参考，但我看你写的代码却有些不同，为何这两个创建方法要定义为实例方法呢？”</p>
<img src="/discuss-about-interface-design/01.png" class="">

<p>“老大，我是这样想的。我觉得这两个创建方法传入的参数都一样，为了避免重复，我就将它们定义成了字段。因为要使用字段，就不能用静态方法罗！”蔡了一想到昨天自己灵机一动，通过提取字段有效避免了方法参数的重复定义，不免有些沾沾自喜。</p>
<p>“哦，小蔡不错哟，都有很强的重用意识了！但是——”话锋一转，马丁花开启了循循善诱的教导模式，“你有没有好好比较两种不同定义的调用代码呢？”一边说，一边在电脑上敲出如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">new</span> Kafka251Factory(config.kafka(), <span class="string">&quot;topic&quot;</span>).createSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line">Kafka251Factory.createSource(config.kafka(), <span class="string">&quot;topic&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>“这个……”蔡了转着大大的眼睛，努力想说出点颇有见地的答案，只可惜转了半天，还是想不出一二三。</p>
<p>马丁花看蔡了半天回答不上，也不着恼，缓缓说道：“你要学会站在调用者的角度看待API设计。这里虽然都是一行调用代码，但是要创建一个实例和直接调用类型的静态方法给人的观感还是不同的。虽然从可扩展性的角度看，面向对象鼓励我们尽可能定义实例方法，但对于工厂方法而言，方式2定义的静态工厂方法还是要更直接一些。更何况，作为一个工厂对象而言，频繁地创建工厂实例，既无必要，也增加了垃圾回收的负担。”</p>
<p>蔡了点点头，说道：“大叔，我貌似懂了，就是说从调用者的直觉来看，这样的静态工厂方法应该更符合调用者的期望。我说得对吗？”</p>
<p>“不错不错，朽木可雕也！”马丁花哈哈地笑起来，很欣慰自己的一番教导总算没有白费。可惜没有长长的胡须可以抚弄，否则倒有几分爷爷看孙女的感觉，如今这般笑着，无奈只得扫入怪大叔的行列了。</p>
<p>“可是，这样的定义不是导致方法参数的重复了吗？”蔡了仍不甘心推倒自己的重用成果，指着重构为静态工厂方法的<code>Kafka251Factory</code>类，继续问道。</p>
<img src="/discuss-about-interface-design/02.png" class="">

<p>“如果一个类的多个实例方法接收的输入参数相同，确实可以将这些参数当做该类的字段，如此即可减少参数的传递，而且从生命周期来看，既然多个实例方法都会用到它们，说明它们的作用范围要广于方法的范围，可以认为是当前类自身携带的数据，将它们定义为字段，然后在构造函数中接收其值，这一设计是合理的。但是，对于静态方法来说，由于方法参数与当前类的生命周期并非一致，我们就不能贸然地将其改为实例方法，否则就会增加调用者的负担。如果静态方法的参数太多，大可以通过提取Parameter Object封装多个内聚的参数，减少方法参数数量。”</p>
<p>马丁花说到这里，想了想，继续说道：“若要说重复，代码中的<code>config.item(label).topic()</code>出现了两次，有着很明显的重复代码坏味道，可以再改进一下。”</p>
<p>“这个还不简单！”蔡了终于逮住表现自己的机会，一把抢过摆在电脑面前的键盘，熟练地将光标移到这行代码，按下Ctrl+Alt+M快捷键，将其提取为一个方法：</p>
<img src="/discuss-about-interface-design/03.png" class="">

<p>“看起来提取方法确实消除了重复，但你觉得它带来了有效的重用了吗？”马丁花点点头，又摇摇头，继续问道。</p>
<p>蔡了皱起眉：“呃……提取的方法做到了重用，可惜要重用的代码实在太少，看起来区别不大啊！”</p>
<p>“确实如此，然而……关键不在于这里。”马丁花说罢，接过键盘，把光标挪到getTopic方法下，解释道：“你看这里，两个工厂方法实际上希望获得的是topic，这个topic又是通过config的item与传入的label来获得的。虽说这段代码非常简短，实际上它仍然暴露了获取topic的细节。”马丁花的语气开始加重，这是要敲黑板了：“<strong>记住！当你发现调用一个对象时，频繁出现多个方法链式的调用，只要不是像Java Stream API那样的流畅接口，都说明它的封装不够彻底，属于Martin Fowler指出的Message Chain坏味道，有人也将这一坏味道称之为‘火车残骸’！</strong>”</p>
<p>“哦！”蔡了恍然大悟！</p>
<p>“还记得我给你讲过的<strong>信息专家模式</strong>与<strong>迪米特法则</strong>吗？你结合这两个原则想想这里的问题所在！”马丁花不愧是经验丰富的资深咨询师，逮住机会就开始启发式教育了。</p>
<p>蔡了用手支住自己的小脸，开启大脑的Google搜索模式，似乎都能听到敲木鱼的声音，然后“叮”的一声，欢呼雀跃地叫到：“我知道了！如果根据迪米特法则，<code>KafkaConfig</code>的<code>Item</code>对象是<code>Kafka251Factory</code>的陌生人，根本就不需要知道它；根据信息专家模式，无论是<code>Item</code>还是<code>Topic</code>，其实都是<code>KafkaConfig</code>的信息，因而获取topic的职责就应该转移给<code>KafkaConfig</code>来承担，所以……”蔡了拿过键盘，流畅地按下F6，完成方法的移动，再通过ctrl+alt+shift+t调出重构万能键的快捷菜单，迅速通过convert to instance method重构手法将静态方法修改为实例方法。只见她白皙的双手在键盘上跳动着，像弹钢琴一般，动作如行云流水，十分好看，很快就完成了重构：</p>
<img src="/discuss-about-interface-design/04.png" class="">

<p>当然，<code>getTopic</code>方法已经顺理成章转移到了<code>KafkaConfig</code>那里。</p>
<p>“不错，写代码就得有这样的态度！虽然代码的质量仅得到了微量的改进，却只有如此，<strong>代码才能不断打磨，趋于完美，你的技能也能不断精进</strong>。最关键的是，这样小步地重构既安全，也没有什么成本，何乐而不为呢？好了，要开站会了，赶紧去准备吧。你重构的代码我一会提交！”</p>
<p>“好的！谢谢大叔！”蔡了知道自己水平菜，老马则是逮住机会就给自己学习的机会，这一声感谢，确实由衷而发。说完转过身，连蹦带跳地回到自己的工位。还没坐下来，又听到大叔一声吼：“蔡了，记得查一下资料，搞清楚静态工厂到底用了什么模式，它会对设计带来什么好处。明天的作业，我要检查哈！”</p>
<p>“哦！”蔡了苦着脸应下来，心里不禁骂道：“这个死老头，都不让人轻松一点！我的命怎么这么苦啊！”心里对马丁花积累的5点好感值瞬间烟消云散了。</p>
]]></content>
      <categories>
        <category>蔡了成长记</category>
      </categories>
      <tags>
        <tag>Design, OO</tag>
      </tags>
  </entry>
  <entry>
    <title>企业架构与领域驱动设计的融合</title>
    <url>/enterprise-architecture-and-ddd/</url>
    <content><![CDATA[<img src="/enterprise-architecture-and-ddd/2021-06-07.jpg" class="">

<p>DDD的作用范围主要还是针对系统级的分析、架构与设计，在更高的层面上，即将问题空间扩大到超过系统范围，变成企业或组织范围之后，DDD的模式就显得捉襟见肘了。此时，可以考虑引入企业架构的思想，尤其是业务架构的内容，给了DDD很好的补充，又或者说，将企业架构与DDD融合起来，就能真正串联起战略和战术设计了。</p>
<p>为什么在传统企业中，DDD开始得到了许多企业的追捧？不仅仅是微服务的原因，就我个人不成熟的判断，应该是数字化转型开始倒逼着传统企业的IT部门开始接纳了DDD这一方法体系。</p>
<span id="more"></span>

<p>数字化转型对企业的要求，表现在以下方面：</p>
<ul>
<li>企业架构与行业的结合程度</li>
<li>数字化的企业IT架构</li>
</ul>
<p>所谓“行业”，也可以理解为“领域”，传统企业在互联网经济的冲击下，开始向更快、更强的要求转变，但真正的快，绝不是没有规划，恰恰相反，需要在战略上有着清晰的转型目标，而在战术（企业的战术层面，对应于DDD的战略层次）上需要沉淀企业的领域资产。不管这些领域资产是通过核心模型、服务还是其他组件形式，都需要对准转型方向的企业战略，并在战略指导下做到可复用业务能力的识别与沉淀。这个过程可以是计划式的，也可以是演进式的；可以是分解为服务的粒度，也可以是能力中心的粒度；可以采用领域驱动设计建立核心领域模型，也可以建立自治的微服务，也可以是中台的能力规划与战略。</p>
<p>数字化转型必然不仅仅是业务的转型，还包括IT架构的转型。当前的一个趋势是在基础设施上，向着云原生架构转变；在能力建设上，要改变组织模式，同时也要从项目思维向产品思维转变；同时，还要加强对数据的重视，全面拥抱互联网数据、物联网数据，做到业务与数据的双向支撑；在技术复用方面，也提出了前所未有的高要求，不管是PaaS、SaaS还是中台的能力中心，或者微小粒度的服务与组件，更或者是近期炒得火热的低代码平台，其核心关键还是遵循八二原则，尽可能将能够复用的技术实现、业务模型（包括流程与规则）的开发成本降低，如此就能满足快速开发产品服务不断应对产品创新的需要，又能合理分配人力成本，花更多人力与物力去做好高价值的东西。</p>
<p>要做好企业的数字化转型，就要“从企业整合运作、提升竞争力的角度出发，站在企业全局的高度，从理解企业所处行业、发展阶段、目标、战略、竞争环境等多方面入手，认清其核心能力及管理中存在的主要问题，在此基础上进行管控模式分析，提出关键业务流程的优化建议”[引自《微服务设计：企业架构转型之道》]，简单说来，数字化转型是企业层面的全面转型，同时也是企业高管的思维转型。为了规避风险，也为了企业的转型步子能够迈得更坚实，又需要根据轻重缓急分阶段实施。实施的过程必然是自上而下的，但是随着从顶层到底层的逐步细化，粒度也在不断缩小，待缩小到目标系统的层次时，就是DDD登上舞台的最佳时机了。</p>
<p>我曾经和多位业务架构师聊过企业架构与DDD的关系，窃以为企业架构在宏观层面上有着自己一套成熟的体系方法，如TOGOF和Zachman等企业架构体系，它庞大的规范、标准与过程非常值得IT部门学习，值得将其引入到数字化转型作为参考；然而，这些方法的问题在于：</p>
<ul>
<li>过于复杂：虽然企业自身复杂度决定了体系的复杂性，但一套体系如果过于复杂，许多人穷其一生可能都无法掌握其全貌与细节，就很难掌控，更谈不上落地；</li>
<li>过于宏观：利用企业架构的思想和方法对企业做完战略规划后，如何保证方案的落地，又如何保证落地过程完全遵循解决方案的要求不偏不倚地推进，缺乏有效的手段。</li>
</ul>
<p>企业架构就好似画出了企业战略规划的模板，模板中的空白部分就是落地需要的知识和能力。利用业务架构，已经对这些模板与空白进行了有效的切分，并明确了各自的边界，企业架构对业务架构向IT架构的映射给予了架构的指导，接下来，就可以通过DDD高质量地填充这些空白。</p>
<p>因此，企业架构与领域驱动设计是完全能够融合在一起的，促进这一融合的催化剂是数字化转型，呼唤这种融合的需求来自于相对高高在上的企业架构需要具备落地的能力，至于这种融合为何在现在开始提出或得到重视，是因为当下这个时代，具备了向这个趋势发展的天时地利与人和：</p>
<ul>
<li>天时：数字化转型已经提上了大多数传统企业的议事日程，不得不上，也必须上，而且得快上；</li>
<li>地利：各种IT基础架构已经满足了这一要求，无论是云原生、微服务、大数据，还是所谓的中台，为这一融合打下了良好的基础，敏捷思想已经深入人心，IT的管理能力与构建能力得到了大幅度的提高；</li>
<li>人和：数字化转型让企业高层领导看到了转型的迫在眉睫，转型的战略规划与IT架构构建已经时不我待，业务人士与IT人士都看到了这一趋势，并开始打破业务与IT的壁垒，寻求全方位的合作。</li>
</ul>
<p>如果说以上内容指出了这一融合趋势，回答了融合的必要性，那么该怎么融合的问题就摆上了议事日程，毕竟二者并不处于同一层次，关心的角色也可能在身份地位上存在天壤之别。我的一个粗浅想法，是希望借鉴DDD的方法与思想，寻求对企业架构做必要的精简和简化，核心价值仍然是领域（业务）驱动，然后尝试建立不同层次的架构体系，即建立组织级与系统级的架构，让企业架构方法与DDD方法各司其职，组织级的棘手问题交给企业架构，系统级的落地问题交给DDD。</p>
<p>以上观点很不成熟，个人对企业架构的认识也非常粗浅。从学习路线看，我算是自下而上的狂飙猛进，不再满足于领域驱动设计的系统层次，要向上开始向企业顶层设计“逆袭”，之后，不是高高在上去俯视IT众生，而是沉下心来，完成二者的真正融合——既要做得了规划，还能写得出方案，针对核心实现，还要能撸得出代码。如此就算是打通业务（领域）驱动的任督二脉了！</p>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>EA</tag>
      </tags>
  </entry>
  <entry>
    <title>软件系统中的模型</title>
    <url>/model-of-software-system/</url>
    <content><![CDATA[<img src="/model-of-software-system/header.jpeg" class="">

<p>从领域驱动的战略设计进入战术设计，简单说来，就是跨过系统视角的限界上下文边界进入它的内部，从分层架构的逻辑分层进入到每一层的内部。在思考内部的设计细节时，首先需要思考的问题就是：什么是模型（Model）？</p>
<span id="more"></span>

<h3 id="什么是模型"><a href="#什么是模型" class="headerlink" title="什么是模型"></a>什么是模型</h3><p>还是来看看Eric Evans对模型的阐述：</p>
<blockquote>
<p>为了创建真正能为用户活动所用的软件，开发团队必须运用一整套与这些活动有关的知识体系。所需知识的广度可能令人望而生畏，庞大而复杂的信息也可能超乎想象。模型正是解决此类信息超载问题的工具。模型这种知识形式对知识进行了选择性的简化和有意的结构化。适当的模型可以使人理解信息的意义，并专注于问题。</p>
</blockquote>
<p>如何才能让“庞大而复杂的信息”变得更加简单，让分析人员的心智模型可以容纳这些复杂的信息呢？那就是利用抽象化繁为简，通过标准的结构来组织和传递信息，形成一致的可以进行推演的解决方案，这就是“模型”。模型反应了现实问题，表达了真实世界存在的概念，但它并不是现实问题与真实世界本身，而是分析人员对它们的一种加工与提炼。这就好比真实世界中的各种物质可以用化学元素来表达一般，例如流动的水是真实世界存在的物体，而“水（Water）”这个词则是该物体与之对应的概念，$H_2O$则是水的模型（同时，$H_2O$也是化学世界中的统一语言）。</p>
<p>模型往往会作为交流的有效工具，因而会要求用经济而直观的形式来表达，其中最常用的表现形式就是图形。例如轨道交通线网图：</p>
<img src="/model-of-software-system/beijing-metro.gif" class="">

<p>说明：本图来自<a href="http://bj.bendibao.com/ditie/linemap.shtml">本地宝</a>的北京城市轨道交通线网图。</p>
<p>该交通线网图体现了模型的许多特点。首先它是抽象的。与地图不同，它并非现实世界中轨道交通线网的缩影，图中的每条轨道其实都是理想化的几何图形，以线段为主，仅仅展现了轨道线的方位、走向和距离。其次它利用了可视化的元素。这些元素实际上都是传递信息的信号量，例如使用不同的颜色来区分线路，使用不同大小的形状与符号来区分普通站点与中转站。模型还传递了重要的模型要素，例如线路、站点、站点数量、站点距离、中转站以及方向，因为对于乘客而言，仅需要这些要素即可获得有用的路径规划与指导信息。</p>
<p>针对现实世界的问题域建立抽象的模型形成解决方案，这个过程视软件复杂度而定，可能会非常漫长。这其间需要迭代的分析、设计和实现，逐步浮现出最终可行的方案，构建满足需求的软件。从问题域到解决方案域，或许有多种途径或手段，然而针对复杂问题域，通过建立抽象的模型来映射现实世界的多样性，就好似通过数学公式来求解一般，是实践证明可行的道路：</p>
<img src="/model-of-software-system/model01.png" class="">

<p>模型的重要性并不体现在它的表现形式，而在于它<strong>传递的知识</strong>。它是从需求到编码实现的知识翻译器，通过它对杂乱无章的问题进行梳理，消除无关逻辑乃至次要逻辑的噪音，然后再按照知识语义进行归纳与分类，并遵循设计标准与规范建立一个清晰表达业务需求的结构。这个梳理、归纳与分类的过程就是建模的过程，建立的结构即为模型。建模过程与软件开发生命周期的各种不同的活动（Activity）息息相关，它们之间的关系大体如下图所示：</p>
<img src="/model-of-software-system/model02.png" class="">

<p>建模活动用灰色的椭圆表示，它主要包括需求分析、软件架构、详细设计和编码与调试等活动，有时候，测试、集成与保障维护活动也会在一定程度上影响系统的建模。为了便于更好地理解建模过程，我将整个建模过程中主要开展的活动称之为“建模活动”，并统一归纳为分析活动、设计活动与实现活动。每一次建模活动都是<strong>对知识的一次提炼和转换</strong>，产出的成果就是各个建模活动的模型：</p>
<ul>
<li>分析活动：观察现实世界的业务需求，依据设计者的建模观点对业务知识进行提炼与转换，形成表达了业务规则、业务流程或业务关系的逻辑概念，建立<strong>分析模型</strong>。</li>
<li>设计活动：运用软件设计方法进一步提炼与转换分析模型中的逻辑概念，建立<strong>设计模型</strong>，使得模型在满足需求功能的同时满足更高的设计质量。</li>
<li>实现活动：通过编码对设计模型中的概念进行提炼与转换，建立<strong>实现模型</strong>，构建可以运行的高质量软件，同时满足未来的需求变更与产品维护。</li>
</ul>
<p>整个建模过程如下图所示：</p>
<img src="/model-of-software-system/model03.png" class="">

<p>不同的建模活动会建立不同的模型，上图表达的建模过程体现了这三种模型的递进关系。但是，这种递进关系并不意味着分析、设计与实现形成一种前后相连的串行过程，而应该是分析中蕴含了设计，设计中夹带了实现，甚至在实现中回溯到设计，从而形成一种迭代的螺旋上升的演进过程。不过，在建模的某一个瞬间，针对同一问题，分析、设计与实现这三个活动不能同时进行，这就好似开发过程中不能同时戴上重构与功能实现这两顶帽子一般，它们其实是相互影响、不断切换与递进的关系。一个完整的建模过程，就是<strong>模型驱动设计（Model-Driven-Design）</strong>。</p>
<p>不仅仅是建模活动会对模型带来影响，设计者在面对业务需求时，关注的视角不同，抽象的设计思想不同，也会导致模型的不同，这就形成了从建模视角产生的模型分类。如果我们是以数据为核心，关注数据实体的样式和它们之间的关系，由此建立的模型就是“<strong>数据模型</strong>”。如果我们需要为系统外部的客户端提供服务，关注的是客户端发起的请求以及服务返回的响应，由此建立的模型就是“<strong>服务模型</strong>”。而领域驱动设计则强调以领域为中心，通过识别领域对象来表达业务系统的领域知识包括业务流程、业务规则和约束关系，由此建立的模型就是“<strong>领域模型</strong>”。这三种不同的模型，就是不同视角的模型驱动设计获得的结果。因此，整个模型驱动设计可以分为两个不同的维度来表现模型，即建模视角与建模活动。不同的建模视角驱动出不同的抽象模型，而不同的建模活动，也会获得不同抽象层次的模型。这两个维度表达的模型驱动设计如下图所示：</p>
<img src="/model-of-software-system/model04.png" class="">

<p>无论分析模型、设计模型还是实现模型，它们皆是对现实世界的抽象，只是抽象的层次和目的不同罢了。如何观察现实世界，又可能影响我们最终获得的模型。当我们将现实世界视为由数据组成的系统时，就可以建立一个由数据实体概念组成的软件世界，并驱动着获得<strong>以数据模型为核心的解决方案</strong>。当我们将现实世界隐喻为一个Web系统时，现实世界的任何事物都是暴露给Web系统的资源，这就获得了<strong>以服务资源模型为核心的解决方案</strong>。当我们将现实世界认为是提供服务行为的容器，并由此产生与消费者的协作，就获得了<strong>以服务行为模型为核心的解决方案</strong>。当我们将现实世界看做是由核心领域与子领域组合而成的问题域时，我们就将围绕着领域模型为核心，驱动并指导着我们的设计，形成<strong>以领域模型为核心的解决方案</strong>。</p>
<p>Eric Evans认为模型驱动设计是领域驱动设计中的一种模式。它并没有给出模型驱动设计的定义，只是提出“严格按照基础模型来编写代码，能够使代码更好地表达设计含义，并且使模型与实际的系统相契合。”但我认为，模型的范围要大于领域模型，设计过程也会因为建立模型的不同而各有不同的路径与方向。于是，数据视角产生数据模型驱动设计，服务视角产生服务模型驱动设计，领域视角则产生领域模型驱动设计。在模型驱动的设计过程中，我们获得的模型还将受到建模范式的影响，尤其针对设计与实现，建模范式就意味着设计思想与编程范式的不同，最后获得的模型可能会大相径庭。</p>
<p>因此，要理解和学习领域驱动设计，我们需要辨别各种模型的差异，理解建模范式对模型产生的影响，同样还要认识到：领域驱动设计不过是模型驱动设计中的一种罢了。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>利用聚合概念指导MongoDB的Schema设计</title>
    <url>/mongodb-schema-design-using-aggregate/</url>
    <content><![CDATA[<img src="/mongodb-schema-design-using-aggregate/logo.jpg" class="">
<p>习惯的力量强大却往往无法察觉。往往不经意之间，陷入习惯的陷阱中却不自知。</p>
<p>在我们的项目中，为了能够保存分析报表以及用户设置的报表查询条件，我们将这些信息视为报表元数据存储在MongoDB中。要存储的元数据包括：</p>
<ul>
<li>报表分类（ReportCategory）</li>
<li>报表（Report）</li>
<li>报表查询条件（QeuryCondition）</li>
</ul>
<p>一个报表分类会包含多个报表，同一个报表只能属于一个分类。每个报表提供了多个标准查询条件和多个用户自定义查询条件。</p>
<span id="more"></span>

<p>我需要为这些元数据设计MongoDB的DB Schema。最初考虑将这三个概念合起来定义为元数据表的一条记录。之后想到对于一个报表而言，需要频繁对报表的查询条件进行增删操作，似乎又应该将查询条件单独分离出来。那么报表分类与报表呢？是否将报表也独立出来才合适？对于MongoDB这样的Document数据库而言，将Report作为ReportCategory的embedded属性也是可行的，至少不会像关系型数据库那样会产生数据冗余。倘若要分开，当需要查询某个分类下的所有报表时，还得多余地做一次Link。</p>
<p>好纠结啊！似乎怎么设计都是可行的，又仿佛总有不如意处。</p>
<p>正在思索中，突然想起对于这样面向文档的NoSQL数据库而言，使用聚合（Aggregate）来观察表记录会更加恰当。这个想法恍若闪电般迅捷而锐利，猛地撞向脑中的思绪，一下子点燃了我的设计思维。</p>
<p>这里所谓“<strong>聚合</strong>”，非面向对象中表达对象关系的概念，而是领域驱动设计（DDD）对对象边界的思考。关于聚合（Aggregate）的设计，我根据过往的经验，整理出五条设计原则：</p>
<ul>
<li>聚合作为一种边界，主要用于维护业务完整性，此时应遵循业务规则中定义的不变量（Invariant）</li>
<li>作为聚合边界内的非聚合根实体对象，若可能被别的调用者单独调用，则应该作为单独的聚合分离出来</li>
<li>在聚合边界内的非聚合根对象，与聚合根之间应该存在直接或间接的引用关系，且可以通过对象的引用方式；若必须采用Id来引用，则说明被引用的对象不属于该聚合</li>
<li>若一个对象缺少另一个对象作为其主对象就不可能存在，则该对象一定属于该主对象的聚合边界内</li>
<li>若一个实体对象，可能被多个聚合引用，则该实体对象应首先考虑作为单独的聚合</li>
</ul>
<p>这些设计原则都是我在探索聚合设计时的一些思考，多次实践下来，窃以为颇有指导价值。这里不再铺开，留待以后的文章详述。单说本例，我们该如何运用这些原则来思考ReportCategory、Report与QueryCondition之间的关系？</p>
<p>显然，套用这些原则，我认为前面纠缠不清的混乱思路已可迎刃而解。从业务完整性看，Report虽属于ReportCategory，但二者未尝有强的约束关系，即不存在业务上的不变量（Invariant）。例如ReportCategory可以没有Report，成为一个空的分类，我们也可以撇开ReportCategory，单独查询所有的Report。倘若我们将Report放到ReportCategory聚合中，由于Report可能会被单独调用，聚合的边界保护反而成为了障碍，不合理。</p>
<p>于是，我们可以得出第一个结论：<strong>ReportCategory和Report应该属于两个不同的聚合</strong>。</p>
<p>基于第四条原则，我们可以提出问题：当QueryCondition缺少Report对象后，还有存在意义吗？答案一目了然，没有Report，就没有QueryCondition。皮之不存毛将焉附！第二个结论自然得来：<strong>Report与QueryCondition应属于同一个聚合</strong>。于是，模型呼之欲出：</p>
<img src="/mongodb-schema-design-using-aggregate/aggregate.png" class="">

<p>上图是领域模型而非数据模型。站在领域驱动设计的角度，这才是正确的打开姿势。那么，使用该领域模型去指导MongoDB的Schema设计，是否有将领域混入技术实现之嫌呢？从设计方向看，先考虑领域模型才是正解，DB的技术实现应为了满足该领域模型而设计。只有当领域模型可能阻碍技术实现，又或者依据领域模型得到的Schema设计不满足性能或其他质量属性需求时，才应该反过来调整领域模型。对于MongoDB这种面向Document的数据库，以聚合概念指导Schema设计，可谓水到渠成，不仅没有违和之感，反而让Repository的实现变得更加简单、自然。</p>
<p>在项目开发过程中，我先入为主地做了技术选型，从而习惯性地开始针对MongoDB进行Schema设计，反而忘了领域驱动设计的指导原则。技术人员对技术实现往往见猎心喜，因而忽略了领域设计的驱动力，慎之慎之！</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>多维度规划业务架构</title>
    <url>/multi-views-of-business-architecture/</url>
    <content><![CDATA[<img src="/multi-views-of-business-architecture/cover.jpg" class="">

<p>领域驱动设计的社区主流声音是划分问题空间（Problem Space）与解空间（Solution Space）。整个问题空间实际上就是团队开发的目标系统对应的领域，这实际上也是业务架构要描述的目标。领域驱动设计解决大规模问题空间的方法或模式是引入子领域（Subdomain）。</p>
<p>根据价值高低的不同，子领域分为核心子领域、支撑子领域和通用子领域。若将其引入到业务架构，似乎可以根据价值高低建立不同的服务层，例如：</p>
<ul>
<li>核心子领域：产品服务层，体现为子领域专用的产品服务</li>
<li>支撑子领域：能力服务层，体现为跨子领域复用的能力服务</li>
<li>通用子领域：基础服务层，体现为与领域无关的基础服务</li>
</ul>
<p>不同的层次代表了复用的粒度和水平。基础服务层因为与领域无关，它复用的范围更广泛，对应为业务架构中的支撑业务（支撑部门提供的职能），如财务体系、人力资源体系、行政体系、采购体系等。原则上，任何企业都需要这些支撑业务，而与企业从事的领域方向无关。引入领域驱动设计的概念，我将其纳入到通用子领域的范畴。</p>
<span id="more"></span>



<p>企业核心业务对应为核心子领域，对外公开为一个个相对完整的产品服务。一个产品服务可以认为对应一个核心子领域。在识别核心子领域（产品服务）的过程中，我们需要遵循能力复用的原则，尝试去寻找那些可以跨子领域复用的业务能力，然后自上而下进行沉淀，从而形成映射支撑子领域的能力服务层。</p>
<p>以上内容，我称之为<strong>领域维度的业务架构规划</strong>，如下图所示：</p>
<img src="/multi-views-of-business-architecture/domain.png" class="">



<p>从商业维度，Gartner定义了Pace-Layered Architecture，如下图所示：</p>
<img src="/multi-views-of-business-architecture/gartner-pace-layered.png" class="">



<p>它按照变化速率将企业应用分为了三个层次：</p>
<ul>
<li>创新型系统，SoI（System of Innovation)</li>
<li>差异型系统，SoD（System of Difference）</li>
<li>记录型系统，SoR（System of Record）</li>
</ul>
<p>Gartner分别从变化频率、生命周期、规划远景、治理模型、利益相关者、资金和架构七个角度阐述了各个层次的特征与属性。</p>
<p>商业维度的划分依据可以对领域维度的业务架构规划进行指导与调整，当然，它们之间也存在若有若无的映射关系，形成了如下图所示的<strong>商业维度的业务架构规划</strong>：</p>
<img src="/multi-views-of-business-architecture/business.png" class="">



<p>子领域的划分在业务架构规划的每个层次形成各自的子领域，它是分解问题空间的最高抽象层次（依据分解粒度），我将其称之为“业务领域”。在业务领域之下，是由业务服务组成的业务组件。</p>
<p>这里的<strong>业务服务</strong>与<strong>业务组件</strong>是我自己提出的定义，并非业务架构知识体系中的概念：名称相同，含义并不完全相同。</p>
<p>业务架构的业务服务“表示显式定义的暴露业务行为，代表了用于实现组织内外客户需求的服务，并处理主体与主体之间、主体和客体之间的连接物”。这一定义没有清晰地说明业务服务到底是什么，也没有明确划分依据，无法确定其设计粒度。我在《解构领域驱动设计》一书中明确指出了业务服务的定义，即它是“角色主动向目标系统发起服务请求，完成一次完整的功能交互，体现了服务价值的业务行为”，如下图所示：</p>
<img src="/multi-views-of-business-architecture/business-service.png" class="">



<p>基于这一定义，可以确定业务服务的粒度与层次。</p>
<p>在业务架构知识体系中，IBM提出了业务组件模型，“采用目标、资源、活动、治理、服务5个标准属性来表达能力以及能力之间的关系”。我所定义的业务组件其本质实际是业务角度的<strong>限界上下文</strong>。</p>
<p>通常认为，限界上下文属于解空间的DDD模式，但在识别限界上下文时，实际上首先是从业务角度对基本的业务单元（即业务服务）进行归类与归纳。在规划业务架构时，如果我们仅将限界上下文视为领域模型的知识语境边界，不去考虑技术实现的内容，那么，将其映射为业务架构的业务组件也未尝不可。</p>
<p>由此，就形成了业务领域-业务组件-业务服务的分析粒度层次，我将其称之为<strong>分析维度的业务架构规划</strong>，它是业务架构映射为应用架构的基础，使得整个企业架构具备了落地的可能性。这一维度的业务架构规划如下图所示：</p>
<img src="/multi-views-of-business-architecture/analysis.png" class="">



<p>领域维度的判断依据是领域价值的高低，商业维度的主要判断依据是变化速率和规划愿景，它们共同映射为不同服务层次进行规划的业务架构，最后从分析维度对每个服务层次的业务逻辑进行切分与细化，为业务架构映射为应用架构提供落地实现的基础。</p>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Architecture</tag>
        <tag>EA</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala的面向对象与函数编程</title>
    <url>/oo-and-fp-of-scala/</url>
    <content><![CDATA[<p>很难说FP和OO孰优孰劣，应该依场景合理选择使用。倘若从这个角度出发，Scala就体现出好处了，毕竟它同时支持了OO和FP两种设计范式。</p>
<p>从设计角度看，我认为OO更强调<strong>对象的自治</strong>，即每个对象承担自己应该履行的职责。倘若在编码实现时能遵循“自治”原则，就不容易设计出贫血对象出来。FP则更强调<strong>函数的分治</strong>，即努力保证函数的纯粹性和原子性，对一个大问题进行充分地分解，分别治理，然后再利用函数的组合性完成职责的履行，即所谓“通过增量组合建立抽象”。</p>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>我最近正在编写的一个需求场景，正好完美地展现了这两种不同范式的设计威力。我要实现的是一个条件表达式树的验证和解析，这棵树的节点分为两种类型：</p>
<ul>
<li>Condition Group</li>
<li>Condition</li>
</ul>
<p>Condition Group作为根节点，可以递归嵌套Condition Group和Condition，如下图所示：</p>
<img src="/oo-and-fp-of-scala/expression.png" class="">

<p>对条件表达式树的验证主要是避免出现非法节点，例如不支持的操作符，不符合要求的条件值，不合理的递归嵌套，空节点等。若验证不通过则需要提供错误信息，并返回给前端400的BadRequest。解析时，必须保证节点是合规的，解析后的结果为满足SQL语法中where条件子句的字符串。</p>
<span id="more"></span>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>针对表达式数的合规性验证，我选择了FP的实现方式。为何做出这样的选择？试剖析整个验证行为，可以分解为如下的验证逻辑：</p>
<ul>
<li>对表达式树的验证<ul>
<li>对当前Condition节点的验证<ul>
<li>对操作符的验证  </li>
<li>对条件值的验证  </li>
</ul>
</li>
<li>对当前Condition Group节点的验证 <ul>
<li>对逻辑操作符的验证  </li>
<li>对子条件Size的验证  </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可以看到，分解出来的处于同一层次的验证逻辑，彼此之间是完全正交的，获得的结果互相不受影响。同时，这些“原子”的验证逻辑又可以组合起来，形成更高粒度的正交的验证，例如对Condition和Condition Group的验证，彼此独立，组合起来却又可以形成对整个表达式树的验证。</p>
<p>考虑函数的side effect，应尽量做到无副作用，这更选择选择FP的方式，且Scala自身提供了<code>Try[T]</code>类型，可以避免在函数中抛出具有副作用的异常。<code>Try[T]</code>是一个Monad，可以支持for comprehension对函数进行组合。</p>
<p>由于验证逻辑彼此正交，对函数的实现就变得非常纯粹而简单，不用考虑太多外在的因素。只要设计好函数的接口，函数可以专心做自己的事情。</p>
<h4 id="对Condition当前节点的验证"><a href="#对Condition当前节点的验证" class="headerlink" title="对Condition当前节点的验证"></a>对Condition当前节点的验证</h4><p>对Condition的验证相对简单，只需要分别针对操作符和条件值进行验证即可。如下是代码实现：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ConditionValidator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">validateCondition</span></span>(condition: <span class="type">Condition</span>): <span class="type">Try</span>[<span class="type">Boolean</span>] = &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      _ &lt;- validateOperator(condition)</span><br><span class="line">      result &lt;- validateValues(condition)</span><br><span class="line">    &#125; <span class="keyword">yield</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">validateOperator</span></span>(condition: <span class="type">Condition</span>): <span class="type">Try</span>[<span class="type">Boolean</span>] = &#123;</span><br><span class="line">    <span class="type">List</span>(<span class="string">&quot;between&quot;</span>, <span class="string">&quot;in&quot;</span>, <span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;=&quot;</span>, <span class="string">&quot;&lt;=&quot;</span>, <span class="string">&quot;&gt;=&quot;</span>, <span class="string">&quot;&lt;&gt;&quot;</span>).contains(condition.operator.toLowerCase) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">true</span> =&gt; <span class="type">Success</span>(<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">false</span> =&gt; <span class="type">Failure</span>(<span class="keyword">new</span> <span class="type">Throwable</span>(<span class="string">s&quot;can&#x27;t support operator <span class="subst">$&#123;condition.operator&#125;</span>&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">validateValues</span></span>(condition: <span class="type">Condition</span>): <span class="type">Try</span>[<span class="type">Boolean</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> error = <span class="keyword">new</span> <span class="type">Throwable</span>(<span class="string">s&quot;invalid values for condition <span class="subst">$&#123;condition&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (condition.values.isEmpty) <span class="keyword">return</span> <span class="type">Failure</span>(error)</span><br><span class="line">    <span class="keyword">if</span> (condition.operator.isBetween &amp;&amp; condition.values.size != <span class="number">2</span>) <span class="keyword">return</span> <span class="type">Failure</span>(error)</span><br><span class="line">    <span class="keyword">if</span> (condition.operator.isCommon &amp;&amp; condition.values.size != <span class="number">1</span>) <span class="keyword">return</span> <span class="type">Failure</span>(error)</span><br><span class="line"></span><br><span class="line">    <span class="type">Success</span>(<span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">StringOperator</span>(<span class="params">operator: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBetween</span></span>: <span class="type">Boolean</span> = operator.toLowerCase == <span class="string">&quot;between&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIn</span></span>: <span class="type">Boolean</span> = operator.toLowerCase == <span class="string">&quot;in&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCommon</span></span>: <span class="type">Boolean</span> = <span class="type">List</span>(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;=&quot;</span>, <span class="string">&quot;&lt;=&quot;</span>, <span class="string">&quot;&gt;=&quot;</span>, <span class="string">&quot;&lt;&gt;&quot;</span>).contains(operator.toLowerCase)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对ConditionGroup当前节点的验证"><a href="#对ConditionGroup当前节点的验证" class="headerlink" title="对ConditionGroup当前节点的验证"></a>对ConditionGroup当前节点的验证</h4><p>这里对ConditionGroup的验证仅仅针对当前节点，不用去考虑ConditionGroup的嵌套，那是对表达式树的验证，属于另一个层次。把这一职责的边界明确界定，代码实现就变得非常的简单：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ConditionGroupValidator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">validateConditionGroup</span></span>(group: <span class="type">ConditionGroup</span>): <span class="type">Try</span>[<span class="type">Boolean</span>] = &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      _ &lt;- validateLogicOperator(group)</span><br><span class="line">      result &lt;- validateConditionSize(group)</span><br><span class="line">    &#125; <span class="keyword">yield</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">validateConditionSize</span></span>(group: <span class="type">ConditionGroup</span>): <span class="type">Try</span>[<span class="type">Boolean</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> error = <span class="keyword">new</span> <span class="type">Throwable</span>(<span class="string">s&quot;invalid condition group for <span class="subst">$&#123;group&#125;</span>&quot;</span>)</span><br><span class="line">    group.logicOperator.toLowerCase <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;not&quot;</span> =&gt; <span class="keyword">if</span> (group.conditions.size == <span class="number">1</span>) <span class="type">Success</span>(<span class="literal">true</span>) <span class="keyword">else</span> <span class="type">Failure</span>(error)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="keyword">if</span> (group.conditions.size &gt;= <span class="number">2</span>) <span class="type">Success</span>(<span class="literal">true</span>) <span class="keyword">else</span> <span class="type">Failure</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">validateLogicOperator</span></span>(group: <span class="type">ConditionGroup</span>): <span class="type">Try</span>[<span class="type">Boolean</span>] = &#123;</span><br><span class="line">    <span class="type">List</span>(<span class="string">&quot;and&quot;</span>, <span class="string">&quot;or&quot;</span>, <span class="string">&quot;not&quot;</span>).contains(group.logicOperator.toLowerCase()) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">true</span> =&gt; <span class="type">Success</span>(<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">false</span> =&gt; <span class="type">Failure</span>(<span class="keyword">new</span> <span class="type">Throwable</span>(<span class="string">s&quot;invalid logic operator <span class="subst">$&#123;group.logicOperator&#125;</span> for ConditionGroup&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对表达式树的验证"><a href="#对表达式树的验证" class="headerlink" title="对表达式树的验证"></a>对表达式树的验证</h4><p>对表达式树的验证相对复杂，因为牵涉到递归，尤其是从性能考虑，需要使用尾递归（tail recursion）。关于尾递归的知识，在我之前的博客《<a href="http://zhangyi.farbox.com/post/designthinking/painting-hand-and-recursion">艾舍尔的画手与尾递归</a>》中已有详细介绍，这里不再赘述。阅读下面的代码实现时，注意尾递归方法<code>recurseValidate()</code>的第二个参数，其实就是关键的accumulator。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CriteriaValidator</span> <span class="keyword">extends</span> <span class="title">ConditionValidator</span> <span class="keyword">with</span> <span class="title">ConditionGroupValidator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">validate</span></span>(group: <span class="type">ConditionGroup</span>): <span class="type">Try</span>[<span class="type">Boolean</span>] = &#123;</span><br><span class="line">    <span class="meta">@tailrec</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recurseValidate</span></span>(expr: <span class="type">List</span>[<span class="type">ConditionExpression</span>], result: <span class="type">Try</span>[<span class="type">Boolean</span>]): <span class="type">Try</span>[<span class="type">Boolean</span>] = &#123;</span><br><span class="line">      <span class="keyword">val</span> ex = <span class="keyword">new</span> <span class="type">Throwable</span>(<span class="string">s&quot;invalid condition group <span class="subst">$&#123;group&#125;</span>&quot;</span>)</span><br><span class="line">      expr <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Failure</span>(ex)</span><br><span class="line">        <span class="keyword">case</span> head::<span class="type">Nil</span> =&gt; result.flatMap(_ =&gt; validateExpression(head))</span><br><span class="line">        <span class="keyword">case</span> head::tail =&gt; recurseValidate(tail, validateExpression(head))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    validateConditionGroup(group).flatMap(_ =&gt; recurseValidate(group.conditions, <span class="type">Success</span>(<span class="literal">true</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">validateExpression</span></span>(expr: <span class="type">ConditionExpression</span>): <span class="type">Try</span>[<span class="type">Boolean</span>] = expr <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> expr: <span class="type">ConditionGroup</span> =&gt; validateConditionGroup(expr)</span><br><span class="line">    <span class="keyword">case</span> expr: <span class="type">Condition</span> =&gt; validateCondition(expr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，在函数<code>validate()</code>中，实际上是验证ConditionGroup当前节点的函数<code>validateConditionGroup()</code>与尾递归方法<code>recurseValidate()</code>的组合。至于<code>validateExpression()</code>函数的引入，不过是为了避免不必要的类型判断和强制类型转换罢了。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>我最初也曾尝试依旧采用FP方式实现解析功能。思索良久，发现要实现起来困难重重。最主要的障碍在于：每个解析行为返回的结果都会影响到别的节点，进而影响整个表达式。例如，为了保证解析后where子句的语法合规，需要考虑为每个节点解析的结果添加小括号。当对整个表达式树进行递归解析时，每次返回的结果无法直接作为accumulator的值。如果在当前递归层添加了小括号，由于该层次下的子节点还未得到解析，就会导致小括号范围有误；如果不添加小括号，就无法界定各个层次逻辑子句的优先级，导致筛选结果不符合预期。换言之，其中的关键在于<strong>每个解析操作并非正交的</strong>，因此无法对函数进行“分治”的拆解。</p>
<p>倘若站在OO的角度去思考，则对条件表达式的解析，实际就是对各个节点的解析。由于解析行为需要的数据是各个节点对象已经具备的，遵循<strong>信息专家模式</strong>，就<strong>应该让节点对象自己来履行职责，这就是所谓的“对象的自治”</strong>。而从抽象层面进行分析，虽然各个节点拥有的数据不同，解析行为的实现也不尽相同，却都是在完成对自身的解析。于是，我们通过<code>ConditionExpression</code>完成对不同节点类型的抽象。此时，Condition Group是表达式树的枝节点，而Condition则是表达式树的叶子节点。如下图所示，不恰好是Composite模式的体现么？</p>
<img src="/oo-and-fp-of-scala/composition.png" class="">

<p>我们首先需要定义<code>ConditionExpression</code>抽象。这里之所以定义为抽象类，而非trait，是为了支持Json解析的多态，与本文无关，这里不再解释。若希望了解，请阅读我的另一篇博客《<a href="https://iamzhangyi.github.io/using-spring-cloud-in-scala-project/">在Scala项目中使用Spring Cloud</a>》：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionExpression</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作为枝节点的<code>ConditionGroup</code>，不仅要解析自身，还要负责解析嵌套的子节点。但是，父节点不用考虑解析子节点内部的实现，它仅仅是在合适的地方发起对子节点的调用就可以了。这才是真正的“自治”，也就是每个对象在理智上都保持对“权力的克制”，仅负责履行属于自己的职责，绝不越权。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionGroup</span>(<span class="params">logicOperator: <span class="type">String</span>, conditions: <span class="type">List</span>[<span class="type">ConditionExpression</span>]</span>) <span class="keyword">extends</span> <span class="title">ConditionExpression</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>: <span class="type">String</span> = &#123;</span><br><span class="line">    logicOperator.toLowerCase <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;not&quot;</span> =&gt; <span class="string">s&quot;(NOT <span class="subst">$&#123;conditions.head.evaluate&#125;</span>)&quot;</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> expr = conditions.map(_.evaluate).reduce((l, r) =&gt; <span class="string">s&quot;<span class="subst">$&#123;l&#125;</span> <span class="subst">$&#123;logicOperator.toUpperCase&#125;</span> <span class="subst">$&#123;r&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="string">s&quot;(<span class="subst">$expr</span>)&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Condition</span>(<span class="params">fieldName: <span class="type">String</span>, operator: <span class="type">String</span>, values: <span class="type">List</span>[<span class="type">String</span>], dataType: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">ConditionExpression</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>: <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handleValue</span></span>(value: <span class="type">String</span>, dataType: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">      dataType.toLowerCase <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;text&quot;</span> =&gt; <span class="string">s&quot;&#x27;<span class="subst">$&#123;value&#125;</span>&#x27;&quot;</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;number&quot;</span> =&gt; value</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> correctValues = values.map(v =&gt; handleValue(v, dataType))</span><br><span class="line">    <span class="keyword">val</span> expr = operator.toLowerCase() <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;between&quot;</span> =&gt; <span class="string">s&quot;BETWEEN <span class="subst">$&#123;correctValues.head&#125;</span> AND <span class="subst">$&#123;correctValues.last&#125;</span>&quot;</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;in&quot;</span> =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> range = correctValues.map(x =&gt; <span class="string">s&quot;<span class="subst">$x</span>&quot;</span>).mkString(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        <span class="string">s&quot;IN (<span class="subst">$&#123;range&#125;</span>)&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="string">s&quot;<span class="subst">$&#123;operator.toUpperCase&#125;</span> <span class="subst">$&#123;correctValues.head&#125;</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">s&quot;(<span class="subst">$&#123;fieldName&#125;</span> <span class="subst">$&#123;expr&#125;</span>)&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合验证与解析"><a href="#组合验证与解析" class="headerlink" title="组合验证与解析"></a>组合验证与解析</h3><p>若采用自顶向下的设计方法来看待整个功能，则表达式树的验证与解析属于两个不同的职责，遵循“单一职责原则”，我们应该将其分离。在进行验证时，无需考虑解析的逻辑；在开始解析表达式树时，也无需负担验证合法性的包袱。分则简易，合则纠缠不清。只有进行了合理地“分治”后然后再组合，景色就大不相同了：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">CriteriaParser</span> <span class="keyword">extends</span> <span class="title">CriteriaValidator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(group: <span class="type">ConditionGroup</span>): <span class="type">Try</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    validate(group).map(_ =&gt; group.evaluate)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>就我个人而言，我认为OO与FP并不是势如水火的天敌，也无需发出“既生瑜何生亮”的慨叹，非得比出胜负。本文的例子当然仅仅是冰山一角地体现了OO与FP各自的优势。善于面向对象思维的，不能抱残守缺，闭关自守。函数式思维的大潮挡不住，也不必视其为洪水猛兽，反而应该主动去拥抱。精通函数式编程的，也不必过于炫技，夸大函数式思维的重要性，就好似要“一统江湖”似的。</p>
<p>无论面向对象还是函数思维，用对了才是对的。谁也不是江湖永恒的霸主，青山依旧在，几度夕阳红！</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Scala</tag>
        <tag>FP</tag>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动设计概览</title>
    <url>/overview-of-ddd/</url>
    <content><![CDATA[<h2 id="领域驱动设计概览"><a href="#领域驱动设计概览" class="headerlink" title="领域驱动设计概览"></a>领域驱动设计概览</h2><p>领域驱动设计（Domain Driven Design，DDD）是由Eric Evans最早提出的综合软件系统分析和设计的面向对象建模方法，如今已经发展为一种针对大型复杂系统的领域建模与分析方法。它完全改变了传统软件开发工程师针对数据库进行的建模方法，从而<strong>将要解决的业务概念和业务规则转换为软件系统中的类型以及类型的属性与行为，通过合理运用面向对象的封装、继承、多态等设计要素</strong>，降低或隐藏整个系统的业务复杂性，并使得系统具有更好的扩展性，应对纷繁多变的现实业务问题。</p>
<span id="more"></span>

<h3 id="领域驱动设计的开放性"><a href="#领域驱动设计的开放性" class="headerlink" title="领域驱动设计的开放性"></a>领域驱动设计的开放性</h3><p>领域驱动设计是一种方法论（Methodology）。根据维基百科的定义，方法论是一套运用到某个研究领域的系统与理论分析方法。领域驱动设计就是针对软件开发领域提出的一套系统与理论分析方法。Eric Evans在创造性地提出领域驱动设计时，实则是针对当时项目中聚焦在以数据以及数据样式为核心的系统建模方法的批判。面向数据的建模方法是关系数据库理论的延续，关注的是数据表以及数据表之间关系的设计。这是典型的面向技术实现的建模方法，面对日渐复杂的业务逻辑，这种设计方法欠缺灵活性与可扩展性，也无法更好地利用面向对象设计思想以及设计模式，建立可重用的、可扩展的代码单元。领域驱动设计的提出，是<strong>设计观念的转变，蕴含了全新的设计思想、设计原则与设计过程</strong>。</p>
<p>由于领域驱动设计是一套方法论，它建立了<strong>以领域为核心驱动力</strong>的设计体系，因而具有一定的开放性。在这个体系中，你可以使用不限于领域驱动设计提出的任何一种方法来解决这些问题。例如，我们可以使用用例（Use Case）、测试驱动开发（TDD）、用户故事（User Story）帮助我们对领域建立模型；我们可以引入整洁架构思想以及六边形架构，以帮助我们建立一个层次分明、结构清晰的系统架构；我们可以引入函数式编程思想，利用纯函数与抽象代数结构的不变性以及函数的组合性来表达领域模型。这些实践方法与模型已经超越了Eric Evans最初提出的领域驱动设计范畴，但在体系上却是一脉相承的。这也是为什么在领域驱动设计社区，能够不断诞生诸如CQRS模式、事件溯源（Event Sourcing）模式与事件风暴（Event Storming）等新概念的原因；领域驱动设计也以开放的心态拥抱微服务（Micro Service），甚至能够将它的设计思想与原则运用到微服务架构设计中。</p>
<h3 id="领域驱动设计过程"><a href="#领域驱动设计过程" class="headerlink" title="领域驱动设计过程"></a>领域驱动设计过程</h3><p>领域驱动设计当然不是架构方法，也并非设计模式。准确地说，它其实是“一种思维方式，也是一组优先任务，它旨在加速那些必须处理复杂领域的软件项目的开发”。领域驱动设计贯穿了整个软件开发的生命周期，包括对需求的分析，建模，架构，设计，甚至最终的编码实现，乃至对编码的测试与重构。</p>
<p>领域驱动设计强调领域模型的重要性，并通过模型驱动设计来保障领域模型与程序设计的一致。从业务需求中提炼出统一语言（Ubiquitous Language），再基于统一语言建立领域模型；这个领域模型会指导着程序设计以及编码实现；最后，又通过重构来发现隐式概念，并运用设计模式改进设计与开发质量。这个过程如下图所示：</p>
<img src="/overview-of-ddd/01-01.png" class="">

<p>这个过程是一个覆盖软件全生命周期的设计闭环，每个环节的输出都可以作为下一个环节的输入，而在其中扮演重要指导作用的则是“领域模型”。这个设计闭环是一个螺旋上升的迭代设计过程，领域模型会在这个迭代过程中逐渐演进，在保证模型完整性与正确性的同时，具有新鲜的活力，使得领域模型能够始终如一的贯穿领域驱动设计过程，阐释着领域逻辑，指导着程序设计，验证着编码质量。</p>
<p>如果仔细审视这个设计闭环，我们发现在针对问题域和业务期望提炼统一语言，并通过统一语言进行领域建模时，可能会面临高复杂度的挑战。这是因为对于一个复杂的软件系统而言，我们要处理的问题域实在太庞大了。在为问题域寻求解决方案时，需要从宏观层次划分不同业务关注点的子领域，然后再深入到子领域中从微观层次对领域进行建模。宏观层次是战略的层面，微观层次是战术的层面，只有将战略设计与战术设计结合起来，才是完整的领域驱动设计。</p>
<h4 id="战略设计阶段"><a href="#战略设计阶段" class="headerlink" title="战略设计阶段"></a>战略设计阶段</h4><p>领域驱动设计的战略设计阶段是从两个方面来考量的：</p>
<ul>
<li>问题域方面：针对问题域，引入<strong>限界上下文（Bounded Context）</strong>和<strong>上下文映射（Context Map）</strong>对问题域进行合理的分解，识别出<strong>核心领域（Core Domain）</strong>与<strong>子领域（SubDomain）</strong>，并确定领域的边界以及它们之间的关系，维持模型的完整性。</li>
<li>架构方面：通过<strong>分层架构</strong>来隔离关注点，尤其是将领域实现独立出来，可以更利于领域模型的单一性与稳定性；引入<strong>六边形架构</strong>清晰地表达领域与技术基础设施的边界；CQRS模式则分离了查询场景和命令场景，针对不同场景选择使用同步或异步操作，提高架构的低延迟性与高并发能力。</li>
</ul>
<p>Eric Evans提出战略设计的初衷是要<strong>保持模型的完整性</strong>。限界上下文的边界可以保护上下文内部和其他上下文之间的领域概念互不冲突。然而，如果我们将领域驱动设计的战略设计模式引入到架构过程中，就会发现限界上下文不仅限于对领域模型的控制，而在于分离关注点之后，使得整个上下文可以成为独立部署的设计单元，这就是“微服务”的概念，上下文映射的诸多模式则对应了微服务之间的协作。因此在战略设计阶段，微服务扩展了领域驱动设计的内容，反过来领域驱动设计又能够保证良好的微服务设计。</p>
<p>一旦确立了限界上下文的边界，尤其是作为物理边界，则分层架构就不再针对整个软件系统，而仅仅针对粒度更小的限界上下文。此时，限界上下文定义了技术实现的边界，对当前上下文的领域与技术实现进行了封装，我们只需要关心对外暴露的接口与集成方式，形成了在服务层次的设计单元重用。</p>
<p>边界给了实现限界上下文内部的最大自由度。这也是战略设计在<strong>分治</strong>上起到的效用。我们可以在不同的限界上下文选择不同的架构模式，例如针对订单的查询与处理，选择CQRS模式来分别处理同步与异步场景；还可以针对核心领域与子领域重要性的不同，分别选择领域模型（Domain Model）和事务脚本（Transaction Script）模式，灵活地平衡开发成本与开发质量。在宏观层面，面对整个软件系统，我们可以采用前后端分离与基于REST的微服务架构，保证系统具有一致的架构风格。</p>
<h4 id="战术设计阶段"><a href="#战术设计阶段" class="headerlink" title="战术设计阶段"></a>战术设计阶段</h4><p>整个软件系统被分解为多个限界上下文（或领域）后，我们就可以分而治之，对每个限界上下文进行战术设计。领域驱动设计并不牵涉到技术层面的实现细节，在战术层面，它主要应对的是领域的复杂性。领域驱动设计用以表示模型的主要要素包括：</p>
<ul>
<li>值对象（Value Object）</li>
<li>实体（Entity）</li>
<li>领域服务（Domain Service）</li>
<li>领域事件（Domain Event）</li>
<li>资源库（Repository）</li>
<li>工厂（Factory）</li>
<li>聚合（Aggregate）</li>
<li>应用服务（Application Service）</li>
</ul>
<p>Eric Evans通过下图勾勒了战术设计诸要素之间的关系：</p>
<img src="/overview-of-ddd/01-02.png" class="">

<p>领域驱动设计围绕着领域模型进行设计，通过<strong>分层架构（Layered Architecture）</strong>将领域独立出来。表示领域模型的对象包括：<strong>实体</strong>、<strong>值对象</strong>和<strong>领域服务</strong>。<strong>领域逻辑都应该封装在这些对象中</strong>。这一严格的设计原则可以避免业务逻辑渗透到领域层之外，导致技术实现与业务逻辑的混淆。在领域驱动设计的演进中，又引入了<strong>领域事件</strong>来丰富领域模型。</p>
<p><strong>聚合</strong>是一种边界，它可以封装一到多个<strong>实体</strong>与<strong>值对象</strong>，并维持该边界范围之内的业务完整性。在聚合中，至少包含一个实体，且只有实体才能作为<strong>聚合根（Aggregate Root）</strong>。注意，在领域驱动设计中，没有任何一个类是单独的聚合，因为聚合代表的是边界概念，而非领域概念。极端情况下，一个聚合可能有且只有一个实体。</p>
<p><strong>工厂</strong>和<strong>资源库</strong>都是对领域对象生命周期的管理。前者负责领域对象的创建，往往用于封装复杂或者可能变化的创建逻辑。后者则负责从存放资源的位置（数据库、内存或者其他Web资源）获取、添加、删除或者修改领域对象。领域模型中的资源库不应该暴露访问领域对象的技术实现细节。</p>
<h4 id="演进的领域驱动设计过程"><a href="#演进的领域驱动设计过程" class="headerlink" title="演进的领域驱动设计过程"></a>演进的领域驱动设计过程</h4><p>战略设计会控制和分解战术设计的边界与粒度，战术设计则以实证角度验证领域模型的有效性、完整性与一致性，进而以演进的方式对之前的战略设计阶段进行迭代，从而形成一种螺旋式上升的迭代设计过程，如下图所示：</p>
<img src="/overview-of-ddd/01-03.png" class="">

<p>面对客户的业务需求，由领域专家与开发团队展开充分的交流，经过需求分析与知识提炼，获得清晰的问题域。通过对问题域进行分析和建模，识别限界上下文，利用它划分相对独立的领域，再通过上下文映射建立它们之间的关系，辅以分层架构与六边形架构划分系统的逻辑边界与物理边界，界定领域与技术之间的界限。之后，进入战术设计阶段，深入到限界上下文内对领域进行建模，并以领域模型指导程序设计与编码实现。若在实现过程中，发现领域模型存在重复、错位或缺失时，再进而对已有模型进行重构，甚至重新划分限界上下文。</p>
<p>两个不同阶段的设计目标是保持一致的，它们是一个连贯的过程，彼此之间又相互指导与规范，并最终保证<strong>一个有效的领域模型和一个富有表达力的实现同时演进</strong>。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Architecture</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache Apex的Operators</title>
    <url>/operators-of-apache-apex/</url>
    <content><![CDATA[<p>Operator是Apache Apex平台进行数据处理的最基本构建模块。Apex将要处理的数据抽象为tuple，而tuple就是流动在operator之间。Apex的operator可以通过由DAG（Directed Acyclic Graph，有向无环图）组成的Stream进行连接。因此，在Apex架构体系与数据流模型中，一个典型的Apex流应用是由DAG来呈现的，而DAG又包括了数据流（称之为streams）与操作（称之为operators）。</p>
<h3 id="什么是Operator"><a href="#什么是Operator" class="headerlink" title="什么是Operator"></a>什么是Operator</h3><p>Operator是独立的逻辑操作单元，可用于执行用例的业务逻辑。例如在ETL流程中，对数据的过滤就可以视为一个单独的operator。在Apex中，Operator的粒度并没有限制，你可以编写一个operator来完成整个业务逻辑，但为了更好地利用Apache Apex提供的分布式框架，通常还是建议将Operator定义为一个轻量级的独立任务（task）。Apex的API允许用户将任务拆分为不同的阶段（stage），这样就能使得所有的任务可以并行地执行在不同的tuple之上。</p>
<span id="more"></span>

<h3 id="Operator的类型"><a href="#Operator的类型" class="headerlink" title="Operator的类型"></a>Operator的类型</h3><p>在同一时间，一个operator只能工作在一个tuple上。tuple可以是其他operator提供，也可以是诸如数据库或消息队列之类的外部数据源。被处理的tuple又可以传递给另外的operator，或者存储到外部系统中。因此，基于功能可以将operator分为三种类型：</p>
<ul>
<li>Input Adapter：是应用DAG的起点，用于从外部系统获取tuple。还有一种情况是无需与外部系统打交道，数据可以由operator自身生成。</li>
<li>Generic Operator：这种类型的operator会接收前置operator输入的tuple，对其进行处理后，将处理结果传递给DAG中的后续operator。</li>
<li>OutputAdapter：是应用DAG的终点，用于将数据写入到某些外部系统。</li>
</ul>
<h3 id="Operator在DAG中的位置"><a href="#Operator在DAG中的位置" class="headerlink" title="Operator在DAG中的位置"></a>Operator在DAG中的位置</h3><p>根据operator在DAG中的位置，我们以任何一个operator作为参考点（如下图的opr），那么针对所有与opr之间存在直接相关路径的operator，在opr之前的都可以称之为是上游operator，之后的则称之为下游operator。</p>
<img src="/operators-of-apache-apex/dag.png" class="">

<p><strong>注意：</strong>在DAG中没有环状关系。</p>
<h3 id="Ports"><a href="#Ports" class="headerlink" title="Ports"></a>Ports</h3><p>在DAG中，operator通过streams进行连接。一个stream连接operator的端点则被称之为port。port有两种类型：</p>
<ul>
<li>Input Port：operator通过input port接收上游operator传递过来的tuple</li>
<li>Output Port：operator通过output port将数据传递给下游operator</li>
</ul>
<p>显然，Input Adapter这种operator将只有output port而没有input port，Generic Operator既有input也有output port，而Output Adapter则只有input port而没有output port，如下图所示：</p>
<img src="/operators-of-apache-apex/ports.png" class="">

<h3 id="Operator如何工作"><a href="#Operator如何工作" class="headerlink" title="Operator如何工作"></a>Operator如何工作</h3><p>每个operator都有自己的生命周期，并被分为多个stage。Stage以API的形式被Streaming Application Master调用。下图展示了Input Adapter、Generic Operator与Output Adapter的生命周期以及各阶段对应的方法：</p>
<img src="/operators-of-apache-apex/lifecycle.png" class="">

<p>各个方法的说明如下：</p>
<ul>
<li><code>setup()</code>方法：初始化operator，并为其准备待处理的tuple</li>
<li><code>beginWindow()</code>方法：应用窗口（application window）的开启，方法中的实现都会在窗口启动之前被执行完成</li>
<li><code>process()</code>方法：该方法属于InputPort，在tuple到达operator的input port时被触发。由于Input Adapter并没有input port，因此该方法只提供给Generic Operator与Output Adapter</li>
<li><code>emitTuples()</code>方法：与<code>process()</code>相反，它只提供给Input Adapter，用于将从外部系统（或上游operator）获取到的tuple发射出去。该方法会被持续不断地被调用，直到预先配置的窗口时间达到才会停止</li>
<li><code>endWindow()</code>方法：标记窗口结束，方法中的实现都会在窗口结束之后被执行</li>
<li><code>teardown()</code>方法：用于友好地关闭operator，释放被operator占用的资源</li>
</ul>
<h3 id="文件IO流处理的案例"><a href="#文件IO流处理的案例" class="headerlink" title="文件IO流处理的案例"></a>文件IO流处理的案例</h3><p>假设要通过Apex以流处理的形式读取文件，并创建一个stream将读取到的文件内容写入到另一个文件，同时创建另一个stream将读取到的文件内容在控制台显示出来。则整个DAG如下图所示：</p>
<img src="/operators-of-apache-apex/fileio.png" class="">

<p>Apex为文件IO流处理提供了AbstractFileInputOperator与AbstractFileOutputOperator两个抽象类，我们只需定义自己的类，并分别派生这两个类，就可以作为文件读写的input adapter与output adapter。</p>
<p>在FileReader这个input adapter中，分别定义了output与control两个output port，作为tuple的出口，将数据传入到各自的stream中；而在FileWriter中，则定义了input与control这两个input port，用以将stream中的tuple传递给它自己。如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApplicationAnnotation(name=&quot;FileIO&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">StreamingApplication</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateDAG</span><span class="params">(DAG dag, Configuration conf)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    FileReader reader = dag.addOperator(<span class="string">&quot;read&quot;</span>,  FileReader.class);</span><br><span class="line">    FileWriter writer = dag.addOperator(<span class="string">&quot;write&quot;</span>, FileWriter.class);</span><br><span class="line"></span><br><span class="line">    dag.addStream(<span class="string">&quot;data&quot;</span>, reader.output, writer.input);</span><br><span class="line">    dag.addStream(<span class="string">&quot;ctrl&quot;</span>, reader.control, writer.control);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Application中，Apex还允许我们对Port设置属性。例如希望在writer operator中对读取过来的数据进行并行的分区处理，则可以设置为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dag.setInputPortAttribute(writer.input, PARTITION_PARALLEL, <span class="keyword">true</span>);</span><br><span class="line">dag.setInputPortAttribute(writer.control, PARTITION_PARALLEL, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>Operator是支撑Apache Apex进行流数据处理的重要组成部分。当我们使用Apex这个流处理平台时，主要的开发工作其实都是与Operator打交道。为了支持开发者能够更专注于自己的应用场景，Apex业已定义了大量常用的Operator，例如对TCP、HDFS、JDBC、JMS、各种文件、NoSQL等的支持。同时，它又提供了非常灵活的自定义operator支持。例如，它为其定义了Operator接口与提供了基本实现的BaseOperator类。它还定义了诸如AbstractFileInputOperator之类的与具体场景有关的大量抽象类模板，极大地减少了自定义operator的编码量。</p>
<p>Apex的架构核心是DAG，由Operator、Stream与Port三者组成。DAG既满足了高效地流处理需求，又非常形象地以图形建模形式帮助我们梳理处理流数据的业务逻辑和处理流程，降低了数据流建模的难度。</p>
<p><strong>说明：</strong>本文内容主要来自Apache Apex官方文档。</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Streaming</tag>
        <tag>Big Data</tag>
        <tag>Apex</tag>
      </tags>
  </entry>
  <entry>
    <title>《架构之美》评注版序</title>
    <url>/preface-of-beautiful-architecture/</url>
    <content><![CDATA[<img src="/preface-of-beautiful-architecture/beautiful-arch.jpg" class="">

<p>软件架构终归属于工程学的范畴，不能一概以“只可意会不可言传”来搪塞，因为架构知识是可以传递的，架构文档是可以共享的，最重要的是，架构自身是可以评审、验证与实现的。</p>
<span id="more"></span>

<p>Stephen J. Mellor在Beautiful Architecture序中，画龙点睛地勾勒出美丽架构的模样，即必须遵循的一些普遍原则，分别为：</p>
<ul>
<li>One fact In one place（一处一事实）</li>
<li>Automatic propagation（自动传播）</li>
<li>Architecture includes construction（架构包含构建）</li>
<li>Minimize mechanisms（最小化机制）</li>
<li>Constuct engines（构建引擎）</li>
<li>O(G), the order of growth（O(G)，增长的阶）</li>
<li>Resist entropy（抵制熵）</li>
</ul>
<p>这些原则，其实就是架构师的智慧，没有足够深刻的理解与深入实践，是不可能给出如此言简意赅的架构建议的。按照我的理解，这些普适性原则其实就是在说明所谓美丽的架构，就是简单、一致、适应变化并能去除重复的架构。泄露天机的一句话还是Mellor所言——美丽的架构用更少的机制做更多的工作。这就是Beautiful Architecture一书不凡的开篇了。</p>
<p>若是一本平庸的书，必然会惧怕这样精彩绝伦的序，因为它愈发的美，就愈发能照映出正文的丑；它愈发的言之有物，又愈发会衬托出正文的空洞无味。 然而，若是内容是超乎寻常的精彩绝伦，这样的序就无异于锦上添花，珠联璧合了。通透点儿，就是齐活！这就好比一首歌曲的领唱者，倘若一开始就飙出高音，声入云霄。跟唱者没有点儿本事，恐怕就难以为继了；可要都是高手呢？那就真是一场音乐的盛宴了。</p>
<p>Beautiful Architecture合唱团荟萃了全球最为顶级的架构师、意见领袖，他们在这本书中唱出了架构思想、实践与原则的最强音。全书共分为五个主题：</p>
<ul>
<li>On Architeture</li>
<li>Enterprise Application Architecture</li>
<li>Systems Architecture</li>
<li>End-User Application Architectures</li>
<li>Languages and Architecture</li>
</ul>
<p>这些主题几乎覆盖了软件架构的方方面面，精选的每篇文章可谓字字珠玑，充满了写作者的真知灼见。开卷阅读，如与大师对话，聆听者必须凝神应对，稍不留神就可能遗漏那些重要而正确的意见，影响到对整篇文章的理解。整本书正文不足400页，然而每次阅读皆有新意，书的内容仿佛博尔赫斯笔下小径分叉的花园，花园虽小，景色却变幻多姿，路途虽短，距离却无穷无尽，咫尺天涯。</p>
<p>因此，作为本书的评注者，真可以说是战战兢兢如履薄冰。我的每句点评都尽力追求达到个人最大努力的完美，不求锦上添花，只求不得“狗尾续貂”之嫌。安全地说，这些评注不过是我写在架构这本大书边上的感悟罢了。这些感悟，或是阅读到精彩段落的击节赞叹，或是不明其义而反复研读之后的醍醐灌顶，或是触类旁通体会到架构本质因而不揣冒昧地给出自己的心得体会。在评注过程中，我恪守“扬长避短”的原则，不懂就不装懂，默不作声，当一位沉默的看客；一旦涉猎到自己擅长的部分，却也不妨洋洋洒洒高谈阔论，坦承自己的观点。</p>
<p>对于这些架构领袖们，我怀揣敬意，却也不愿以一种卑微的心态被动接受。我需要做一个具有自己人格和高度的评注者。至于对否，就将给读者诸君对评注再做一次“评注”吧！</p>
<h3 id="行业专家推荐"><a href="#行业专家推荐" class="headerlink" title="行业专家推荐"></a>行业专家推荐</h3><p>《架构之美(评注版)》在架构之美原稿的基础上增加了一些精彩评注。这些评注，或阐述概念、或展开话题、或补充观点、或独创见解。评注内容涉及到架构风格、技术选型、设计模式、语言特性、数据分析工具、实时数据处理工具、研发过程、组织等等，张逸老师渊博的知识和大量软件工程实践的架构经验使我获益良多。架构之美一书数年前读过，评注版仍令我心向往之。读良书悟新知，评注观点亦如老友在品茗座谈间娓娓道来，又时有震耳发聩之声。    ——<strong>蚂蚁金服高级技术专家  右军</strong></p>
<p>程序的健壮、优雅、灵活和易维护，是我们每个研发人员追求的目标。评注者结合自己的实践经验，对架构之美的深刻领悟全部体现在了评注文本中。   ——<strong>京东商城 POP京麦平台 架构师 王新栋</strong></p>
<p>与张逸相识同事多年，常称之为软件开发领域的文艺青年。《架构之美》由张逸来评注可为相得益彰，原书从我们日常繁琐的架构工作中抽象出了一系列优雅的原则，而真正的理解又需要张逸这样的传道者来为我们娓娓道来。评注让我又重拾了一次这本名著，还要感谢张逸通过这样的努力分享了自己多年的架构心得。——<strong>ThoughtWorks咨询总监 精益敏捷专家 肖然</strong></p>
<hr>
<p>目前，《架构之美》评注版在京东有售，欲购买者请移步<a href="https://item.jd.com/29870821428.html?jd_pop=c844cd8d-8acc-436d-98c1-55d6ecfecf3c&abt=0">这里</a>。</p>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>Writing</tag>
        <tag>Architecture</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动设计，重焕青春的设计经典</title>
    <url>/preface-of-practice-ddd/</url>
    <content><![CDATA[<p>领域驱动设计确实已不再青春，从Eric Evans出版那本划时代的著作《领域驱动设计》至今，已有差不多十五年时间。在软件设计领域，似乎可以称得上是步入老年了。可惜的是，对于这样一个在国外IT圈享有盛誉并行之有效的设计方法学，国内多数的技术人员却并不了解，也未曾运用到项目实践中，真可以说是知音稀少。领域驱动设计似乎成了一门悄悄发展的隐学，它从来不曾大行其道，却依旧顽强地发挥着出人意料的价值。</p>
<p>直到——直到行业内吹起微服务的热风，人们似乎才重新发现了领域驱动设计的价值。并不是微服务拯救了领域驱动设计，因为领域驱动设计一直在坚硬的生长，然而看起来，确乎因为微服务，领域驱动设计才又焕发了青春。</p>
<span id="more"></span>

<p>我从2006年开始接触领域驱动设计，一开始我就发现了她的魅力并沉迷其间。从阅读Eric Evans的《领域驱动设计》入门，然后尝试在软件项目中运用它，也取得了一定成效。然而，我的学习与运用一直处于摸索之中，始终感觉不得其门而入。直到我有机会拜读Vaughn Vernon的《实现领域驱动设计》，并负责该书的审校工作，我才触摸到了领域驱动从战略设计到战术设计的整体脉络，并了解其本质：<strong>领域驱动设计是一个开放的设计方法体系</strong>。</p>
<p>即使如此，许多困惑与谜题仍然等待我去发现线索和答案。设计总是如此，虽然前人已经总结了许多原则与方法，却不能像数学计算那样，按照公式与公理进行推导就一定能得到准确无误的结果。设计没有唯一的真相。</p>
<p>即使如此，如果我们能够走在迈向唯一真相的正确道路上，那么每前进一步，就会离这个理想的唯一真相更近一步。这正是我推出这门课的初衷。我并不是说我贴近了唯一真相，也不是说我已经走在正确道路上，但我可以自信地说，对于领域驱动设计，我走在了大多数开发人员的前面，我在发现了更多新奇风景的同时，亦走过太多荒芜的分岔小径，经历过太多坎坷与陷阱。我尝试着解答领域驱动设计的诸多谜题，期望能从我的思考与实践中发现正确道路的蛛丝马迹。我的这门课程正是我跌跌撞撞走过一路的风景拍摄与路径引导。就好似你要去银河系旅游，最好能有一本《银河系漫游指南》在手，不至于迷失在浩瀚的星空之中。我期待这门课程能给你这样的指导。</p>
<h3 id="课程框架"><a href="#课程框架" class="headerlink" title="课程框架"></a>课程框架</h3><p>本课程是我计划撰写的领域驱动设计实践系列的<strong>第一部分</strong>，全面覆盖了领域建模分析与架构设计的战略设计过程，从剖析软件复杂度的根源开始，引入了领域场景分析与敏捷项目实践，帮助需求分析人员与软件设计人员分析软件系统的问题域，提炼真实表达的领域知识，最终建立系统的统一语言。同时，本课程将主流架构设计思想、微服务架构设计原则与领域驱动设计中属于战略设计层面的限界上下文、上下文映射、分层架构结合起来，完成从需求到架构设计再到构建代码模型的架构全过程。</p>
<p>本课程分为五部分，共计33篇：</p>
<p>第一部分：软件复杂度</p>
<ul>
<li>领域驱动设计的目的是应对软件复杂度。本部分内容以简练的笔触勾勒了领域驱动设计的全貌，然后深入剖析了软件复杂度的本质，总结了控制软件复杂度的原则，最终给出了领域驱动设计应对软件复杂度的基本思想与方法。</li>
</ul>
<p>第二部分：领域知识</p>
<ul>
<li>领域驱动设计的核心是“领域”，也是进行软件设计的根本驱动力。因此，团队在进行领域驱动设计时，尤其需要重视团队内外成员之间的协作与沟通。本部分内容引入了敏捷开发思想中的诸多实践，并以领域场景分析为主线讲解了如何提炼领域知识的方法。</li>
</ul>
<p>第三部分：限界上下文</p>
<ul>
<li>限界上下文是领域驱动设计最重要的设计要素，我们需要充分理解限界上下文的本质与价值，突出限界上下文对业务、团队与技术的“控制”能力。</li>
<li>提出了从业务边界、工作边界到应用边界分阶段分步骤迭代地识别限界上下文的过程方法，使得领域驱动设计的新手能够有一个可以遵循的过程来帮助识别限界上下文。</li>
<li>剖析上下文映射，确定限界上下文之间的协作关系，进一步帮助我们合理地设计限界上下文。</li>
</ul>
<p>第四部分：架构与代码模型</p>
<ul>
<li>作为一个开放的设计方法体系，本部分引入了分层架构、整洁架构、六边形架构与微服务架构等模式，全面剖析了领域驱动设计的架构思想与原则。</li>
<li>结合限界上下文，并针对限界上下文的不同定义，对领域驱动的架构设计进行了深度探索，给出了满足整洁架构思想的代码模型。</li>
</ul>
<p>第五部分：EAS系统的战略设计实践</p>
<ul>
<li>给出一个全真案例——EAS系统，运用各篇介绍的设计原则、模式与方法对该系统进行全方位的战略设计，并给出最终的设计方案。</li>
</ul>
<p>本课程并非对Eric Evans《领域驱动设计》的萧规曹随，而是吸纳了领域驱动设计社区各位专家大师提出的先进知识，并结合我多年来运用领域驱动设计收获的项目经验，同时还总结了自己在领域驱动设计咨询与培训中对各种困惑与问题的思考与解答。课程内容既遵循了领域驱动设计的根本思想，又有自己的独到见解；既给出了权威的领域驱动知识阐释，又解答了在实践领域驱动设计中最让人困惑的问题。</p>
<h3 id="为什么要学习领域驱动设计"><a href="#为什么要学习领域驱动设计" class="headerlink" title="为什么要学习领域驱动设计"></a>为什么要学习领域驱动设计</h3><p>如果你已经能设计出美丽优良的软件架构，如果你只希望脚踏实地做一名高效编码的程序员，如果你是一位注重用户体验的前端设计人员，如果你负责的软件系统并不复杂，那么，你确实不需要学习领域驱动设计！</p>
<p>领域驱动设计当然并非“银弹”，自然也不是解决所有疑难杂症的“灵丹妙药”，请事先降低对领域驱动设计的不合现实的期望。我以中肯地态度总结了领域驱动设计可能会给你带来的收获：</p>
<ul>
<li>领域驱动设计是一套完整而系统的设计方法，它能给你从战略设计到战术设计的规范过程，使得你的设计思路能够更加清晰，设计过程更加规范。</li>
<li>领域驱动设计尤其善于处理与领域相关的高复杂度业务的产品研发，通过它可以为你的产品建立一个核心而稳定的领域模型内核，有利于领域知识的传递与传承。</li>
<li>领域驱动设计强调团队与领域专家的合作，能够帮助团队建立一个沟通良好的团队组织，构建一致的架构体系。</li>
<li>领域驱动设计强调对架构与模型的精心打磨，尤其善于处理系统架构的演进设计。</li>
<li>领域驱动设计的思想、原则与模式有助于提高团队成员的面向对象设计能力与架构设计能力。</li>
<li>领域驱动设计与微服务架构天生匹配，无论是在新项目中设计微服务架构，还是将系统从单体架构演进到微服务设计，都可以遵循领域驱动设计的架构原则。</li>
</ul>
<h3 id="课程寄语"><a href="#课程寄语" class="headerlink" title="课程寄语"></a>课程寄语</h3><p>没有谁能够做到领域驱动设计的一蹴而就，一门课程也不可能穷尽领域驱动设计的方方面面。从知识的学习到知识的掌握，进而达到能力的提升，需要一个漫长的过程。所谓“理论联系实际”虽然是一句大家耳熟能详的老话，但其中蕴含了颠扑不破的真理。我在进行领域驱动设计培训时，总会有学员希望我能给出数学公式般的设计准则或规范，似乎软件设计就像拼积木一般，只要遵照图示中给出的拼搭过程，不经思考就能拼出期待的模型。——这是不切实际的幻想。</p>
<p>要掌握领域驱动设计，就不要被它给出的概念所迷惑，而要去思索这些概念背后蕴含的原理，多问一些为什么。同时，要学会运用设计原则去解决问题，而非所谓的“设计规范”。例如：</p>
<ul>
<li>思考限界上下文边界的划分，实际上还是“高内聚低耦合”原则的体现，只是我们需要考虑什么内容才是高内聚的，如何抽象才能做到低耦合？</li>
<li>是否需要提取单独的限界上下文？是为了考虑职责的重用，还是为了它能够独立进化以应对未来的变化？</li>
<li>在分层架构中，各层之间该如何协作？如果出现了依赖，该如何解耦？仍然需要从重用与变化的角度去思考设计决策。</li>
<li>为什么同样遵循领域驱动设计，不同的系统会设计出不同的架构？这是因为不同的场景对架构质量的要求并不一样，我们要学会对架构的关注点做优先级排列，从而得出不同的架构决策。</li>
</ul>
<p>我强烈建议读者诸君要<strong>学会对设计的本质思考，不要只限于对设计概念的掌握，而要追求对设计原则与方法的融汇贯通</strong>。只有如此，才能针对不同的业务场景灵活地运用领域驱动设计，而非像一个牵线木偶般遵照着僵硬的过程进行死板地设计。</p>
<p><strong>广而告知：</strong>我在<a href="https://gitbook.cn/gitchat/column/5b3235082ab5224deb750e02">GitChat的领域驱动战略设计实践达人课</a>已经发布。打开链接即可查看与订阅。同时，我还将在我的个人公众号上做抽奖活动，对于积极评论者会有本次课程的免费码赠送，敬请期待！本文内容为GitChat达人课开篇词。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Writing</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>《解构领域驱动设计》终于可以预购了</title>
    <url>/presale-of-DDDE/</url>
    <content><![CDATA[<img src="/presale-of-DDDE/cover-small.jpg" class="">

<p>四年了，《解构领域驱动设计》<strong>终于</strong>可以在异步社区的<a href="https://www.epubit.com/bookDetails?id=UB77d68d84212a6&typeName=%E6%90%9C%E7%B4%A2">官方网站上预购</a>了！这意味着，我的著作<strong>终于</strong>出版了！有没有普天同庆的赶脚？总之，当我收到这一消息后，长长地吁了一口气……终于，终于，四年了，真不容易啊！</p>
<p>许多次，我在给别人介绍这本著作时，总有人问我哪里可以买到，而我则尴尬地回答：嗯，这个，这个，还没有出版呢。许多次，读者圈的朋友在问这本书多久出版时，我从2020年承诺年底出版，然后推迟到4月，然后推迟到6月，最后推迟到7月，进度的delay已经让人产生抱怨了！而在许多年前，我总是说我的第一本书《<a href="https://book.douban.com/subject/2058073/">软件设计精要与模式</a>》，言外之意，我还有第二本书，可是自从2007年出版我的第一本书，到2009年出版<a href="http://product.china-pub.com/196623">该书的第二版</a>之后，我的第二本书终于在14年后诞生了。</p>
<p>一些信息可以侧面证明本书写作的不容易。</p>
<span id="more"></span>

<p>本书内容首先诞生于我在GitChat上发布的<a href="https://gitchat.csdn.net/column/5cdab7fb34b6ed1398fd8de7">领域驱动设计课程</a>，该课程分为《战略篇》与《战术篇》，战略篇一共34章，15.5万字；战术篇一共71章，35.1万字。合计105章，50.6余万字。发布战术篇的最后一章是在2020年1月21日，完成本书初稿是在2020年11月24日。</p>
<p>个人认为，领域驱动设计课程的内容已经足够完整了，对于课程内容，几乎没有差评（至少我没有看到）；但我仍嫌不足，在完成该课程后，又对内容进行了大刀阔斧地修改与调整，彻底改变了从战略到战术这条线的章节安排，引入了我总结的<strong>领域驱动设计统一过程</strong>，增加了三章与需求分析有关的内容，完善了战略篇，将其进化为架构映射的内容，丰富了限界上下文的定义，引入了菱形对称架构与领域驱动架构风格，完善了战术篇，将其进化为领域建模的内容，使得领域建模的过程与方法更加完整，并具备可操作性。同时，也删减了该课程中部分与领域驱动设计关系不大的内容，使得内容变得更精简也更有条理，最后成书包括4篇推荐序、1篇前言、20章正文组成五个篇章，以及4章附录，总字数（不包括空白、空行与标点符号）约43万字。</p>
<p>虽然本书初稿完成在2020年11月24日，然而在交稿后，又几度批阅删改，甚至在2021年1月基本定稿后，因为字数和章节的不合理性，于2月4日向出版社提出修改要求，为此牺牲了春节的休假时间，调整内容包括：</p>
<ul>
<li>去掉了原稿的第16章、第21章</li>
<li>将原稿的第7章、第14章和第22章合并，并做了大量删减，放到了新稿的第20章，它们合起来是一个完整的案例；</li>
<li>将原稿的第17章、第19章和第20章中的一个案例做了合并，并做了少量调整，放到了新稿的第17章；</li>
<li>调整了正文和附录的分布，从原书的25章调整为正文20章、附录3章（后在5月份又增加了一章附录）</li>
</ul>
<p>这一改动几乎等于乾坤大挪移，严重影响了出版进度。编辑需要针对之前基本完成加工的书稿进行重新梳理，极大地拖慢了出版进度，同时，因为图片字体版权问题，又对本书所有图片进行了再度编辑和调整，直到4月22日最终定稿。确定后的书稿先后经历出版社的一审、二审、三审，再经我个人审校后，编辑做一校、二校、三校，种种工作，不一而足，最终等到书稿付梓印刷，并在今日开启了本书的预售工作。</p>
<h3 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h3><p>本书全面阐释了领域驱动设计的知识体系，内容覆盖领域驱动设计的主要模式与主流方法，并在此基础上提出领域驱动设计统一过程，将整个软件构建过程划分为全局分析、架构映射和领域建模3个阶段。除给出诸多案例阐释领域驱动设计过程中的方法与模式之外，本书还通过一个真实而完整的案例全面展现了如何进行领域驱动设计统一过程的实施和落地。为了更好地运用领域驱动设计统一过程，本书还开创性地引入了业务服务、菱形对称架构、领域驱动架构、服务驱动设计等方法与模式，总结了领域驱动设计参考过程模型与能力评估模型。本书提出的一整套方法体系已在多个项目得到推广和落地。</p>
<p>本书适合希望体会软件架构本质、提高软件架构能力的软件架构师，希望提高领域建模能力、打磨软件设计能力的开发人员，希望掌握业务分析与建模方法的业务分析人员，希望学习领域驱动设计并将该方法运用到项目中的软件从业人员阅读参考。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>本书目录为：</p>
<ul>
<li>推荐序四篇</li>
<li>前言</li>
<li>第一篇 开篇<ul>
<li>第1章 软件复杂度剖析</li>
<li>第2章 领域驱动设计概览</li>
<li>第3章 领域驱动设计统一过程</li>
</ul>
</li>
<li>第二篇 全局分析<ul>
<li>第4章 问题空间探索</li>
<li>第5章 价值需求分析</li>
<li>第6章 业务需求分析</li>
</ul>
</li>
<li>第三篇 架构映射<ul>
<li>第7章 同构系统</li>
<li>第8章 系统上下文</li>
<li>第9章 限界上下文</li>
<li>第10章 上下文映射</li>
<li>第11章 服务契约设计</li>
<li>第12章 领域驱动架构</li>
</ul>
</li>
<li>第四篇 领域建模<ul>
<li>第13章 模型驱动设计</li>
<li>第14章 领域分析建模</li>
<li>第15章 领域模型设计要素</li>
<li>第16章 领域设计建模</li>
<li>第17章 领域实现建模</li>
</ul>
</li>
<li>第五篇 融合<ul>
<li>第18章 领域驱动设计的战略考量</li>
<li>第19章 领域驱动设计的战术考量</li>
<li>第20章 领域驱动设计体系</li>
</ul>
</li>
<li>附录<ul>
<li>附录A 领域建模范式</li>
<li>附录B 事件驱动模型</li>
<li>附录C 领域驱动设计魔方</li>
<li>附录D 领域驱动设计统一过程交付物</li>
</ul>
</li>
<li>参考文献</li>
</ul>
<h3 id="样章阅读"><a href="#样章阅读" class="headerlink" title="样章阅读"></a>样章阅读</h3><ul>
<li><a href="https://www.epubit.com/onlineEbookReader?id=aa089770eea74021958ecb1fe622fb5d&pid=2d58f18fed9243aaaaeabf1a6fd8c539">序一</a></li>
<li><a href="https://www.epubit.com/onlineEbookReader?id=2fd7c627096a4ee588d41964a358d3c9&pid=2d58f18fed9243aaaaeabf1a6fd8c539">序二</a></li>
<li><a href="https://www.epubit.com/onlineEbookReader?id=8f9fff26f6894b899f128002a0c34a83&pid=2d58f18fed9243aaaaeabf1a6fd8c539">序三</a></li>
<li><a href="https://www.epubit.com/onlineEbookReader?id=06e257cf62464431b7f31386c61d9568&pid=2d58f18fed9243aaaaeabf1a6fd8c539">序四</a></li>
<li><a href="https://www.epubit.com/onlineEbookReader?id=61537b18f42440f1ae4d90c57c798e35&pid=2d58f18fed9243aaaaeabf1a6fd8c539">前言</a></li>
<li><a href="https://www.epubit.com/onlineEbookReader?id=ecbfb8ca1e434e9eb7d1d8da9569006a&pid=2d58f18fed9243aaaaeabf1a6fd8c539">第1章 软件复杂度剖析</a></li>
<li><a href="">第2章 领域驱动设计概览</a></li>
<li><a href="https://www.epubit.com/onlineEbookReader?id=9542d12f7f254de8b138c247a420eeea&pid=2d58f18fed9243aaaaeabf1a6fd8c539">第3章 领域驱动设计统一过程</a></li>
<li><a href="https://www.epubit.com/onlineEbookReader?id=2f52844d824b4d1aa8602f338f301cf0&pid=2d58f18fed9243aaaaeabf1a6fd8c539">第20章 领域驱动设计体系</a></li>
</ul>
]]></content>
      <categories>
        <category>Writing</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title>《解构领域驱动设计》篇首语</title>
    <url>/prologue-of-every-volumn-of-ddd-explained/</url>
    <content><![CDATA[<p>《解构领域驱动设计》在领域驱动设计统一过程的指导下，将该过程的全部三个阶段作为本书的三个核心篇章：全局分析、架构映射与领域建模，再辅以开篇和融合，共分为五篇二十五章，全面而完整地表达了我对领域驱动设计的全部认知与最佳实践。</p>
<span id="more"></span>

<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>开篇，明义。<br>领域驱动设计需要应对软件复杂度的挑战！那么，软件复杂度的成因究竟是什么？又该如何应对？概括而言，即：<br>* 规模：通过分而治之控制规模<br>* 结构：通过边界保证清晰有序<br>* 变化：顺应变化方向</p>
<p>领域驱动设计对软件复杂度的应对之道可进一步阐述为：<br>* 规模：以子领域、限界上下文分而治之<br>* 结构：以分层架构隔离业务复杂度与技术复杂度，形成清晰的架构<br>* 变化：通过领域建模抽象为以聚合为核心的领域模型，响应需求之变化</p>
<p>子领域、限界上下文、分层架构与聚合皆为领域驱动设计的核心元模型，分属战略设计和战术设计，贯穿了从问题空间到解空间的全过程。</p>
<p>领域驱动设计的开放性是其生命长青的基石，但它过于开放的灵活性也让运用领域驱动设计的开发团队变得举步维艰。我之所以提出领域驱动设计统一过程，正是要在开放的方法体系指导之下，摸索出一条行之有效的软件构建之路。它既不悖于领域驱动设计之精神，又不吝于运用设计元模型，通过提供简单有效的实践方法，建立具有目的性和操作性的构建过程。</p>
<p>领域驱动设计统一过程分为三个阶段：<br>* 全局分析阶段<br>* 架构映射阶段<br>* 领域建模阶段</p>
<p>每个阶段的过程工作流既融合了领域驱动设计既有的设计元模型，又提出了新的模式、方法与实践，丰富了领域驱动设计的外延。领域驱动设计统一过程对项目管理、需求管理与团队管理也提出了明确的要求，它们虽然不属于领域驱动设计关注的范畴，却是影响领域驱动设计实践与落地成功与否的重要因素。<br>领域驱动设计统一过程是对领域驱动设计进行解构的核心内容！</p>
<h3 id="全局分析"><a href="#全局分析" class="headerlink" title="全局分析"></a>全局分析</h3><p>解决问题的第一要务是明确问题，问题尚不知，就尝试求解，自然就是无的放矢了。全局分析的目标就是确定问题空间，在统一语言的指导下，通过各种可视化手段，由领域专家与团队一起完成对问题空间的探索，帮助领域驱动设计对准问题，输出价值需求和业务需求。</p>
<p>价值需求既是目标系统的目标，也是对目标系统问题空间的界定和约束，它指导着业务需求分析。业务需求由动态的业务流程和静态的业务活动组成，二者的结合依靠业务场景按照时间点和业务目标对业务流程的切分。通过运用商业模式画布，可以获得组成价值需求的利益相关者、系统愿景和系统范围。</p>
<p>业务流程的梳理可以帮助团队对问题空间的各条业务线构成一个整体认识，弄清楚各种角色如何参与到一个完整的流程中，流程的时序性也可以避免识别业务活动时可能出现的缺失。业务流程图与服务蓝图以可视化的方式形象地呈现每一个提供了业务价值的业务流程。</p>
<p>业务活动是角色与目标系统之间的一次功能性交互，是体现了服务价值的功能行为。一直以来，该如何确定业务需求层次，划分业务需求粒度，总是众说纷纭，没有一个客观的标准；业务活动将目标系统视为一个黑盒子，从功能性交互的完整性保证了每个业务活动都是正交的，就无需再考虑业务活动的层次和粒度，或者说，只要确定了完整性，保障了正交性，业务活动的层次与粒度也就确定下来了。业务活动可以使用用例、用户故事或事件风暴中的事件来表达。</p>
<p>业务活动是全局分析阶段的基本业务单元，它的输出对于架构映射与领域建模具有重要意义：<br>* 架构映射：业务活动是识别限界上下文、确定上下文映射的基础，同时，它的粒度正好对应每个限界上下文向外公开的服务契约；<br>* 领域模型：业务需求分析细化的业务活动既是领域分析建模的重要参考，同时又作为服务场景成为场景驱动设计的起点。</p>
<p>全局分析是领域驱动设计统一过程的起点，它的目的是探索问题空间，使团队就问题空间的价值需求和业务需求达成共识，并在统一语言的指导下将其清晰地呈现出来。只有问题定义清楚了，团队才能更好地寻求解决方案。</p>
<h3 id="架构映射"><a href="#架构映射" class="headerlink" title="架构映射"></a>架构映射</h3><p>架构映射对应解空间的战略设计层次。</p>
<p>本阶段，映射成为了获得架构的主要设计手段。价值需求中利益相关者、系统愿景和系统范围可映射为系统上下文，业务活动通过对业务相关性的归类与归纳可映射为限界上下文，二者又是构成系统架构的重要层次，前者勾勒出解空间的控制边界，后者勾勒出领域模型的知识边界，组成了一个稳定而又具有演进能力的领域驱动架构。<br>限界上下文是架构映射阶段的基本架构单元，决定一个限界上下文边界的元素包括：领域对象、领域知识、角色和活动。限界上下文是领域模型的知识语境，又是业务能力的纵向切分，它满足自治单元的四个要素：最小完备、自我履行、稳定空间、独立进化。一个自治的限界上下文一定遵循菱形对称架构模式。</p>
<p>菱形对称架构模式将整个限界上下文分为内部的领域层和外部的网关层，网关层根据调用方向分为北向网关和南向网关。北向网关体现了“封装”的设计思想，根据通信方式的不同分为远程服务与应用服务；南向网关体现了“抽象”的设计思想，将抽象与实现分离，分为端口与适配器。在诸多上下文映射模式中，除了共享内核与遵奉者模式，都应在菱形对称架构网关层的控制下进行协作。</p>
<p>系统上下文对应了解空间的范围，它站在组织层面思考利益相关者、目标系统与伴生系统之间的关系。它通过系统分层架构体现目标系统的逻辑结构，并按照子领域价值的不同，为限界上下文确定了不同的层次。根据康威定律的规定，系统分层架构可以映射为由前端组件团队、领域特性团队与组件团队组成的开发团队。</p>
<p>限界上下文是顺应业务变化进行功能分解的软件元素，菱形对称架构规定了限界上下文之间、限界上下文与外部环境之间的关系，由系统分层架构模式与菱形对称架构模式组成的领域驱动架构风格则是指导架构设计与演进的原则。这些内容符合架构的定义，同时也是对控制软件复杂度的呼应。</p>
<p>领域建模要在架构的约束下进行，系统上下文和限界上下文的边界对领域模型起到了设计约束的作用。根据限界上下文的价值高低，属于支撑子领域和通用子领域的限界上下文，往往因为业务简单，无需进行领域建模，如此就能快速开发，降低开发成本。因此，架构映射是领域建模的前提，也可以认为是战略对战术的设计指导。</p>
<h3 id="领域建模"><a href="#领域建模" class="headerlink" title="领域建模"></a>领域建模</h3><p>领域建模的过程，是模型驱动设计的过程，也是迭代建模的过程。</p>
<p>不可妄求一蹴而就能获得完整的领域模型，也不可殚精竭虑地追求领域模型的尽善尽美。领域建模的分析、设计和实现是循序渐进的增量建模，建模目标与侧重点也不尽相同。</p>
<p>领域分析模型负责捕捉表示领域知识的领域概念，明确它们之间的关系，形成反映现实世界的对象概念图。获得的分析模型全面而粗疏，既不至于遗漏重要的领域概念导致模型的缺失，又不至于锱铢必较地因为过分定义领域属性而陷入分析瘫痪。</p>
<p>领域设计模型在领域分析模型的基础上加入对设计和实现的思考，为对象概念图戴上聚合的镣铐，在保证概念完整性、独立性、不变量与一致性的基础上，更好地管理对象的生命周期。场景驱动设计则赋予了领域模型以动能，在对服务场景进行任务分解的基础上，由外自内由各种角色构造型参与协作，形成了连续执行的消息链条，驱动出远程服务、应用服务、领域服务、聚合和各种端口的方法，既验证了领域模型对象的正确性与完整性，又丰富了领域模型的内容。</p>
<p>领域实现模型基于场景驱动设计输出的任务列表和序列图脚本开展测试驱动开发，领域层的产品代码与测试代码共同构成领域实现模型。由于拥有单元测试的保护，及时重构又改进了代码的质量，使得领域实现模型变得整洁而稳定，形成具有运行能力的核心领域资产。在实现领域模型时，也是对领域设计模型和领域分析模型的一次验证。</p>
<p>聚合是领域建模阶段的基本设计单元。领域分析模型向领域设计模型的演进是通过识别聚合完成的，聚合边界的约束能力使得领域设计模型在保证细粒度对象定义的同时，又能通过封装实体与值对象的细节简化对象模型，降低领域模型的复杂度。一旦确定了聚合，就可以由此定义资源库端口和领域服务，并按照信息专家模式将体现领域逻辑的原子任务分配给聚合，建立富领域模型。聚合是纯粹的，它不依赖于任何访问外部资源的端口，因此它也是稳定的；因为聚合是稳定的，使得围绕着它为核心建立的领域模型也变得更加稳定。</p>
<h3 id="融合"><a href="#融合" class="headerlink" title="融合"></a>融合</h3><p>融合，就是战略和战术的融合，为了让软件运行起来，还需考虑领域逻辑与技术实现的融合，即领域层与网关层的融合。</p>
<p>在战略层次，需在领域驱动架构风格的约束和指导下考虑限界上下文之间的协作，思考并决策限界上下文的通信边界，思考从单体架构向微服务架构的演进，同时，因为进程间通信引起的诸多影响，需评估分布式通信、事务以及受技术因素驱动的命令查询职责分离模式是否对领域模型造成了影响。</p>
<p>事实证明，遵循领域驱动架构风格的系统完全满足架构演进的要求，只需付出少量修改成本，即可支持单体架构、SOA架构、微服务架构与事件驱动架构，同时还满足了领域模型的稳定性。</p>
<p>在战术层次，通过建立设计概念的统一语言，保证团队在领域建模时避免因概念理解的偏差出现设计的不一致，甚至做出有违领域驱动设计理念的错误决策。通过领域模型驱动设计获得的领域模型还需要考虑如何与持久化结合，解决对象关系映射的阻抗不匹配问题，以更加优雅的方式实现资源库，保证作为端口的资源库实现不会侵入领域模型，破坏领域的纯粹性。</p>
<p>无论战略还是战术，抑或二者的融合，都需要在领域驱动设计知识体系的指导下进行。结合领域驱动设计社区的发展与我个人的设计经验，尝试对领域驱动设计做进一步梳理和升华，建立了全方位多维度的领域驱动设计魔方，基于领域驱动设计统一过程给出了具有可操作性的参考过程模型，提炼了领域驱动设计的精髓，面向团队给出领域驱动设计的能力评估模型，如此就能将方法、过程、模式有机地融合起来，给出行之有效的指导意见。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD, Writing</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动战术设计进度说明</title>
    <url>/process-of-domain-driven-tactic-design/</url>
    <content><![CDATA[<p>我在GitChat发布的《领域驱动战略设计》课程于2018年10月结束，原计划是在2018年底或2019年初再发布《领域驱动战术设计》课程，没想到一拖再拖，而我自己也终于体会到起点作者的那种催更压力。我本想揣着鸵鸟的心态躲在后面默默地写、慢慢地写，不给自己设定最终期限，没想到读者群里的众多读者已经开始发出了自己的呼声：</p>
<img src="/process-of-domain-driven-tactic-design/01.png" class="">

<p>我想，我没法再藏起来假装自己不知道，只得站出来给大家汇报。</p>
<span id="more"></span>

<h2 id="课程大纲"><a href="#课程大纲" class="headerlink" title="课程大纲"></a>课程大纲</h2><p>我计划的《领域驱动战术设计》课程共分为六部分内容，分别为：</p>
<ul>
<li>领域模型</li>
<li>分析模型</li>
<li>设计模型</li>
<li>实现模型</li>
<li>融合</li>
<li>案例分析：EAS系统</li>
</ul>
<h3 id="第一部分：领域模型"><a href="#第一部分：领域模型" class="headerlink" title="第一部分：领域模型"></a>第一部分：领域模型</h3><p>领域驱动设计的核心是模型驱动设计，但Eric Evans并没有费太多笔墨来探讨“模型”。我认为讨论任何技术问题，都应该先明确技术概念的含义，在达成一致认识的前提下，才谈得上该如何设计与实现。</p>
<p>我发现许多人在争执领域驱动设计的问题时，甚至都没有分清楚什么是领域建模，什么是数据建模，二者的差异又是什么？因此，我希望在本部分对“模型”来一个彻底的讨论，阐释模型在软件设计中的角色和价值，并比较数据模型、服务模型和领域模型之间的区别。</p>
<p>对于领域驱动的分层架构，我在《领域驱动战略设计》课程中已有深入分析，但我发现很多读者依然会混淆各个层次中的模型，例如什么是DTO？什么是持久化对象？它们和领域对象之间的关系？这些问题真的是剪不断理还乱。所谓“正本清源”，要掌握领域驱动设计，这些概念是需要甄别清楚的。</p>
<p>本部分，我还比较了事务脚本、表模块和领域模型，并由此探讨了模型与编程范式之间的关系。</p>
<h3 id="第二部分：分析模型"><a href="#第二部分：分析模型" class="headerlink" title="第二部分：分析模型"></a>第二部分：分析模型</h3><p>在第一部分，我将领域模型分为分析领域模型、设计领域模型和实现领域模型三种模型，故而接下来的三个部分我将开展对这三个模型的介绍。</p>
<p>分析模型是在分析阶段进行建模后的结果，由于领域驱动设计强调以领域为核心，因而由领域专家与开发团队达成一致的统一语言将在分析模型中扮演非常重要的角色。</p>
<p>软件分析是一种技能，但我们也可以借鉴一些方法，来帮助我们提高分析的能力。因此，在本部分我会利用分析模式、四色建模和事件风暴来帮助我们获得分析模型。若有可能，我还希望再加上一个ICONIX方法，虽然它已经垂垂老矣，但该方法蕴含的一些设计思想仍有值得借鉴之处。</p>
<h3 id="第三部分：设计模型"><a href="#第三部分：设计模型" class="headerlink" title="第三部分：设计模型"></a>第三部分：设计模型</h3><p>这部分才真正进入领域驱动战术设计的内容，你会看到实体、值对象、领域服务、领域事件等耳熟能详的设计要素。即便如此，针对这些基本的设计要素，许多读者仍然存在对它们的理解差异，我希望能够说清楚这些设计要素，并结合案例来展现一个正确的领域模型会给我们带来什么样的价值。</p>
<p>聚合在领域驱动设计中极为关键，是Eric Evans提出的一个非比寻常的创见。然而，一直以来，我们却不知道该如何设计高质量的聚合，我希望我能尽量帮助读者理解聚合的意义，以及识别聚合的原则和方法。</p>
<p>在领域驱动设计中，许多人常常分不清楚领域服务和应用服务之间的差异，也没有能够理解资源库和DAO之间的区别，针对这些棘手问题，我会努力给出清楚的答案。</p>
<p>从本质上讲，Eric Evans的领域驱动设计其实就是对面向对象设计的运用。如何进行良好的面向对象设计呢？“职责”才是面向对象的核心，因此我将结合案例阐释我对职责驱动设计的理解，并给出可行的设计方法与过程。</p>
<p>DCI模式与职责协作有相似之处，它强调在不同场景（Context）中各个角色之间的协作。理解DCI，有助于我们理解什么是多态，什么是SPI。许多设计本质其实是愈辩愈清的。</p>
<h3 id="第四部分：实现模型"><a href="#第四部分：实现模型" class="headerlink" title="第四部分：实现模型"></a>第四部分：实现模型</h3><p>实现模型基本可以认为是代码模型，我希望通过这部分内容回答常见的实现难题，包括：</p>
<ul>
<li>贫血模型与充血模型的问题</li>
<li>领域模型与持久化</li>
<li>通过事务保证不变量与一致性</li>
</ul>
<p>在这部分内容中，我还将引入重构、测试驱动开发和整洁代码的知识，以求实现模型在代码层面能够清晰直观地体现统一语言。</p>
<h3 id="第五部分-融合：战略设计与战术设计"><a href="#第五部分-融合：战略设计与战术设计" class="headerlink" title="第五部分 融合：战略设计与战术设计"></a>第五部分 融合：战略设计与战术设计</h3><p>领域驱动的战略设计与战术设计不是割裂的，在本部分，我将呼应战略设计的内容，将这二者结合起来。内容包括分层架构、REST服务、Dubbo服务与核心的领域模型以及CQRS模式。</p>
<h3 id="第六部分-案例：EAS系统"><a href="#第六部分-案例：EAS系统" class="headerlink" title="第六部分 案例：EAS系统"></a>第六部分 案例：EAS系统</h3><p>仍然采用战略设计中的EAS系统作为案例，如此可以体现整个领域驱动设计的全貌。在战术设计课程中，我将结合战略设计得出的限界上下文，对EAS系统的核心领域进行分析建模，然后在分析模型的基础之上，通过引入领域驱动设计的设计要素和设计模式，获得设计模型，最终通过代码来实现。整个EAS系统是一个相对完整的代码库，届时会发布在github之上。</p>
<h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><p>我原计划战略设计课程能在九月份完工，随着战略设计课程的发布，我就可以提前着手撰写战术设计课程的内容。没想到我在编辑和修改战略设计课程的时候，并不满意之前已经写好的稿件，于是开始不停地重构乃至于重写，进度被拖慢后，到最后的案例部分，甚至变成了一边写作一边发布。简单来说，就是在发布课程的最后阶段，我手里已经没有存稿了。</p>
<p>因此，我真正开始撰写战术设计课程内容，已经是2018年的11月，进度比原计划足足晚了两个月。这期间，因为自己的懒惰，写作进度非常缓慢。此外，在闲暇之余我也需要抽出时间陪伴家人，自己负责的项目进度压力大，导致每天专心写作的时间越来越少，拖延症的威力也越来越大，眼看着进入2019年的三月了，进展依旧缓慢。目前的进度大致如下：</p>
<ul>
<li>第一部分：领域模型 完成情况：50%</li>
<li>第二部分：分析模型 完成情况：80%</li>
<li>第三部分：设计模型 完成情况：60%</li>
<li>第四部分：实现模型 完成情况：0%</li>
<li>第五部分：融合 完成情况：0%</li>
<li>第六部分：案例分析 完成情况：30%</li>
</ul>
<p>从进度情况看，一旦我完成前面三个部分，基本上就可以考虑课程的发布了，之后的内容可以写作与发布同步进行。根据我目前的写作速度，我的理想发布时间应该会在四月中旬或下旬。会不会太晚？没有办法！有多少项目是按时交付的？写作不是件简单的事情，高质量的写作就更不容易。我的写作我做主，大家慢慢等吧！我不为时间负责，我只为质量负责！</p>
<p>如此，算是广而告之！</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title>GitChatDDD课程微信群问答</title>
    <url>/qa-for-ddd-group-of-wechat/</url>
    <content><![CDATA[<img src="/qa-for-ddd-group-of-wechat/cover.png" class="">



<p>我在GitChat发布了《<a href="https://gitbook.cn/gitchat/column/5cdab7fb34b6ed1398fd8de7">领域驱动设计实践</a>》<a href="https://gitbook.cn/gitchat/column/5b3235082ab5224deb750e02">战略篇</a>+<a href="https://gitbook.cn/gitchat/column/5cbed2f6f00736695f3a8699">战术篇</a>课程，购买该课程的学员还可以免费加入由我创建，GitChat维护的DDD微信群。目前，已创建三个微信群，人数达到1200人左右。在这三个群里，每天都有DDD的爱好者参与激烈的讨论，讨论的质量也格外的高。我几乎可以自豪地说，天下DDD英雄已尽在群中矣。</p>
<p>感谢志愿者@子鱼每天不辞辛劳对群里问题的收集。本文遴选了部分问题给以回答。</p>
<span id="more"></span>



<h3 id="DDD事件风暴如何落地"><a href="#DDD事件风暴如何落地" class="headerlink" title="DDD事件风暴如何落地"></a>DDD事件风暴如何落地</h3><p>背景：电商履约过程中， 确定一个订单具体进哪一个仓的因素多， 以往的实现方式是把这些规则收集起来逐个实现。</p>
<p><strong>问题：</strong>针对订单定仓的场景， 事件风暴中， 可能只有一句话， 表示成“订单已定仓”。背后那些复杂的规则及规则之间的综合判断逻辑，没有体现出来， 也就不方便用DDD的思路改造。请帮看下， 这样业务上可能一带而过但具体实现复杂的功能点， 怎么借助DDD改造优化下？</p>
<p>提问者之后又补充道：</p>
<p>具体实施上有些问题：</p>
<ul>
<li><p>公司没有领域专家。</p>
</li>
<li><p>有业务方， 不过业务方不稳定， 经常换人， 反倒不如落到代码上的经验具体和全面。</p>
</li>
</ul>
<p><strong>我的回答：</strong></p>
<p>实际上这个问题充分说明我们在实践事件风暴时，并没有得到合理运用。事件风暴究竟优势在哪里？事件并非灵丹妙药，因为有了它，业务就一下子变得清晰了。哪有这么容易的事儿。如果真正实践过事件风暴，你会发现它的核心思想其实仍然是通过识别出领域知识中各个细小但关键的概念，然后针对这些概念进行抽象、归纳，算是一种自底向上的分析过程，只不过表现形式不再是功能、用例、或者类。</p>
<p>实践事件风暴与传统建模方法不同之处在于：</p>
<ul>
<li>它非常强调领域专家与全团队的参与。如果公司没有领域专家，也需要邀请具有业务知识的角色参与到事件风暴的过程中来。</li>
<li>它非常强调可视化的沟通形式与面对面的交流形式。利用各种颜色的即时贴表示不同的概念，并以清晰直观地事件流呈现出来，就能消除交流的误解，打破沟通可能存在的坚冰。</li>
</ul>
<p>至于事件产生的驱动力，以及事件风暴的过程，在我的课程中已有介绍，这里就不再赘述。</p>
<h3 id="核心子领域还是支撑子领域"><a href="#核心子领域还是支撑子领域" class="headerlink" title="核心子领域还是支撑子领域"></a>核心子领域还是支撑子领域</h3><p><strong>问题：</strong>请问各位大佬,公司要做促销系统, 在下准备根据ddd的思想来做, ，但是想到要划分核心域, 通用域,支撑域的时候,针对于公司,整个促销系统都不是核心 , 是不是这里就直接整个系统都当做一个支撑域就行了?</p>
<p><strong>我的回答：</strong></p>
<p>这个问题也是许多初涉DDD的人容易误解的。Eric Evans在讨论核心领域时，当然是针对你要开发的系统而言，只有对你的系统而言最有价值，最值得投资的领域才是你的核心领域。Vernon在《实现领域驱动设计》书中，就阐释得更清晰一些，他认为分辨子领域到底是核心，还是通用或者支撑，需要结合具体的场景来考虑。例如在电商系统中，地图领域就是支撑子领域，但是对于做地图系统的团队而言，地图领域就是核心子领域了。</p>
<p>促销系统或许不是公司的核心领域，但是这里要实施DDD的是促销系统，毫无疑问，你应该为促销系统划分核心子领域、支撑子领域以及通用子领域。除非整个领域的问题域非常小，自然没有拆分的必要。</p>
<p>顺便说以下，Eric Evans在《领域驱动设计》书中仅仅提出了核心领域（注意是核心领域，而非核心子领域）与通用子领域，Vernon的书中则增加了支撑子领域。为了概念的一致性，统一称之为：核心子领域、支撑子领域与通用子领域。</p>
<h3 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h3><p><strong>问题：</strong>我们的定向开发思维，导致在对分层架构时很好理解；但对于六边型架构，虽然看过很多次，但还是不能想像出具体的代码实现。请问六边型架构有具体的源码吗？</p>
<p><strong>回答：</strong></p>
<p>群里已有精彩的回答。</p>
<p>Qiao Liang: 洋葱架构  <a href="https://youtu.be/o_TH-Y78tt4">https://youtu.be/o_TH-Y78tt4</a> bob martin讲的挺清楚的</p>
<p>忘却录音：整洁架构，微内核架构，架构设计模式 都是通过分离关注点，划分边界的方式。达到结构的清晰与一致</p>
<p>lucoo：阿里的cola <a href="https://github.com/alibaba/COLA">https://github.com/alibaba/COLA</a> </p>
<p>孔令秋：六边形架构的核心是隔离耦合，六边形架构将系统分为两个部分，系统的业务逻辑与系统依赖的其他部分（其他部分包括各种中间件，其他的微服务，数据库等等），六边形架构最好结合maven来使用，一个微服务对应一个project，一个project多个module，最核心的三个module分别是应用层，领域层，基础设施层，其中基础设施层引用其他两层，这样就实现了依赖倒置，依赖倒置也就隔离了耦合，同时单元测试也会变得容易</p>
<p>阿斌哥： 六边形架构的入站适配器对应张老师所说的北向网关，出站适配器对应南向网关，入站端口对应应用服务，出站端口对应南向网关的抽象。依赖倒置的核心就在那一层南向网关的抽象。</p>
<p><strong>我的补充：</strong></p>
<p>六边形架构其实相当于是隔离内外的分层架构，在学习时，你可以将两个六边形隔离出来的三个区域映射到分层架构上帮助你理解。我的GitChat课程其实已经较清晰地分析了分层架构、六边形架构与整洁架构之间的关系，以及分层架构的演进。</p>
<p>在内外两个六边形之间的区域都是适配器（Adapter）。如果是六边形外部向内部的适配器发起请求，则该适配器称之为Driving Adapter，也就是我说的“北向网关”；反之，该适配器称之为Driven Adapter，也就是我说的“南向网关”。</p>
<p>如果结合DDD的模式来理解，北向网关就是上下文映射中的“开放主机服务（OHS）”模式，服务可以分为：</p>
<ul>
<li>Resource：REST资源服务</li>
<li>Provider：RPC提供者服务</li>
<li>Controller：面向前端UI的控制器服务</li>
<li>Event Subscriber：面向事件的订阅者</li>
</ul>
<p>这些服务传递的DTO（我称之为消息契约对象）就是上下文映射中的“发布语言（Published Language）”模式。</p>
<p>南向网关就是上下文映射中的“防腐层（ACL）”模式，常见的防腐层包括：</p>
<ul>
<li>Client：对被调用（上游）服务接口的封装</li>
<li>Event Publisher：发布事件</li>
</ul>
<p>实际上，我们也可以将对数据库访问的封装即资源库（Repository）视为是一种防腐层。我在GitHub上创建的项目<a href="https://github.com/agiledon/eas-ddd">EAS-DDD</a>的代码结构其实就是按照这一思路来创建的，也可以认为它遵循了六边形架构的设计原则。</p>
<p>目前，我看到讲解六边形模式（即端口适配器模式）最好的是ThoughtWorks的周宇刚撰写的文章《<a href="https://insights.thoughtworks.cn/port-and-adapter-architecture/">端口和适配器架构——DDD好帮手</a>》。本文发表于ThoughtWorks洞见，讲解思路非常清晰，作者对该模式的理解炉火纯青，真的是从本质上剖析了该模式与DDD的结合。推荐阅读。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>GitChat</tag>
        <tag>QA</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Spark读取并分析二进制文件</title>
    <url>/read-binary-file-using-spark/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>客户希望通过spark来分析二进制文件中0和1的数量以及占比。如果要分析的是目录，则针对目录下的每个文件单独进行分析。分析后的结果保存与被分析文件同名的日志文件中，内容包括0和1字符的数量与占比。</p>
<span id="more"></span>

<p>要求：如果值换算为二进制不足八位，则需要在左侧填充0。</p>
<p>可以在linux下查看二进制文件的内容。命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxd –b –c 1 filename</span><br></pre></td></tr></table></figure>

<p><code>-c 1</code>是显示1列1个字符，<code>-b</code>是显示二进制</p>
<h2 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This Python file uses the following encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkConf, SparkContext</span><br><span class="line"></span><br><span class="line">APP_NAME = <span class="string">&quot;Load Bin Files&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">spark_context, path</span>):</span></span><br><span class="line">    file_paths = fetch_files(path)</span><br><span class="line">    <span class="keyword">for</span> file_path <span class="keyword">in</span> file_paths:</span><br><span class="line">        outputs = analysis_file_content(spark_context, path + <span class="string">&quot;/&quot;</span> + file_path)</span><br><span class="line">        print_outputs(outputs)</span><br><span class="line">        save_outputs(file_path, outputs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_files</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">        <span class="keyword">return</span> [path]</span><br><span class="line">    <span class="keyword">return</span> os.listdir(path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis_file_content</span>(<span class="params">spark_context, file_path</span>):</span></span><br><span class="line">    data = spark_context.binaryRecords(file_path, <span class="number">1</span>)</span><br><span class="line">    records = data.flatMap(<span class="keyword">lambda</span> d: <span class="built_in">list</span>(<span class="built_in">bin</span>(<span class="built_in">ord</span>(d)).replace(<span class="string">&#x27;0b&#x27;</span>, <span class="string">&#x27;&#x27;</span>).zfill(<span class="number">8</span>)))</span><br><span class="line">    mapped_with_key = records.<span class="built_in">map</span>(<span class="keyword">lambda</span> d: (<span class="string">&#x27;0&#x27;</span>, <span class="number">1</span>) <span class="keyword">if</span> d == <span class="string">&#x27;0&#x27;</span> <span class="keyword">else</span> (<span class="string">&#x27;1&#x27;</span>, <span class="number">1</span>))</span><br><span class="line">    result = mapped_with_key.reduceByKey(<span class="keyword">lambda</span> x, y: x + y)</span><br><span class="line"></span><br><span class="line">    total = result.<span class="built_in">map</span>(<span class="keyword">lambda</span> r: r[<span class="number">1</span>]).<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> result.<span class="built_in">map</span>(<span class="keyword">lambda</span> r: format_outputs(r, total)).collect()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_outputs</span>(<span class="params">value_with_key, total</span>):</span></span><br><span class="line">    tu = (value_with_key[<span class="number">0</span>], value_with_key[<span class="number">1</span>], value_with_key[<span class="number">1</span>] / total * <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;字符&#123;0&#125;的数量为&#123;1&#125;, 占比为&#123;2:.2f&#125;%&quot;</span>.<span class="built_in">format</span>(*tu)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_outputs</span>(<span class="params">outputs</span>):</span></span><br><span class="line">    <span class="keyword">for</span> output <span class="keyword">in</span> outputs:</span><br><span class="line">        <span class="built_in">print</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_outputs</span>(<span class="params">file_path, outputs</span>):</span></span><br><span class="line">    result_dir = <span class="string">&quot;result&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(result_dir):</span><br><span class="line">        os.mkdir(result_dir)</span><br><span class="line"></span><br><span class="line">    output_file_name = <span class="string">&quot;result/&quot;</span> + file_name_with_extension(file_path) + <span class="string">&quot;.output&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_file_name, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> result_file:</span><br><span class="line">        <span class="keyword">for</span> output <span class="keyword">in</span> outputs:</span><br><span class="line">            result_file.write(output + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        result_file.write(<span class="string">&quot;统计于&#123;0&#125;\n\n&quot;</span>.<span class="built_in">format</span>(format_logging_time()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_logging_time</span>():</span></span><br><span class="line">    <span class="keyword">return</span> time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%m:%s&#x27;</span>, time.localtime(time.time()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_name_with_extension</span>(<span class="params">path</span>):</span></span><br><span class="line">    last_index = path.rfind(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span></span><br><span class="line">    length = <span class="built_in">len</span>(path)</span><br><span class="line">    <span class="keyword">return</span> path[last_index:length]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    conf = SparkConf().setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">    conf = conf.setAppName(APP_NAME)</span><br><span class="line">    sc = SparkContext(conf=conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请输入正确的文件或目录路径&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        main(sc, sys.argv[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>核心逻辑都在<code>analysis_file_content</code>方法中。</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>python是脚本文件，无需编译。不过运行的前提是要安装好pyspark。运行命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/spark-submit /Users/zhangyi/PycharmProjects/spark_binary_files_demo/parse_files_demo.py &quot;files&quot;</span><br></pre></td></tr></table></figure>

<h3 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h3><h4 id="开发环境的问题"><a href="#开发环境的问题" class="headerlink" title="开发环境的问题"></a>开发环境的问题</h4><p>要在spark下使用python，需要事先使用pip安装pyspark。结果安装总是失败。python的第三方库地址是<code>https://pypi.python.org/simple/</code>，在国内访问很慢。通过搜索问题，许多文章提到了国内的镜像库，例如豆瓣的库，结果安装时都提示找不到pyspark。</p>
<p>查看安装错误原因，并非不能访问该库，仅仅是访问较慢，下载了不到8%的时候就提示下载失败。这实际上是连接超时的原因。因而可以修改连接超时值。可以在<code>~/.pip/pip.conf</code>下增加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">timeout = 6000</span><br></pre></td></tr></table></figure>

<p>虽然安装依然缓慢，但至少能保证pyspark安装完毕。但是在安装py4j时，又提示如下错误信息（安装环境为mac）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OSError: [Errno 1] Operation not permitted: &#x27;/System/Library/Frameworks/Python.framework/Versions/2.7/share&#x27;</span><br></pre></td></tr></table></figure>

<p>即使这个安装方式是采用sudo，且在管理员身份下安装，仍然提示该错误。解决办法是执行如下安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install --upgrade pip</span><br><span class="line"></span><br><span class="line">sudo pip install numpy --upgrade --ignore-installed</span><br><span class="line"></span><br><span class="line">sudo pip install scipy --upgrade --ignore-installed</span><br><span class="line"></span><br><span class="line">sudo pip install scikit-learn --upgrade --ignore-installed</span><br></pre></td></tr></table></figure>

<p>然后再重新执行<code>sudo pip install pyspark</code>，安装正确。</p>
<h4 id="字符编码的坑"><a href="#字符编码的坑" class="headerlink" title="字符编码的坑"></a>字符编码的坑</h4><p>在提示信息以及最后分析的结果中都包含了中文。运行代码时，会提示如下错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SyntaxError: Non-ASCII character &#x27;\xe5&#x27; in file /Users/zhangyi/PycharmProjects/spark_binary_files_demo/parse_files_demo.py on line 36, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details</span><br></pre></td></tr></table></figure>

<p>需要在代码文件的首行添加如下编码声明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This Python file uses the following encoding: utf-8</span></span><br></pre></td></tr></table></figure>

<h4 id="SparkConf的坑"><a href="#SparkConf的坑" class="headerlink" title="SparkConf的坑"></a>SparkConf的坑</h4><p>初始化SparkContext的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conf = SparkConf().setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">conf = conf.setAppName(APP_NAME)</span><br><span class="line">sc = SparkContext(conf)</span><br></pre></td></tr></table></figure>

<p>结果报告运行错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error initializing SparkContext.</span><br><span class="line">org.apache.spark.SparkException: Could not parse Master URL: &#x27;&lt;pyspark.conf.SparkConf object at 0x106666390&gt;&#x27;</span><br></pre></td></tr></table></figure>

<p>根据错误提示，以为是Master的设置有问题，实际上是实例化<code>SparkContext</code>有问题。阅读代码，发现它的构造函数声明如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, master=<span class="literal">None</span>, appName=<span class="literal">None</span>, sparkHome=<span class="literal">None</span>, pyFiles=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            environment=<span class="literal">None</span>, batchSize=<span class="number">0</span>, serializer=PickleSerializer(<span class="params"></span>), conf=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            gateway=<span class="literal">None</span>, jsc=<span class="literal">None</span>, profiler_cls=BasicProfiler</span>):</span></span><br></pre></td></tr></table></figure>

<p>而前面的代码仅仅是简单的将conf传递给<code>SparkContext</code>构造函数，这就会导致Spark会将conf看做是<code>master</code>参数的值，即默认为第一个参数。所以这里要带名参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sc = SparkContext(conf = conf)</span><br></pre></td></tr></table></figure>

<h4 id="sys-argv的坑"><a href="#sys-argv的坑" class="headerlink" title="sys.argv的坑"></a>sys.argv的坑</h4><p>我需要在使用spark-submit命令执行python脚本文件时，传入我需要分析的文件路径。与scala和java不同。scala的<code>main</code>函数参数argv实际上可以接受命令行传来的参数。python不能这样，只能使用sys模块来接收命令行参数，即<code>sys.argv</code>。</p>
<p>argv是一个list类型，当我们通过<code>sys.argv</code>获取传递进来的参数值时，一定要明白它会默认将spark-submit后要执行的python脚本文件路径作为第一个参数，而之后的参数则放在第二个。例如命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./bin/spark-submit /Users/zhangyi/PycharmProjects/spark_binary_files_demo/parse_files_demo.py &quot;files&quot;</span><br></pre></td></tr></table></figure>

<p>则：</p>
<ul>
<li><code>argv[0]</code>: /Users/zhangyi/PycharmProjects/spark_binary_files_demo/parse_files_demo.py</li>
<li><code>argv[1]</code>: files</li>
</ul>
<p>因此，我需要获得files文件夹名，就应该通过<code>argv[1]</code>来获得。</p>
<p>此外，由于argv是一个list，没有<code>size</code>属性，而应该通过<code>len()</code>方法来获得它的长度，且期待的长度为2。</p>
<h4 id="整数参与除法的坑"><a href="#整数参与除法的坑" class="headerlink" title="整数参与除法的坑"></a>整数参与除法的坑</h4><p>在python 2.7中，如果直接对整数执行除法，结果为去掉小数。因此<code>4 / 5</code>得到的结果却是0。在python 3中，这种运算会自动转型为浮点型。</p>
<p>要解决这个问题，最简单的办法是导入一个现成的模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>这个import的声明应该放在所有import声明前面。</p>
<h2 id="Scala版本"><a href="#Scala版本" class="headerlink" title="Scala版本"></a>Scala版本</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> bigdata.demo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.<span class="type">File</span></span><br><span class="line"><span class="keyword">import</span> java.text.<span class="type">SimpleDateFormat</span></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Calendar</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.io.&#123;<span class="type">Files</span> =&gt; <span class="type">GoogleFiles</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.<span class="type">Charsets</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">&quot;Binary Files&quot;</span>).setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args.size != <span class="number">1</span>) &#123;</span><br><span class="line">      println(<span class="string">&quot;请输入正确的文件或目录路径&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">analyseFileContent</span></span>(filePath: <span class="type">String</span>): <span class="type">RDD</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">      <span class="keyword">val</span> data = sc.binaryRecords(filePath, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">val</span> records = data.flatMap(x =&gt; x.flatMap(x =&gt; toBinaryStr(byteToShort(x)).toCharArray))</span><br><span class="line">      <span class="keyword">val</span> mappedWithKey = records.map(i =&gt; <span class="keyword">if</span> (i == &#x27;<span class="number">0</span>&#x27;) (&#x27;<span class="number">0</span>&#x27;, <span class="number">1</span>L) <span class="keyword">else</span> (&#x27;<span class="number">1</span>&#x27;, <span class="number">1</span>L))</span><br><span class="line">      <span class="keyword">val</span> result = mappedWithKey.reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> sum = result.map(_._2).sum()</span><br><span class="line">      result.map &#123; <span class="keyword">case</span> (key, count) =&gt; formatOutput(key, count, sum)&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> path = args.head</span><br><span class="line">    <span class="keyword">val</span> filePaths = fetchFiles(path)</span><br><span class="line">    filePaths.par.foreach &#123; filePath =&gt;</span><br><span class="line">      <span class="keyword">val</span> outputs = analyseFileContent(filePath)</span><br><span class="line">      printOutputs(outputs)</span><br><span class="line">      saveOutputs(filePath, outputs)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">byteToShort</span></span>(b: <span class="type">Byte</span>): <span class="type">Short</span> =</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>) (b + <span class="number">256</span>).toShort <span class="keyword">else</span> b.toShort</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">toBinaryStr</span></span>(i: <span class="type">Short</span>, digits: <span class="type">Int</span> = <span class="number">8</span>): <span class="type">String</span> =</span><br><span class="line">    <span class="type">String</span>.format(<span class="string">&quot;%&quot;</span> + digits + <span class="string">&quot;s&quot;</span>, i.toBinaryString).replace(&#x27; &#x27;, &#x27;<span class="number">0</span>&#x27;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">printOutputs</span></span>(outputs: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    outputs.foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">saveOutputs</span></span>(filePath: <span class="type">String</span>, outputs: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> resultDir = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;result&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> (!resultDir.exists()) resultDir.mkdir()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resultFile = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;result/&quot;</span> + getFileNameWithExtension(filePath) + <span class="string">&quot;.output&quot;</span>)</span><br><span class="line">    outputs.foreach(line =&gt; <span class="type">GoogleFiles</span>.append(line + <span class="string">&quot;\n&quot;</span>, resultFile, <span class="type">Charsets</span>.<span class="type">UTF_8</span>))</span><br><span class="line">    <span class="type">GoogleFiles</span>.append(<span class="string">s&quot;统计于：<span class="subst">$&#123;formatLoggingTime()&#125;</span>\n\n&quot;</span>, resultFile, <span class="type">Charsets</span>.<span class="type">UTF_8</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">formatLoggingTime</span></span>(): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> formatter = <span class="keyword">new</span> <span class="type">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span><br><span class="line">    formatter.format(<span class="type">Calendar</span>.getInstance().getTime)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getFileNameWithExtension</span></span>(filePath: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    filePath.substring(filePath.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">fetchFiles</span></span>(path: <span class="type">String</span>): <span class="type">List</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> fileOrDirectory = <span class="keyword">new</span> <span class="type">File</span>(path)</span><br><span class="line">    fileOrDirectory.isFile <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">true</span> =&gt; <span class="type">List</span>(path)</span><br><span class="line">      <span class="keyword">case</span> <span class="literal">false</span> =&gt; fileOrDirectory.listFiles().filter(_.isFile).map(_.getPath).toList</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">formatPercent</span></span>(number: <span class="type">Double</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> percent = <span class="string">&quot;%1.2f&quot;</span> format number * <span class="number">100</span></span><br><span class="line">    <span class="string">s&quot;<span class="subst">$&#123;percent&#125;</span>%&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">formatOutput</span></span>(key: <span class="type">Char</span>, count: <span class="type">Long</span>, sum: <span class="type">Double</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="string">s&quot;字符<span class="subst">$&#123;key&#125;</span>的数量为<span class="subst">$&#123;count&#125;</span>, 占比为<span class="subst">$&#123;formatPercent(count/sum)&#125;</span>&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h3><p>通过sbt对代码进行编译、打包后，生成jar文件。然后在spark主目录下运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$SPARK_HOME/bin/spark-submit --class bigdata.demo.Main --master spark://&lt;ip&gt;  $SPARK_HOME/jars/binaryfilesstastistics_2.11-1.0.jar file:///share/spark-2.2.0-bin-hadoop2.7/derby.log</span><br></pre></td></tr></table></figure>

<p>最后的参数”file:///share/spark-2.2.0-bin-hadoop2.7/derby.log”就是main函数接收的参数，即要分析的文件目录。如果为本地目录，需要指定文件协议<code>file://</code>，如果为HDFS目录，则指定协议<code>hdfs://</code>。</p>
<h3 id="遇到的坑-1"><a href="#遇到的坑-1" class="headerlink" title="遇到的坑"></a>遇到的坑</h3><h4 id="byte类型的值"><a href="#byte类型的值" class="headerlink" title="byte类型的值"></a>byte类型的值</h4><p>在Scala中，Byte类型为8位有符号补码整数。数值区间为 -128 到 127。倘若二进制值为<code>11111111</code>，通过SparkContext的binaryRecords()方法读进Byte数据后，其值为-1，而非255。原因就是补码的缘故。如果十进制为128，转换为Byte类型后，值为-128。</p>
<p>而对于-1，如果执行toBinaryString()，则得到的字符串为”11111111111111111111111111111111”，而非我们期待的”11111111”。如下图所示：</p>
<img src="/read-binary-file-using-spark/to-binary-string.png" class="">

<p>针对八位的二进制数值，可以编写一个方法，将Byte类型转为Short类型，然后再调用toBinaryString()方法转换为对应的二进制字符串。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">byteToShort</span></span>(b: <span class="type">Byte</span>): <span class="type">Short</span> =</span><br><span class="line">  <span class="keyword">if</span> (b &lt; <span class="number">0</span>) (b + <span class="number">256</span>).toShort <span class="keyword">else</span> b.toShort</span><br></pre></td></tr></table></figure>

<p>而对于不足八位的二进制数值，如果直接调用toBinaryString()方法，则二进制字符串将不到八位。可以利用String的format进行格式化：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">toBinaryStr</span></span>(i: <span class="type">Short</span>, digits: <span class="type">Int</span> = <span class="number">8</span>): <span class="type">String</span> =</span><br><span class="line">  <span class="type">String</span>.format(<span class="string">&quot;%&quot;</span> + digits + <span class="string">&quot;s&quot;</span>, i.toBinaryString).replace(&#x27; &#x27;, &#x27;<span class="number">0</span>&#x27;)</span><br></pre></td></tr></table></figure>

<p>当然，可以将这两个方法定义为Byte与Short的隐式方法。</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Spark</tag>
        <tag>Scala</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>《解构领域驱动设计》推荐序</title>
    <url>/recommendation-of-my-book/</url>
    <content><![CDATA[<p>我的书《<a href="https://www.epubit.com/bookDetails?id=UB77d68d84212a6&typeName=">解构领域驱动设计</a>》即将由人民邮电出版社异步社区出版，目前已经可以在出版社的官网预定，很快就能够在电商平台上架开售。历时近四年的写作委实不易，当然，也离不开各位朋友的支持与帮助。正如我在本书前言中提到的“感谢京东周吉鑫、AWS高翊凯（Kim Kao）、腾讯王立与技术专家于君泽（花名“右军”）诸兄的抬爱，他们不仅拨冗为我的著作作序，也给了我许多好的建议与指点，提升了本书的整体质量。”</p>
<p>为此，在这里我抢先发布这些朋友为本书写的推荐序，以飨读者。</p>
<span id="more"></span>



<h3 id="推荐序一"><a href="#推荐序一" class="headerlink" title="推荐序一"></a>推荐序一</h3><p>本书的读者是幸运的！我运用领域驱动设计磕磕绊绊十余年，读过本书的内容之后，深感它是一本可与《领域驱动设计》和《实现领域驱动设计》互补的书，它在领域驱动设计落地方面尤其出色。</p>
<p>2007年，我阅读了Eric Evans的《领域驱动设计》。2014年，我又阅读了由Eric Evans作序、Vaughn Vernon编写的《实现领域驱动设计》，后来，我有幸认识了该书的审校者张逸老师，和张逸老师的沟通令我受益匪浅。虽然知道张逸老师在领域驱动设计方面功力颇深，但在拜读了张逸老师的这本书的初稿之后，我依然非常吃惊，觉得张逸老师真正做到了将领域驱动设计知识融会贯通。张逸老师在这本书中对限界上下文、聚合、领域服务概念进行了深刻阐述，并通过案例的运用让研发人员在使用这些概念时不再迷惑。他还在参透了六边形整洁架构、架构与分层架构的本质后，大胆突破，提出了精简的菱形对称架构，从架构角度让领域驱动设计更加容易理解和落地，并通过服务驱动设计，以任务分解的方式让测试驱动开发和领域驱动设计无缝结合，让设计可以推导验证，让开发人员可以自然而然写出不再“贫血”的代码。</p>
<p>本书不仅具备国内作者难得的宽阔视野和理论深度，而且有丰富的案例与实战经验总结，其中一些总结还细心地标明了出处，如关于过度设计和设计不足的权衡案例后面的总结：“具有实证主义态度的设计理念是面对不可预测的变化时，应首先保证方案的简单性；当变化真正发生时，可以通过诸如提炼接口（extract interface）[6]341的重构手法，满足解析逻辑的扩展。”</p>
<p>本书中有很多这样的总结，因此阅读这本书相当于吸收了很多本书的精华。记得张逸老师曾向我推荐过Robert Martin的《架构整洁之道》，当时我告诉他那是我2019年读的最好的一本书，而今天，我要告诉他，他的这本书是我2020年读到的最好的一本书！</p>
<p><strong>作者：</strong>周吉鑫，京东资深业务架构师，2011年起至今在京东公司进行物流系统的建模、分析和设计工作，主要工作包括京东亚洲一号WMS、WMS3.0～WMS6.0系统、云仓、国际化物流系统、无人仓系统等的建模、分析和设计。</p>
<h3 id="推荐序二"><a href="#推荐序二" class="headerlink" title="推荐序二"></a>推荐序二</h3><p>2019年的冬天，我从台湾赶往上海，为公司内的团队进行领域驱动设计（DDD）与事件风暴的培训，在完成了培训工作后马不停蹄地赶往北京，只为了与领域驱动设计社区的伙伴王威、张逸相聚。在2019年领域驱动设计中国峰会（2019 DDD China Conference）上，我们分享了领域驱动设计台湾社区对领域驱动设计的理解与实践方式。是日恰巧迎来了北京的初雪，趁着此情此景，一行人把酒言欢，正是“初雪纷飞夜访，奇闻经历共话，点拨思绪再整，把酒笑谈学涯”。</p>
<p>当时我们探讨了一个很重要的话题：很多人在学习领域驱动设计时，往往初探不得其窍门，而工作背景不同的人看待这一方法又往往仅侧重于一部分战略指导，或者只关注战略设计实践的代码层级，但不管侧重于哪一部分，都会让这种经典的指导协作与实现业务战略目标的软件工程方法略显失重，无法尽得其精要。</p>
<p>2003年，Eric Evans的著作《领域驱动设计》从欧洲席卷而来，乃至于全球的软件工作者都渴望从他提出的领域建模方法中得到帮助，但十多年来，Eric Evans本人经常被问到：“有没有一种方法可以很好地指引我们进行业务建模？什么样的建模才是合理的，或者说可以一次就成其事达其标？”Eric Evans本人在很多公开场合都提过，其实这一切都依然需要依赖一些经验和持续积累的领域知识。对于这样需要由高度经验法则施行的领域驱动设计，一般的软件架构师、程序员以及相关的从业人员往往望而却步，个中原因便是始终少了一个系统性的指引，将业务流程梳理的产物对接到后续的程序开发中，实现从业务架构到系统架构的良好实践，使常见的业务与技术之间的隔阂降到最低。</p>
<p>对于这本书，我首先要向张逸老师表达感激之情，然后祝贺本书的读者！感激张逸老师花了多年时间梳理并融合了其在软件设计领域的实务经验，将战略推进到战术过程中佚失的部分，并通过领域驱动设计统一过程（DDDUP），使领域驱动设计方法更加完备。祝贺本书的读者在拿到本书时就几乎综览了过去20多年的软件开发历程所提到的诸多重要元素。本书结合大量实务案例来探讨为何需要战略指导、为何需要以固有的战术设计范式指导实践，并辅以领域驱动设计统一过程的指导原则，指引读者逐步落地。本书不单纯以领域驱动设计来讲老生常谈的方法，而更像一位坐在你身边的资深架构师，与你结对进行系统架构设计，一起探索软件架构设计的奥秘。</p>
<p>如果读者对软件工程有极大的热情，渴望更好地理解、实施领域驱动设计，解决复杂的业务问题，就千万别错过这本书。但我最真切地提醒读者，在购书之后务必阅读与身体力行兼具。行之才是学之。</p>
<p><strong>作者：</strong>高翊凯（Kim Kao），Amazon Web Services（AWS）资深解决方案架构师，领域驱动设计台湾社区共同发起人之一。他的专长是软件系统设计，并致力于无服务器服务推广，推动企业透过领域驱动设计与便捷的云端服务打造更适切的建构系统方案，解决实际的业务问题。</p>
<h3 id="推荐序三"><a href="#推荐序三" class="headerlink" title="推荐序三"></a>推荐序三</h3><p>自2003年Eric Evans的著作《领域驱动设计》面世以来，领域驱动设计（DDD）相关的实践书籍并不多，整体的理论发展速度并不快，以至于很长一段时间，开发团队的实践过程总是磕磕绊绊，这让他们觉得领域驱动设计的门槛很高，甚至有人怀疑领域驱动设计是否是一种足够成熟与体系化的方法论。根据我个人的经验，我确实发现其中不少问题仍旧没有什么经典论著能完全覆盖与讨论。看过这本书的内容后，我的感受是：无论是理论还是实践，领域驱动设计知识体系确实都已经成熟了，与国内外的经典领域驱动设计著作相比，这本书包含了更多案例，覆盖了更多问题场景，回答了更多人们不常考虑的细节。本书作者不仅继承了各类经典著作的精华，更难得的是他能够在实践中深入细节进行推敲，批判与改良一些不成熟的理论，甚至有了自己的理论创新，例如，提出了菱形架构概念、对强一致事务与聚合的边界的一致性提出挑战……特别是，他还创造性地提出了领域驱动设计统一过程（DDDUP），很好地总结了完整的领域驱动设计知识体系。</p>
<p>有些读者可能不理解本书为什么这么厚。网络上有大量碎片式的领域驱动设计文章，一个案例只有几页，市场上也有不少领域驱动设计方面的培训，两天就能帮我们“搞定”领域驱动设计，领域驱动设计的知识体系似乎并没有我们想象的那么丰满。但事实上，这本书将告诉我们，领域驱动设计背后完整的知识体系并没有那么简单，我们需要掌握的是从业务到技术的整个技能栈。我们必须接受的事实是：领域驱动设计是有一定学习曲线的。所以，不要拒绝一本足够厚的书，这恰恰是其价值的体现。这本书的各个部分不是泛泛而谈，而是通过展开细节，层层推进，帮助读者建立扎实的理论基础，并通过大量翔实的案例，让读者能灵活运用理论知识。对于初学者，本书尽可能详尽地把问题展开、讲透；对于有一定经验的老手，本书也有更多有深度的细节思考和理论拓展。相信这本书会成为国内领域驱动设计技术书籍的一个标杆。</p>
<p>张逸先生是我国最早一批接触并实践领域驱动设计的先行者，经验极其丰富。本书不仅是他在该领域十多年实战经验的沉淀和升华，也是他多年教学经验的总结和提炼。他曾经为很多行业巨头提供过咨询服务，是国内在领域驱动设计方面影响力最大的布道者之一。看到张逸先生的书终于要出版了，我感到非常高兴，我们太需要这样一本既有理论升华又如此接地气的大作了。</p>
<p>我熟读了几乎所有的领域驱动设计经典著作，但仍旧从张逸先生的书中获益良多。我认为本书的广度、深度与创新性已经可以与该领域的国际经典著作看齐，这也是国人的骄傲。本书的出版是领域驱动设计理论界的一个重要事件，是对软件行业在领域驱动设计方面的巨大贡献，必将降低整个行业掌握领域驱动设计的门槛，加速领域驱动设计的普及。能为这本书作序是我的荣幸，同为领域驱动设计布道者，我将向我的同行强烈推荐本书。这本书也是我本人将来开展工作的重要理论指导。</p>
<p><strong>作者：</strong>王立，微信支付12级专家工程师、技术领导者。他从2006年起开始研究领域驱动设计，曾经在阿里巴巴、神州数码、网宿科技等上市公司担任技术专家与技术经理，现在负责微信支付技术团队在领域建模、分析和设计方面的实践指导。</p>
<h3 id="推荐序四"><a href="#推荐序四" class="headerlink" title="推荐序四"></a>推荐序四</h3><p>领域驱动设计方面的书现在不是太多，而是太少。想必不少读者受过《领域驱动设计》和《实现领域驱动设计》两本书的启蒙。本书是我特别推荐的领域驱动设计方面的技术书，为何特别推荐，且听下文。</p>
<p>大约在2007年，我第一次读《领域驱动设计》一书时，如读天书，主要记住了类似实体、值对象、工厂、仓储等概念。近年来，随着微服务的流行，国内对领域驱动设计的研究和实践愈发多了起来。</p>
<p>我对领域驱动设计的态度是：相对于战术设计，应该更看重战略设计。数年前，我醉心于研究领域模型。领域是业务变化中接近不变性的部分，业务包括领域对象、业务逻辑和界面交互3个层次，其中领域对象是最稳定的。2015年我组织领域建模工作坊活动时，用的就是《分析模式：可复用的对象模型》一书中的一个需求场景。2016年我写了一篇文章，强调了问题域和解决方案域的区分。张逸兄在GitChat上的两个连载专栏历时两年，创作数十万字，内容之丰满，关键节点探讨之深刻，于我之所见，浩瀚领域专家，无出其右者。虽大家都各自奔忙，仅偶有线上问候或者面聊，但皆有受益。本书的成书过程尤其令人钦佩，张逸兄不是直接将专栏调整成书，而是重新组织架构，提炼出自己的方法体系，可以说是推陈出新，自成一家。</p>
<p>张逸兄敢言人之所未言。领域驱动设计有四大不足：领域驱动设计缺乏规范的统一过程，领域驱动设计缺乏与之匹配的需求管理体系，领域驱动设计缺乏规范化的、具有指导意义的架构体系，领域驱动设计的领域建模方法缺乏固化的指导方法。他创造性地提出领域驱动设计统一过程，虽然此方法有无调整空间，一定是要在不断实践中去检验的，但单就他的这份胆识和专业，足以让人钦佩。</p>
<p>如果说非要给本书提一点儿意见的话，我觉得本书有点儿厚了。我认为一本好书也要兼顾读者的情况，最好能达到让读者快速上手的学习效果。但张逸兄坚持让本书以集大成者的面貌出现，洋洋洒洒数十万字，力求让其成为一本值得珍藏的技术书。</p>
<p>凡学习，须循序渐进。我建议读者把面向对象的分析（object-oriented analysis，OOA）、面向对象的设计（object-oriented design，OOD）、统一建模语言（unified modeling language，UML）、模式等相关知识作为阅读本书的前序内容。《领域驱动设计》一书也特别提到了“复杂性”，有一定的软件从业经验的朋友对“复杂性”更感同身受。</p>
<p>每个人心中都有一个哈姆雷特，每一位读者都可以登临领域驱动设计的阁楼，从不同的角度或俯瞰、或仰望、或凝视。我之所得：于道，是对限界上下文特别有共鸣的部分，以及问题空间（域）与解空间（域）；于术，是作者提出的领域驱动设计的“三大纪律八项注意”，可作为团队执行作战任务的纪律规范。其中，“三大纪律”是实施领域驱动设计的准则：</p>
<ul>
<li><p>领域专家与开发团队在一起工作；</p>
</li>
<li><p>领域模型必须遵循统一语言；</p>
</li>
<li><p>时刻坚守两重分析边界与四重设计边界。</p>
</li>
</ul>
<p>信笔至此，兹为张兄推荐。本书精彩之处甚多，留待读者去发现。祝阅读愉快！</p>
<p><strong>作者：</strong>于君泽（右军），技术专家，《深入分布式缓存：从原理到实践》和《程序员的三门课：技术精进、架构修炼、管理探秘》联合作者。</p>
]]></content>
      <categories>
        <category>Writing</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title>2018，重新开始</title>
    <url>/restart-from-2018/</url>
    <content><![CDATA[<p>我从2004年开始写技术博客。最初一直是在博客园，笔耕不辍，几年积累下来也有不少文章。最初我的关注点主要在于软件设计，尤其是与面向对象设计和设计模式有关的，在园子里也颇受关注。2006年，我将这些文章整理成册，名为“设计之道”，开源出来放在网上，似乎引起不少人的关注和追捧，其中就有电子工业出版社的博文视点编辑。2007年，在博客园dudu的帮助下，我在博文视点出版了我的第一本书《软件设计精要与模式》，这也是至今我出版的唯一一本自己的著作。本书在2009年出版了第二版，之后，就没有之后了。</p>
<p>因为我做的项目慢慢开始脱离.NET圈子，兴趣点也放在Java社区，我逐渐与微软的.NET阵营渐行渐远。不再继续申请连续五年的微软MVP，很少关注.NET技术，于是自己觉得应该与当时专注于.NET技术的博客园告别了。</p>
<p>其间自己效仿技术网红的做法，申请了域名，开起了个人网站。有了小小富贵，就想独立成家立业，典型的小市民。因为少了整个博客园这个圈子，个人网站的访问几乎称得上是“门前冷落鞍马稀”了。那时候没有GitHub，没有许多特别自由的博客软件，没有markdown，自己小本经营着个人网站，慢慢心也淡了。博客仍然继续写，因为后来需要域名备注的缘故，个人网站终于惨淡收场。待到Github page出现，就赶紧惊喜地将博客搬迁到github上。</p>
<p>当时我使用了jekyll制作了博客，自己修改了样式，二次开发了一些小程序，例如通过ruby程序自动将发布的博客同步到新浪微博上。我寻找到了geek的感觉，因而乐此不疲。然而我这人总有些喜新厌旧，慢慢的，博客虽然照常这样不温不火地写着，却寻找不回最初的乐趣了。直到我发现farbox。</p>
<span id="more"></span>

<p>farbox这种博客写作方式完全颠覆了传统，然而本质其实与github没有太大区别。但是操作更简单。farbox提供了非常棒的markdown编辑器，且一旦编辑即可发布博客，颇有几分当初windows Live Writer的感觉。且编辑器针对markdown提供了很棒的所见即所得功能，使得博客写作变得如此easy。</p>
<p>我打算长期驻扎在farbox上了，即使每天的访问量依旧单薄，但我深信只要自己深耕下去，总会有收获。然而，farbox通过dropbox同步文件的技术选型其实从一开始就埋下了地雷。当翻墙变得越来越不容易时，dropbox就变成了我难以逾越的天堑，每次同步博客还得不停地连接各种VPN。烦恼啊！</p>
<p>其时，我也创建了我个人的微信公众号<strong>「逸言」</strong>。其实我很讨厌微信公众号这种形式，它除了可以非常方便地提供订阅之外，增加了更好的分享渠道更多受众之外，一无是处。排版麻烦，对代码显示极不友好，也不利于文章的收藏。因此从最初的0个用户到目前近3000用户，我始终惫懒的更新着，不死不活。</p>
<p>终于，我再也无法忍受farbox的翻墙之苦了，而时间也走向了2018年。我认为我应该有一个新的开始，我需要向过去做一个告别。选择良久，我还是决定回归到github，而建站的软件则选择基于NodeJS的hexo。我还计划申请一个个人域名。github支持域名绑定，而hexo提供的建博客功能也异常地简单。</p>
<p>我新开一个博客，挥挥手与过去告别。</p>
<p>这个告别是彻底的告别。以前每当我新开一个博客，总是舍不得把过去丢弃，因而总是不厌其烦地把过去的文章一篇一篇迁移到新博客上。而在这个博客上，我打算以全新的姿态亮相。对于博客，我打算以一种更轻松更写意的态度来面对。因此，三两句话的闲谈、碎片般的思想、过去的心得体会、走过的足迹、文法严谨的大块文章，可能都会呈现在这个博客上，形成一种斑斓的姿态。是为博客的站名——<strong>「斑斓」</strong>。</p>
<p>至于过去，我正在利用WizNote整理那些还值得一读的旧文章，分门别类，最后分享到GitBook上。从2007年的第一次整理，至今刚好十年，也许这本开源的小册子可以命名为《我的十年》。Btw，WizNote即为知笔记真的是个好东西，我热情地给他打电话呢。</p>
]]></content>
      <categories>
        <category>Thinking</category>
      </categories>
      <tags>
        <tag>Thinking</tag>
      </tags>
  </entry>
  <entry>
    <title>菱形对称架构</title>
    <url>/rhombic-symmetric-architecture/</url>
    <content><![CDATA[<img src="/rhombic-symmetric-architecture/cover.jpeg" class="">

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实施领域驱动设计的过程中，限界上下文（Bounded Context）扮演了关键角色：它既是维护领域模型完整性与一致性的重要边界，又是系统架构的重要组成部分。随着社区对限界上下文的重视，越来越多的人开始尝试将更多的架构实践与限界上下文融合在一起，创造出符合领域驱动设计的架构模式。</p>
<p>Eric Evans 在领域驱动设计中引入了分层架构（Layered Architecture），目的是希望能够分离领域，这意味着该模式本身是作用在整个系统层次。Vaughn Vernon 在《实现领域驱动设计》一书中，将 Alistair Cockburn 提出的六边形架构（Haxagonal Architecture）引入到领域驱动设计中，并将其与限界上下文结合在一起，清晰地体现了它内部的视图。这一模式的引入，实际上代表着限界上下文在架构中的核心地位。</p>
<span id="more"></span>

<p>限界上下文改变了系统架构的逻辑视图，领域层的抽取则意味着领域对设计的驱动力，二者的结合可以形成一种新的架构风格，我将其称之为“<strong>领域驱动架构（Domain Driven Architecture）</strong>”。该架构风格建立了以领域为核心驱动力，以整洁架构为指导原则，将整个系统分解为多个限界上下文，并通过上下文映射（Context Map）表现限界上下文之间的协作关系以及系统与外部环境之间关系。</p>
<p>这一架构风格将整个系统的架构分为两个层次：</p>
<ul>
<li>系统层次</li>
<li>领域层次</li>
</ul>
<p><strong>系统层次的架构</strong> 以限界上下文为核心，从纵向维度根据业务能力纵向切分形成限界上下文，然后从横向维度提炼出由限界上下文组成的价值层（Value-Added Layer）。</p>
<img src="/rhombic-symmetric-architecture/01.png" class="">

<p><strong>领域层次的架构</strong> 针对限界上下文内部以领域为核心进行关注点分解，形成由内部领域模型与外部网关组成的内外分层架构。</p>
<p>本文提出的<strong>菱形对称架构（Rhombic Symmetric Architecture）</strong> 主要针对领域层次的架构，借鉴了六边形架构、分层架构、整洁架构的知识，并结合了领域驱动设计的元模型，使其能够更好地运用到限界上下文的架构设计中。因此，本文会依次介绍六边形架构、整洁架构与分层架构，由此再引出我定义的菱形对称架构。</p>
<p><strong>说明：</strong>由于菱形又可以表示为<strong>diamond</strong>，故而该架构模式也可以称之为“钻石架构”，简称 diamond。我在 GitHub 上建立了名为<a href="https://github.com/agiledon/diamond">diamond</a>的代码库，提供了本文案例的 Demo 代码，也清晰地展现了限界上下文的代码结构。</p>
<p>本文全稿发表于<a href="https://gitbook.cn/new/gitchat/activity/5e55150b238b2a7efa28c297">GitChat</a>，通过扫码付费后可以阅读全文，这里发布的是这篇文章的部分内容。</p>
<h2 id="架构模式的演进"><a href="#架构模式的演进" class="headerlink" title="架构模式的演进"></a>架构模式的演进</h2><h3 id="六边形架构"><a href="#六边形架构" class="headerlink" title="六边形架构"></a>六边形架构</h3><p>六边形架构（Hexagonal Architecture）又被称之为端口适配器（Port and Adapter），由 Alistair Cockburn 提出，他的定义为：“无论是被用户、程序、还是自动化测试或批处理脚本驱动，应用程序（Application）都能一视同仁地对待，最终使得应用程序能独立于运行时设备和数据库进行开发与测试。”</p>
<p>包含了领域逻辑的应用程序放在六边形的边界内，它与外界的通信只能通过端口与适配器进行。端口存在两个方向：入口和出口。与之相连的适配器自然也存在两种适配器：入口适配器（Inbound Adapter，又可称为 Driving Adapter）和出口适配器（Outbound Adapter，又可称为 Driven Adaptor）。入口适配器负责处理系统外部发送的请求，也就是驱动应用程序运行的用户、程序、自动化测试或批处理脚本会向入口适配器发起请求，适配器将该请求适配为符合内部应用程序执行的输入格式，转交给端口，再由端口调用应用程序。出口适配器负责接收内部应用程序通过出口端口传递的请求，对其进行适配后，向位于外部的运行时设备和数据库发起请求。</p>
<p>显然，从内外边界的视角观察端口与适配器的协作，整个过程如下图所示：</p>
<img src="/rhombic-symmetric-architecture/02.png" class="">

<p>在 Cockburn 对六边形架构的初始定义中，应用程序处于六边形边界之内，它封装了支持业务功能的领域逻辑。入口端口与出口端口放在六边形边界之上，前者负责接收外部的入口适配器转换过来的请求，后者负责发送应用程序的请求给外部的出口适配器，由此可以勾勒出一个清晰的六边形：</p>
<img src="/rhombic-symmetric-architecture/03.png" class="">
<p>我们说限界上下文是在特定知识语境下的业务能力的体现，这一业务能力固然以领域模型为核心，却必须通过与外部环境的协作方可支持其能力的实现，因此限界上下文的边界实则包含了对驱动它运行的入口请求的适配与响应，也包含了对外部设备和数据库的访问。若要将限界上下文与六边形架构结合起来，就需要将入口适配器和出口适配器放在限界上下文的边界之内，从而构成一个外部的六边形：</p>
<img src="/rhombic-symmetric-architecture/04.png" class="">

<p>六边形架构清晰地勾勒出限界上下文的两个边界：</p>
<ul>
<li>外部边界：通过外部六边形展现，是限界上下文的业务边界，当然，同时也可能是限界上下文的工作边界与应用边界。我将此六边形称之为“应用六边形”。</li>
<li>内部边界：通过内部六边形将领域单独抽离出来，隔离了业务复杂度与技术复杂度。我将此六边形称之为“领域六边形”。</li>
</ul>
<p>以预定机票场景为例，用户通过浏览器访问订票网站，向订票系统发起订票请求。根据六边形架构的规定，前端 UI 位于应用六边形之外，属于驱动应用程序运行的起因。订票请求发送给以 RESTful 契约定义的资源服务<code>ReservationResource</code>，它作为入口适配器，介于应用六边形与领域六边形的边界之内。<code>ReservationResource</code>在接收到以 JSON 格式传递的前端请求后，将其转换（反序列化）为入口端口<code>ReservationAppService</code>需要的请求对象。</p>
<p>入口端口为应用服务，位于领域六边形的边界之上。当它在接收到入口适配器转换后的请求对象后，调用位于领域六边形边界内的领域服务<code>TicketReservation</code>，执行领域逻辑。</p>
<p>在执行订票的领域逻辑时，需要向数据库添加一条订票记录。这时，位于领域六边形边界内的领域模型对象会调用出口端口<code>ReservationRepository</code>。出口端口为资源库，位于领域六边形的边界之上，定义为接口，真正访问数据库的逻辑则由介于应用六边形与领域六边形边界内的出口适配器<code>ReservationRepositoryAdapter</code>实现。该实现访问了数据库，将端口发送过来的插入订票记录的请求转换为数据库能够接收的消息，执行插入操作。</p>
<p>该领域场景在六边形架构中的体现为：</p>
<img src="/rhombic-symmetric-architecture/05.png" class="">

<p><strong>六边形架构中的端口是解耦的关键。</strong> 入口端口体现了“封装”的思想，它既隔离了外部请求转换所必须的技术实现，如 REST 服务的反序列化机制与 HTTP 请求路由等基础设施功能，又避免了领域模型向外的泄露，因为端口公开的方法已经抹掉了领域模型的信息。出口端口则体现了“抽象”的思想，它通常需要定义为抽象接口，不包含任何具体的访问外部设备和数据库的实现。</p>
<p>显然，入口端口抵御了外部请求可能对当前限界上下文造成的侵蚀，因此，入口适配器与入口端口之间的关系是一个<strong>依赖调用关系</strong>；出口端口隔离了领域逻辑对技术实现以及外部框架或环境的依赖，因此，出口适配器与出口端口之间的关系是一个<strong>接口实现关系</strong>。二者的结合共同为限界上下文两个边界层次的松散耦合提供助力，最终保证了限界上下文的自治能力。</p>
<h2 id="菱形对称架构"><a href="#菱形对称架构" class="headerlink" title="菱形对称架构"></a>菱形对称架构</h2><h3 id="菱形对称架构的组成"><a href="#菱形对称架构的组成" class="headerlink" title="菱形对称架构的组成"></a>菱形对称架构的组成</h3><p>作用于限界上下文的菱形对称架构从领域驱动设计分层架构与六边形架构中汲取了营养，通过对它们的融合形成了以领域为轴心的内外分层对称结构。</p>
<img src="/rhombic-symmetric-architecture/06.png" class="">

<p>内部以领域层的领域模型为主，外部的网关层则根据方向划分为北向网关与南向网关。通过该架构，可清晰说明整个限界上下文的组成：</p>
<ul>
<li>北向网关的远程网关</li>
<li>北向网关的本地网关</li>
<li>领域层的领域模型</li>
<li>南向网关的端口抽象</li>
<li>南向网关的适配器实现</li>
</ul>
<p>限界上下文以领域模型为核心向南北方向对称发散，从而在边界内形成清晰的逻辑层次。很明显，前端 UI 并未包含在限界上下文的边界之内。每个组成元素之间的协作关系表现了清晰直观的自北向南的调用关系，仍以订票服务场景为例，参与该场景的各个类在菱形对称架构下的位置与协作关系如下图所示：</p>
<img src="/rhombic-symmetric-architecture/07.png" class="">

<p><strong>说明：</strong> 本案例的样例代码可以从 GitHub 上的<a href="https://github.com/agiledon/diamond">diamond</a>库获得。扫描下图的二维码可以付费阅读。</p>
<img src="/rhombic-symmetric-architecture/gitchat.jpeg" class="">

<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>Eric Evans《领域驱动设计》赵俐等译 人民邮电出版社</li>
<li>Robert C. Martin 《敏捷软件开发原则、模式与实践》注释版 人民邮电出版社</li>
<li>Robert C. Martin 《架构整洁之道》，电子工业出版社 孙宇聪译</li>
<li>Neal Ford, Rebecca Parsons, Patrick Kua 《演进式架构》 周训杰译 人民邮电出版社</li>
<li>Jim Highsmith &amp; Neal Ford “The CxO Guide to Microservices”  <a href="https://www.thoughtworks.com/cn/insights/blog/cxo-guide-microservices">https://www.thoughtworks.com/cn/insights/blog/cxo-guide-microservices</a></li>
<li>Vaughn Vernon 《实现领域驱动设计》 滕云译 张逸审校  电子工业出版社</li>
<li>周宇刚《端口和适配器架构——DDD 好帮手》 <a href="https://insights.thoughtworks.cn/port-and-adapter-architecture/">https://insights.thoughtworks.cn/port-and-adapter-architecture/</a></li>
<li> Erwan Alliaume, Sébastien Roccaserra, “Hexagonal Architecture: three principles and an implementation example” <a href="https://blog.octo.com/en/hexagonal-architecture-three-principles-and-an-implementation-example/">https://blog.octo.com/en/hexagonal-architecture-three-principles-and-an-implementation-example/</a></li>
<li>Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides 《设计模式》 李英军等译  机械工业出版社</li>
<li>Martin Fowler “Inversion of Control Containers and the Dependency Injection pattern” <a href="https://martinfowler.com/articles/injection.html">https://martinfowler.com/articles/injection.html</a></li>
<li>Frank Buschmann, Regine Meunier, Hans Rohnert, Peter Sommerland, Michael Stal 著 《面向模式的软件体系结构 卷 1：模式系统》 贲可荣等译  机械工业出版社</li>
<li>Scott Millett, Nick Tune 《领域驱动设计模式、原理与实践》 蒲成译 清华大学出版社</li>
<li>Martin Fowler 《企业应用架构模式》影印版 中国电力出版社</li>
<li>张逸 《领域驱动设计实践》（战略篇） GitChat <a href="https://gitbook.cn/gitchat/column/5b3235082ab5224deb750e02">https://gitbook.cn/gitchat/column/5b3235082ab5224deb750e02</a></li>
</ul>
<hr>
<p><strong>封面题图</strong>为张子瞻小朋友的绘画。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Architecture</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>领域模型在交流中扮演的角色</title>
    <url>/role-of-domain-model-in-communication/</url>
    <content><![CDATA[<img src="/role-of-domain-model-in-communication/dddclub.jpeg" class="">

<p>GitChat《领域驱动战略设计》作者，《软件设计精要与模式》作者，《架构之美》评注者，公众号@逸言 架构编码实践者张逸的知识星球。 </p>
<ol>
<li>每周一篇技术长文分享，主题包括领域驱动设计，面向对象设计，函数式编程，响应式编程，分布式与微服务架构，大数据，Java语言，Scala语言，职业规划，敏捷管理与技术实践。 </li>
<li>开展以上相关主题的交流与问题答疑，并鼓励读者分享好文。优选文章与积极提问者将获得技术书籍赠送，包括我的签名书籍，我的GitChat书籍免费阅读码，红包等小礼品。 </li>
<li>不定期提供免费线上微课，内容涵盖上述主题。 </li>
</ol>
<p>欢迎大家到我的星球做客，更重要的是让大家能看到你的真知灼见。本文即来自我在知识星球《DDD高端俱乐部》的回答。</p>
<p><strong>问题：</strong>我对于领域模型如何表示始终还不太明白。按照Evans书里的说法，代码应当是领域模型的主要部分，文档、图表作为补充。另外一方面，领域模型应当是所有参与者都能够理解的，而我觉得用户不太可能去理解代码。</p>
<p>比如以Evans书里举的，可以超载10%这一点，书里是通过一个Strategy模式来表达这个知识，从程序员的角度看很清晰了，但是从用户的角度看，还是不太能够明白吧。</p>
<p>请教张老师如何看待这个问题？</p>
<span id="more"></span>

<p><strong>回答</strong>：其实从模型的角度看，有几个层次，Eric说的是模型驱动模型。重点是模型。这几个层次包括: </p>
<ul>
<li>现实模型即问题域</li>
<li>领域模型</li>
<li>设计模型</li>
<li>代码模型</li>
</ul>
<p>实际上领域模型是搭建现实模型需求问题到解决方案的桥梁。领域模型是领域概念尤其是统一语言的可视化表现，在Eric写作《领域驱动设计》一书的时代，领域模型多数以UML来表达。</p>
<p>这里要注意一个历史问题。在Eric写作该书的时代，正是UML与逆向工程大行其道的时代。当时有很多人都在倡导运用建模工具如Rational Rose来建模，进而利用图形化的模型生成代码。这个思想在当时人们的心中会是未来编程的一个主流发展方向，也有很多人在朝着这个方向努力，随之也催生了诸多建模工具的诞生，UML得到大量的普及，甚至差点成为了软件设计的唯一标准。这也是Eric倡导模型驱动设计的一个历史背景，至少我认为他在写书时是收到这个思想影响的。最终，这种设计思想并没有得以实现，人们低估了编程的复杂度，高估了模型的重要性。所以，Eric的书是有历史局限性的。尽信书不如无书，这是阅读他的书要注意的。书中讲的一些实践，未必都对。</p>
<p>但是，Eric的领域驱动设计是一个方法学，是开放的，也是逐步演进的。事实上，已经有很多人站在Eric的肩膀上，提出了很多切合实际，也吻合软件行业发展趋势的实践与模式，作为领域驱动设计的补充。例如领域事件、六边形架构以及CQRS等。Eric自己也认可这种演进。</p>
<p>回到模型上来。我认为领域模型就是对领域概念的抽象，你说的超载10%其实就是业务规则，所以可以抽象为一个领域概念，在与领域专家进行交流时，可以通过领域模型的这个领域概念来表达，而不是直接使用代码。</p>
<p>设计模型则是对领域模型的一种技术呈现，乃至于是从技术角度的一种精化与演进，例如通过引入设计原则与模式，可以实现领域模型对象更好的职责分配，通过抽象实现解耦，定义更加合理的封装。这时，设计模型要取决于你的编程范式，如采用面向对象还是函数式编程。同样以超载规则为例，面向对象范式的设计模型就是抽象的服务接口，函数式就是一个函数。如果规则需要组合，前者就利用继承或委派，后者就用组合子。</p>
<p>代码模型是设计模型的具体实现，它是遵循设计模型来实现的，采用不同的语言和框架，也会有区别。例如，有的语言可以非常方便地定义值对象，如Scala的Case Class，就是值对象的语法糖。</p>
<p>整体来看，领域模型是团队与领域专家交流所用，设计模型是团队的设计人员交流的工具，代码模型自然为程序员服务。这三个模型之间的关系如下图所示：</p>
<img src="/role-of-domain-model-in-communication/01.png" class="">


<p>随着时间的推移，这三种模型可能会出现不同步的问题。Eric在书中讲解模型驱动设计时也提到了这个问题。如上图所示，领域模型为指导设计模型，设计模型是领域模型的实现，而随着设计模型的演进，我们又需要这种变更体现在领域模型中，保证模型是领域的真实表达。至于代码模型，一方面是遵循设计模型进行代码的实现，同时还应该尽力保障代码模型要表达领域概念，这不仅仅是从代码可读性的角度来考虑，也牵涉到代码对领域逻辑的呈现。这也是为什么在DDD的编程实践中，我们为什么希望避免贫血模型，希望避免使用无法表达领域行为的get和set方法的原因。</p>
<p>倘若要在代码模型中体现领域模型，一种更好的做法是使用DSL，即领域特定语言。但DSL的实现其实是一个相对漫长的积累过程，不同语言的领域表达能力也不相同。所以DSL主要还是用在一些相对复杂但又相对稳定专业的行业中，例如通信和金融行业，就有DSL的开发需求。当然，即使不去做一套DSL，我们也可以借鉴DSL的思想，例如通过Fluent Interface之类的实践改进代码的表达能力。</p>
<p>还有一种做法就是利用BDD编写验收测试，形成活文档（Live Document）。BDD框架如Cucumber、Robot Framework、RSpec其实就是一种DSL，通过这些框架可以编写符合自然语言规范的测试用例，形成一个中规格（Specification），这些测试用例又是能够运行的代码，这就相当于搭建了代码与需求规格的桥梁。不过，这种活文档只能应用在测试保障上，它可以帮助我们建立一种更好的交流机制，但并不能取代设计模型和代码模型。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>QA</tag>
      </tags>
  </entry>
  <entry>
    <title>场景驱动设计新鲜出炉了</title>
    <url>/scenario-driven-design/</url>
    <content><![CDATA[<p>我并非要刻意创造一个方法体系，仅仅是在领域驱动设计的大旗下，发现以“场景”为起点，会有更为系统的设计过程。设计本身会有许多驱动力，场景驱动的方式并没有超出领域驱动的范畴，只是以场景来描述会更准确。</p>
<p>我对场景的定义为：<strong>具有业务价值的，由参与者触发的，按照时序排列的一系列连续执行的任务过程。</strong>场景的层次与Alistair Corkburn设定的用例层次一致，可以简单分为三个层次：概要目标、用户目标和子功能。</p>
<p>用户目标被Corkburn形象地比喻为“海平面”，它是最重要的目标，可以认为是业务需求与系统需求的分界线。只有满足用户目标的场景才体现了业务价值，因此，位于这一层的场景才可以认为是“领域场景”。准确地说，场景驱动设计其实是领域场景驱动设计，如此才能体现通过业务来驱动设计的事实。</p>
<span id="more"></span>

<p>下图体现了场景驱动设计的关键要素：</p>
<img src="/scenario-driven-design/01.jpg" class="">

<p>如上图所示，场景驱动设计的关键要素为角色、职责与协作。<strong>角色</strong>即对象的角色构造型，参与领域场景活动的主要<strong>角色</strong>包括应用服务、领域服务、聚合与抽象的网关。<strong>职责</strong>的层次与任务分解相对应，而任务分解的层次又与角色构造型相对应。在完成一个领域场景时，不同角色履行不同层次的职责：</p>
<ul>
<li>应用服务：匹配领域场景，提供满足业务价值的服务接口</li>
<li>领域服务：匹配组合任务，协调多个聚合与网关之间的协作，履行提供业务功能的领域行为</li>
<li>聚合：匹配原子任务，履行自给自足的领域行为，提供具体的业务实现</li>
<li>网关：匹配原子任务，抽象对外部资源的访问，封装具体的技术实现</li>
</ul>
<p>在当前领域场景的背景下，各个对象角色履行不同层次和粒度的职责。由于场景是由参与者触发的按照时序排列的一系列连续执行的任务过程，因此可以通过时序图表达它们彼此之间的<strong>协作</strong>方式。把场景与角色、职责、协作结合起来，恰好对应于6W模型。以场景作为设计起点，利用任务分解细化场景的业务需求，明确不同层次的职责，并分配给不同角色构造型的对象，结合职责层次通过时序图表现这些对象之间的行为协作。这就是场景驱动设计的全景图。</p>
<p>为了简化场景驱动设计，可以将该设计方法固化为一个可按部就班执行的动态设计过程。整个设计过程如下所示：</p>
<img src="/scenario-driven-design/02.jpg" class="">

<p>场景驱动设计的过程分为三个步骤：</p>
<ol>
<li>识别场景：从需求中识别出独立的具有业务价值的领域场景</li>
<li>分解任务：根据职责的层次对领域场景进行任务分解</li>
<li>分配职责：为领域驱动设计角色构造型分配不同层次的职责</li>
</ol>
<p>场景驱动设计的这三个步骤糅合了几种方法。它的基础其实事件风暴的成果，即通过事件风暴得到的领域分析模型，其中包含了决策命令、读模型、聚合和事件。每个决策命令都是潜在的领域场景。</p>
<p>分解任务其实最符合设计者思维方式，这其实是一种自顶向下的设计方式，它同时也作为测试驱动开发的前置条件。我根据子任务的粒度，将这些任务分为“组合任务”和“原子任务”。任务的类别划分直接影响到后面的职责分配。</p>
<p>分配职责的基础是角色构造型。下图是我总结的主要角色构造型：</p>
<img src="/scenario-driven-design/03.jpg" class="">

<p>在场景驱动设计中，发挥重要的角色构造型包括：应用服务、领域服务、聚合和网关。它们与场景及任务存在以下对应关系：</p>
<ul>
<li>应用服务：场景，体现业务价值</li>
<li>领域服务：组合任务，封装多个领域对象之间的协作</li>
<li>聚合：代表领域行为的原子任务</li>
<li>网关：访问外部资源的原子任务</li>
</ul>
<p>分配职责时，可以借用时序图来表达多个对象角色之间的协作关系。</p>
<p>可以看出，分解任务是场景驱动设计中的关键。只要任务分解合理了，按照我固化的设计流程进行职责分配是水到渠成的过程。我们还可以借助一些工具来显化职责分配与对象协作。推荐我的朋友肖鹏的时序图工具<a href="https://www.zenuml.com/?utm_source=zhangyi">ZenUml</a>，该工具提供了程序员最容易理解和接受的伪代码形式绘制时序图。关键在于这种伪代码将任务与职责完美地融合起来了。</p>
<p>例如，针对信用卡开卡的领域场景，分解的任务如下所示：</p>
<ul>
<li>审核申请<br> * 获得征信信息<br> * 验证申请信息<br> * 审核</li>
<li>生成卡号</li>
<li>通知申请人<br> * 根据模板生成通知内容<br>  * 获取模板<br>  * 根据申请信息和模板生成通知内容<br> * 发送短信</li>
</ul>
<p>根据这些任务，将场景对应应用服务，然后将组合任务和原子任务分配给对应的角色构造型，就可以编写如下伪代码：<br> <br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ApplicationAppService.approve() &#123;</span><br><span class="line">  ApprovingApplicationService.execute() &#123;</span><br><span class="line">    CreditInvestigationGatewary.retriveCredit();</span><br><span class="line">    Application.validate();</span><br><span class="line">    Application.approve();</span><br><span class="line">    ApplicationRepository.save(application);</span><br><span class="line">  &#125;</span><br><span class="line">  CreditCard.generateCardNo();</span><br><span class="line">  NotifingService.execute() &#123;</span><br><span class="line">     GeneratingNotificationService.execute() &#123;</span><br><span class="line">       TemplateRepository.find();</span><br><span class="line">       Notification.generate(template, application);</span><br><span class="line">     &#125;</span><br><span class="line">     SmsGateway.send(notification);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由此伪代码获得的时序图如下所示：</p>
<img src="/scenario-driven-design/04.png" class="">


<p>在得到这些伪代码之后，我们可以利用测试驱动开发由原子任务开始编写单元测试。编写时，仅针对代表领域行为的原子任务进行测试驱动。在这个过程中，需要严格遵循红-绿-重构的节奏进行，通过重构发现之前设计上的不足之处，可以让聚合内实体与值对象之间的协作能够更加的合理。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
        <tag>SDD</tag>
      </tags>
  </entry>
  <entry>
    <title>ZenUML与服务驱动设计</title>
    <url>/service-driven-design-and-zenuml/</url>
    <content><![CDATA[<p>在《<a href="https://item.jd.com/10035002181202.html">解构领域驱动设计</a>》书中的领域建模阶段，我提出了以<strong>业务服务</strong>为核心进行设计与建模的方法——<strong>服务驱动设计</strong>。通过该方法可以在静态的领域设计模型基础之上，以业务服务规约为基础，通过分析需求，对业务服务进行任务分解，获得以子任务构成的任务树。这棵树以业务服务为根，组合任务为枝，原子任务为叶，既体现了业务服务的执行过程，又进行了适度的封装，建立了一定的封装层次。</p>
<p>一旦获得了子任务树，即可对树中的每一个子任务进行职责分配，根据其特点分别分配给远程服务、本地服务、领域服务、聚合、端口。它们是构成限界上下文的主要对象角色，我将其称之为“角色构造型”，可以和我提出的<strong>菱形对称架构</strong>结合：</p>
<img src="/service-driven-design-and-zenuml/rsa.jpg" class="">

<span id="more"></span>

<p>分配的过程可以呈现为序列图，作为动态的领域设计模型，它与静态的领域设计模型共同组成领域设计模型。然则，绘制序列图总是不太方便，于是，我提出了编写序列图脚本的方法。以提交订单业务服务为例，分解获得的子任务树为：</p>
<img src="/service-driven-design-and-zenuml/task-tree.jpg" class="">



<p>根据职责分配的规则，业务服务分配给远程服务与本地服务，组合任务分配给领域服务，原子任务分配给聚合或端口，就可以编写出如下的序列图脚本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OrderController.placeOrder(placingOrderRequest) &#123;  <span class="comment">// 业务服务对应远程服务</span></span><br><span class="line">   OrderAppService.placeOrder(placingOrderRequest) &#123;<span class="comment">//应用服务的方法体现服务价值</span></span><br><span class="line">      OrderService.placeOrder(order) &#123; <span class="comment">// 领域服务对应组合任务，避免领域逻辑泄露到应用服务</span></span><br><span class="line">         OrderService.validate(order) &#123; <span class="comment">// 领域服务对应组合任务</span></span><br><span class="line">            Order.validate();   <span class="comment">// 聚合承担原子任务</span></span><br><span class="line">            InventoryCheckingClient.check(order); <span class="comment">// 客户端端口指向库存上下文的边界服务</span></span><br><span class="line">         &#125;</span><br><span class="line">         OrderRepository.save(order); <span class="comment">// 资源库端口操作订单数据表</span></span><br><span class="line">         ShoppingCartService.removeItems(customerId,cartItems) &#123; <span class="comment">// 领域服务对应组合任务</span></span><br><span class="line">            ShoppingCartRepository.cartOf(customerId); <span class="comment">// 资源库端口操作购物车数据表</span></span><br><span class="line">            ShoppingCart.removeItems(cartItems);  <span class="comment">// 聚合承担原子任务</span></span><br><span class="line">            ShoppingCartRepository.save(shoppingCart); <span class="comment">// 资源库端口操作购物车数据表</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      OrderPlacedPublisher.publish(orderPlacedEvent); <span class="comment">// 发布者端口发布订单已提交的应用事件</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>序列图脚本的创意并非我的创举，而是<a href="https://zenuml.com/">ZenUML</a>给予我的启发。我还在ThoughtWorks的时候，我的Sponser肖鹏正在打磨这个工具。我们二人都认同UML的序列图对于领域建模与设计颇有助力。一方面，序列图这一可视化方式可以提供给设计者一些特征，用于甄别设计的坏味道；另一方面，绘制序列图时，是由外向内逐层递进的，可以更好地站在调用者的角度去思考设计，消息的定义也会产生一种驱动力。我在为GitChat编写领域驱动设计课程时，就想到了这一工具，它提供的脚本语法非常接近Java语法，于是，我就采用拿来主义，将其搬到我的文章里，在融入业务服务、菱形对称架构、角色构造型后，组成了服务驱动设计，其完整过程如下图所示：</p>
<img src="/service-driven-design-and-zenuml/sdd.jpg" class="">



<p>在《解构领域驱动设计》一书即将出版前，我准备修改<a href="https://gitee.com/agiledon/diamond">针对菱形对称架构提供的一个案例</a>，预备在代码库中增加提交订单的序列图脚本。忽然想起之前与肖鹏交流时，他曾提及ZenUML已经为IntelliJ IDEA开发了插件。果然在Settings -&gt; Plugins中找到了ZenUML的插件：</p>
<img src="/service-driven-design-and-zenuml/zenuml-plugin.png" class="">



<p>它的使用方式非常简单，在安装了该插件后，你可以在代码库的任意位置（建议在项目根目录下定义一个文件夹），新建一个扩展名为<code>.zen</code>的文件，然后在文件内根据语法编写序列图脚本，工具就可以自动生成序列图了：</p>
<img src="/service-driven-design-and-zenuml/zenuml-script-sequence.png" class="">



<p>在上图右上方的View工具栏上，还可以切换视图类型，从左到右依次为：</p>
<ul>
<li>仅显示编辑器：此时只会显示时序图脚本</li>
<li>显示编辑器和预览：如上图所示，同时显示时序图脚本和预览的时序图效果</li>
<li>仅显示预览：此时只会显示序列图</li>
<li>在浏览器中打开</li>
</ul>
<p>如果将ZenUML工具运用到服务驱动设计方法中，即可在领域设计建模阶段尝试通过IDE建模，分析需求后，尝试编写序列图脚本，然后对照生成的序列图对脚本进行调整。调整的成本很低，完全可以随时修订。一旦确定了最终的序列图，即可按照测试驱动开发的流程，优先为聚合承担的原子任务和组合任务编写测试用例，通过测试驱动出该业务服务的实现代码。</p>
<p>ZenUML的功能当然不限于此，在驱动出最终的实现代码后，也可以将真实代码转换为序列图。例如在IntelliJ IDEA中，打开已经实现好的远程服务类<code>OrderController</code>，将光标移到要生成序列图的方法体内，右键弹出快捷菜单，即可看到如下的菜单项：</p>
<img src="/service-driven-design-and-zenuml/zenuml-menu.png" class="">



<p>选择该菜单项，就会自动生成序列图脚本与对应的序列图，生成的文件为<code>buffer&#123;n&#125;.zen</code>：</p>
<img src="/service-driven-design-and-zenuml/zenuml-generated.png" class="">



<p>如果你不喜欢它默认提供的呈现样式，也可以到Languages &amp; Frameworks中找到ZenUML，添加CSS规则，以改变呈现样式：</p>
<img src="/service-driven-design-and-zenuml/zenuml-css.jpg" class="">



<p>ZenUml除了<a href="https://app.zenuml.com/">Web APP</a>之外，还提供了<a href="https://marketplace.atlassian.com/apps/1218380/zenuml-sequence-diagram">Confluence插件</a>，以便于我们编写设计文档。不出意料之外，它也为主流的浏览器提供了扩展，例如，在Microsoft Edge浏览器中可找到ZenUML Sequence扩展，安装后，工具栏会出现它的图标，打开，即可输入序列图脚本生成序列图：</p>
<img src="/service-driven-design-and-zenuml/zenuml-explorer.png" class="">



<p>真的是太方便了！ZenUML简直就是为服务驱动设计量身定做的。至于该怎么实践服务驱动设计，在《解构领域驱动设计》书中你可以找到答案。该如何使用ZenUML？那就太简单了，它的脚本语法基本和Java相同，使用也非常简单，无论是通过浏览器还是IDE，实际去使用一下，很快就能理解它的价值。</p>
<p>如果你的开发流程和开发工具中需要序列图，也可以直接在系统中把ZenUML作为一个前端库进行集成。目前已经有多家企业在自己的构建流程中集成了ZenUML。某国内企业在构建过程中使用ZenUML在文档中嵌入序列图；某国外企业则开发了Python转ZenUML工具，从代码直接生成序列图。ZenUML的文本转序列图的功能以免费的形式发布在<a href="https://www.npmjs.com/package/vue-sequence">npm</a>上面。ZenUML开发者提供（有限的）免费技术支持。</p>
]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂不简单</title>
    <url>/simple-factory-is-not-simple/</url>
    <content><![CDATA[<img src="/simple-factory-is-not-simple/cover.jpeg" class="">

<p>马丁花背着灰色的双肩背包走进了公司写字楼，浮现在眼前的是排成长蛇状的一群上班族，正按照单双层各自分成两队等候着电梯。低楼层的童鞋等不及了，甩开双腿开始爬楼梯，就当是减肥锻炼身体了，不着急的依旧排在队伍里，低头看着手机，玩着游戏或者刷着朋友圈。手机扫去了等待的急躁与不安，一个个安静如花，只待电梯像殷勤的主人把他们一批一批接走。</p>
<p>终于踏进了电梯，马丁花被挤到了角落里，电梯里的人互不相识，肃穆像开追悼会，只听得电梯不断发出“叮”的一声响，电子合成声开始汇报多少层到了，门打开，随着不断有人走出，空间变得逐渐开阔起来。</p>
<p>“十八层到了！”自从新搬到这栋写字楼后，马丁花每次听到呆板而不带感情的电子合成声汇报所在楼层到达时，都忍不住翻一下白眼，心里不由脑补出“地狱”两个字眼儿。摇摇头，缓缓走出电梯。</p>
<p>刷卡。自动门刚一打开，就瞥见一道身影正要到正前方拐角处的茶水间倒水，看见自己来了，又赶紧退了回去，似乎故意躲着马丁花。这道身影再熟悉不过，自然躲不过马丁花敏锐的法眼，赶紧叫到：“蔡了！”</p>
<span id="more"></span>

<p>“啊……这么倒霉，一上班就被头儿盯住了，昨天布置的作业没完成，怎么办！”蔡了内心不由哀嚎，听到马丁花的声音，只得停下来，无奈装出一副笑脸，言不由衷地说道：“老大，早上好啊！”</p>
<p>“躲着我啊！昨天的作业没做，对吧？”马丁花看到她一副强颜欢笑的样子，哪还不知道古怪灵精的她打的甚么主意，即刻开启了严师模式。</p>
<p>“哼，勤奋如我怎么会没有完成作业呢？”蔡了赶紧辩解，“——只是，我虽然搞清楚了静态工厂实际用的是<strong>简单工厂模式</strong>，却不知道它能给设计带来什么好处？查了好多资料，发现居然有各种各样的工厂模式，不看还好，越看越糊涂了！”</p>
<p>“嗯，看来你还是做了些功夫的。一会开完站会，到我工位来，我给你简单讲一讲吧！”</p>
<p>蔡了点点头，谢过马丁花，径直到茶水间倒水去了。</p>
<p>站会一开完，蔡了就规规矩矩前来受教。马丁花开门见山，直截了当地说到：“工厂在设计模式中，其实就是一种比喻，目的自然是为了更好地创建对象。既然在Java中已有构造函数能够担负实例化的职责，为何还需要引入工厂呢？要明白工厂的价值，你就需要先明确构造函数的缺陷，对吧？”蔡了不由得点头称是，似乎得到了一丝启发。</p>
<p>“你想想，Java语法中构造函数是怎么定义的？它有哪些语法上的限制？”马丁花循循善诱地提出了问题。</p>
<p>蔡了在脑海中搜索着这段时间学习的Java语法，心里组织着语言，回答道：“类的构造函数与类名必须保持一致；构造函数支持方法重载，但不允许出现相同方法签名；每个具体类的构造函数都只能创建类自身；如果定义了带参构造函数，且又需要无参构造函数，还需要显式定义无参的构造函数。”</p>
<p>“不错！语法记得很清楚。那么，根据这些语法限制，你想想：如果需要创建代码给出清晰的创建目的，构造函数能不能做到？如果创建的对象有可能发生变化，构造函数能不能做到？如果希望控制对象的创建逻辑，构造函数能不能做到？”</p>
<p>“好像是这么回事，不过大叔啊，你可否给我个例子，这样枯燥的理论讲解让人很难理解呢。”小姑娘有些得寸进尺了。</p>
<p>“好吧。”马丁花看着她一脸困惑的样子，无奈地摇摇头，打开IntelliJ，找到JDK中的<code>Optioanal&lt;T&gt;</code>类，展示给蔡了：</p>
<img src="/simple-factory-is-not-simple/sf01.png" class="">

<p>“你看JDK 8提供的<code>Optional&lt;T&gt;</code>类，它就定义了诸如<code>empty()</code>、<code>of()</code>和<code>ofNullable()</code>这几个简单工厂，它们创建的虽然都是<code>Optional&lt;T&gt;</code>对象，可相较于直接调用构造函数，它们有什么价值？”</p>
<p>蔡了陷入沉思中。马丁花提醒道：“还是昨天那句话，<strong>你要学会站在调用者的角度看待API设计</strong>。”这么一说，小姑娘就回过味来，说道：“对啊，有了这些简单工厂，就能更加清晰地告诉调用者究竟创建了什么样的<code>Optional</code>对象，尤其那个<code>empty()</code>，实在太传神了！这实际上就是可读性的要求嘛，很好理解哟。”马丁花看着她一副不屑一顾的样子，想到她刚才一脸茫然抱怨不好理解，真恨不得给她脑门上来一记头粟！</p>
<p>蔡了倒是没来得及察言观色，继续想着老马刚才问的几个问题，想不通，只得问道：“嘿，大叔，你刚才说控制对象的创建逻辑，我有些不清楚，构造函数就是方法啊，难道还不能控制创建的逻辑？”</p>
<p>“如果创建逻辑只是验证、组装、计算等逻辑，构造函数确实办得到；但是，你注意到没有，Java类的构造函数是没有<code>return</code>的，如果你希望控制对象创建的次数，又或者希望引入缓存提升创建对象的性能，构造函数还能做到吗？更不用说，在有些情况下，如果需要通过反射创建对象，就更需要引入静态工厂方法来封装对象创建的逻辑了。”</p>
<p>“例如有<code>Composer</code>继承体系。”马丁花绘制出如下类图：</p>
<img src="/simple-factory-is-not-simple/sf02.png" class="">

<p>“考虑<code>Composer</code>的扩展性，需要通过反射创建各个<code>Composer</code>实现类，类名遵循格式：文件扩展名+Composer，你想想看，可以通过<code>YamlComposer</code>或其他实现类的构造函数来完成吗？”</p>
<p>蔡了使劲摇头！马丁花把一段示例代码打开，指着代码继续讲道：“这个时候，就需要引入一个专门的工厂类，为其定义一个静态工厂方法，用来封装创建逻辑。”</p>
<img src="/simple-factory-is-not-simple/sf03.png" class="">

<p>“大叔！”蔡了认真看着这个案例，忽然灵机一动，想到一点，赶紧指出来：“那你说的创建对象有可能发生变化，是不是也属于这种情况啊？”</p>
<p>“孺子可教！”马丁花很高兴看到蔡了能够触类旁通，继续讲道：“刚才说到的<code>Composer</code>对象的创建之所以引入反射，确实考虑到了创建对象的变化，不过，在多数情况下，不一定要使用反射来解决这一问题。只要你希望<strong>调用者无需了解产品对象创建变化的逻辑</strong>，在工厂方法返回<strong>父类产品</strong>的前提下，你都可以使用简单工厂。例如JDK中的<code>Collections</code>类，就定义了许多静态工厂方法，用于创建<code>Collection&lt;T&gt;</code>对象。创建的这些对象可能是不同的集合类型，但对于调用者而言，可以不必知道产品对象的具体类型。”马丁花一边说着，一边打开<code>Collections</code>类的定义，将光标快速移到<code>unmodifiableCollection()</code>方法上：</p>
<img src="/simple-factory-is-not-simple/sf04.png" class="">

<p>“你看！<code>unmodifiableCollection()</code>方法表面上返回的是一个<code>Collection&lt;T&gt;</code>对象，实际上，在其内部定义了一个内部类<code>UnmodifiableCollection</code>，它屏蔽了集合的修改功能，使之成为一个不可修改的集合。你想想看，这样做的好处是什么？”</p>
<p>“嗯……”思索良久，蔡了想到了答案：“我想，这样做应该有两个好处。一个好处是<code>unmodifiableCollection()</code>方法清晰地向调用者传递了创建不可变集合的语义，另一个好处是将来如果修改了<code>UnmodifiableCollection</code>内部类的定义与实现，也不会影响到该工厂方法的调用者。我说的对吗，马大叔？”</p>
<p>“不错，不错！我看你彻底理解了简单工厂的含义！”</p>
<p>“噢耶！”得到马大叔的肯定，蔡了不由得欢呼起来，不过想到其他工厂模式，又苦下脸来，说道：“可是——我还是不太明白简单工厂模式与工厂方法模式、抽象工厂模式的区别和使用场景呢。”</p>
<p>马丁花想了想，指着茶水间，向蔡了说道：“说了半天，口也渴了，不如我们去那边冲一杯咖啡，边喝边讲，如何？”蔡了点点头，和马丁花一起走到了茶水间的咖啡机旁。</p>
]]></content>
      <categories>
        <category>蔡了成长记</category>
      </categories>
      <tags>
        <tag>Design, OO, Design Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>解惑领域驱动设计</title>
    <url>/solve-puzzle-of-ddd/</url>
    <content><![CDATA[<img src="/solve-puzzle-of-ddd/logo.jpg" class="">
<p>最近重读Eric Evans的经典《领域驱动设计》，正如Eric提倡我们要去发现隐式概念一般，这次重读也让我发现了许多隐藏的DDD知识。恰好今日有朋友咨询我一些DDD问题，好似激活了触发器，随着问题的解答，我倒是在回答过程中又把这些知识梳理了一遍，才有了这篇杂记。</p>
<span id="more"></span>

<h3 id="问题一：Repository的问题"><a href="#问题一：Repository的问题" class="headerlink" title="问题一：Repository的问题"></a>问题一：Repository的问题</h3><p>怎么看待DDD中的Repository？我们必须把握一个根本的底线，就是采用DDD方式设计Repository时，<strong>一定要忘记所有与数据访问有关的技术实现细节</strong>。Repository接口属于领域层，一旦我们将Repository视为DAO对象，就会不期然地重回数据驱动设计的老路。</p>
<p>Eric在书中写道：“Repository将某种类型的所有对象表示为一个<strong>概念集合</strong>（通常是模拟的）”。这句话一语道破天机，也是DDD得名的由来，必须是<strong>通过领域去驱动设计</strong>，也就是说在这个设计过程中，应尽量去掉技术的色彩。</p>
<p>借用Martin Fowler对重构的隐喻，在领域驱动设计过程中，也有两顶帽子：领域设计与技术实现。在进行领域设计时，考虑的应该是领域逻辑、业务规则，以及随之需要设计演进的领域模型；一旦开始关注技术实现，就应该切换到与领域完全无关的技术关注点上。这也就是我认为非常关键的点：<strong>分离技术复杂度和业务复杂度</strong>。</p>
<p>Repository是一个概念集合，我们在领域设计时，又需要保证领域概念的完整性，并考虑领域逻辑的不变性约束，因此，DDD才会引入Aggregate。同时，DDD明确约定：<strong>一个Aggregate只能有一个Repository，即聚合根的Repository</strong>。所有对聚合的访问都应该通过Repository来完成。</p>
<h3 id="问题二：针对没有采用DDD的项目，如何演化为DDD"><a href="#问题二：针对没有采用DDD的项目，如何演化为DDD" class="headerlink" title="问题二：针对没有采用DDD的项目，如何演化为DDD"></a>问题二：针对没有采用DDD的项目，如何演化为DDD</h3><p>在《领域驱动设计》的第四章“分离领域”，Eric给出了几点DDD的适用范围：</p>
<ul>
<li>领域驱动设计只有应用在大型项目上才能产生最大的收益，而这也确实需要高超的技巧。不是所有的项目都是大型项目；也不是所有的项目团队都能掌握这些技巧</li>
<li>如果一个架构能够把那些与领域相关的代码隔离出来，得到一个内聚的领域设计，同时又使领域与系统其它部分保持松散耦合，那么这种架构也许可以支持领域驱动设计</li>
<li>将领域实现独立出来是领域驱动设计的前提</li>
</ul>
<p>因此，领域驱动设计绝对不是银弹，我们也不要将领域驱动设计视为拯救项目的灵丹妙药。从上述几点描述，我们似乎可以得出DDD的基础要素：</p>
<ul>
<li>项目的规模与领域复杂度</li>
<li>项目成员的设计能力</li>
</ul>
<p>当我们开始做一个新项目时，有可能从一开始业务并没有多复杂，系统规模也不够大，没有运用DDD是可以接受的选择。但随着需求的增加与变化，项目规模与领域复杂度都达到了DDD的要求。这时该如何应对？</p>
<p>针对这种已有的系统，若要从Non-DDD形式演化为DDD形式，无非是两种策略：</p>
<ul>
<li><strong>策略一：</strong>对已有系统进行重构。注意这种重构并非Martin Fowler提出的代码级别重构，而是对领域模型的重构。如果没有领域模型，那么我们就需要去重新发掘领域知识，建立统一语言，进而提炼出领域模型，然后使用领域模型指导我们的程序设计。这时，需要重构已有代码来满足领域模型表达的知识。</li>
<li><strong>策略二：</strong>如果已有系统的功能与新需求存在一个清晰的边界，更简单的办法是将已有功能视为一个Bounded Context，然后对新需求采用DDD设计方法，并通过引入防腐层和已有系统进行通信。</li>
</ul>
<p>倘若开启的新项目在领域复杂度上达不到DDD的要求，我仍然建议运用DDD，只不过需要将DDD的设计重点放在战略设计阶段，即对项目划分合理的Bounded Context。一旦确定了这些Context的边界，在边界之内进入战术设计阶段时，就可以不采纳DDD的设计方式，例如选择使用Transaction Script。</p>
<h3 id="问题三：微服务与领域驱动设计的关系"><a href="#问题三：微服务与领域驱动设计的关系" class="headerlink" title="问题三：微服务与领域驱动设计的关系"></a>问题三：微服务与领域驱动设计的关系</h3><p>领域驱动设计的战略设计可以帮助我们识别微服务的边界。针对微服务内部，可以采用DDD的方式，也可以采用其他方式，这个并没有特别约束。</p>
<p>大体可以这样认为：</p>
<ul>
<li>战略层面，领域驱动设计指导了微服务设计，微服务架构影响了领域驱动设计</li>
<li>战术层面，二者没有任何关系，但DDD可以是微服务的其中一种实现</li>
</ul>
<p>实践中，我们通常会使用DDD的Bounded Context、Context Map以及六边形架构来指导微服务设计。反过来，由于微服务强调服务的独立部署，因此微服务的引入重新定义了Bounded Context的边界，服务之间的通信也突破了Context Map的集成模式。</p>
<p>至于微服务对数据存储的设计约束——“每个微服务的数据单独存储”，属于基础设施层面，严格来讲，与领域驱动设计是没有任何关系的。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
        <tag>Micro Service</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Flink流式任务的性能瓶颈</title>
    <url>/solution-to-performance-bottleneck/</url>
    <content><![CDATA[<p>都说“过早进行性能优化是万恶之源”，我宁肯相信这是为了“矫枉过正”而出此惊人之语，更何况，现在的IT时代已与Donald Knuth的时代已有很大差异了。重点还是在于<strong>“过早”</strong>这个词，之所以Knuth告诫我们不要过早进行性能优化，原因在于：</p>
<ul>
<li>判断性能是否存在问题，不能太早</li>
<li>太早做性能优化，有可能并没有弄清楚性能瓶颈在哪里</li>
</ul>
<img src="/solution-to-performance-bottleneck/knuth.JPG" class="">

<p>图为Donald Knuth在斯坦福大学计算机科学William Gates大楼的办公室</p>
<p>最近，我的团队成员正在着力于提高实时流处理任务的性能。由于客户为我们的测试环境仅提供了极度可怜的集群资源，我们需要在“螺蛳壳里做道场”，死扣性能，尽可能在方案与实现上将性能提升到极致。（顺带说，在测试时，不要奢侈地提供大量资源，反倒有可能尽早发现性能问题，从而让团队想办法解决之。）</p>
<span id="more"></span>



<p>一开始，我们想到的方案是增加Flink Streaming Job每个算子或算子链的并行度。Flink支持多个级别设置并行度，包括：</p>
<ul>
<li><p>环境级别：对Execution Environment进行<code>parallelism</code>的设置</p>
</li>
<li><p>客户端级别：客户端提交Job时通过命令参数-p进行设置</p>
</li>
<li><p>算子级别：调用每个算子的<code>setParallelism()</code>方法设置算子的并行度，在为算子设置并行度时，需要考虑它对算子链的影响。如果相邻算子的并行度不一样，两个算子就不能成为算子链。算子链可以减少不必要的线程切换，减少不必要的序列化和反序列化操作，减少延迟提高吞吐能力，因此，如果两个算子相邻，且中间没有数据的shuffle操作，应保证它们的并行度是相同的。</p>
</li>
</ul>
<p>如果没有显式设置并行度，Flink的系统默认并行度为1。不同级别优先级不同，优先级按照高低，顺序依次为：</p>
<p>算子级别 -&gt; 客户端级别 -&gt; 环境级别 -&gt; 系统默认级别</p>
<p>Flink的并行度设置并不是说越大，数据处理的效率就越高，而是需要设置合理的并行度。并行度的设置数量取决于Task Manager的数量以及slot数量。通常可以认为Task Manager部署的节点有多少核CPU，就有多少个slot。</p>
<p>设置了合理的并行度，就能有效地利用Worker节点的资源。但为何在实现之初，没有考虑并行度呢？原因在于引入并行度后，从上游传入的数据就会被Task Manager分配到不同的slot做并行处理，由于不同任务执行时间不同，slot的执行效率也可能不同，就可能无法保证同类数据多条数据的时序性。</p>
<p>为了保证同类数据的执行时序性，我们引入了Flink的<code>keyBy</code>算子。它能够将相同key的元素散列到一个子任务中，且没有改变原来的元素数据结构。<code>keyBy</code>使用的key应使用数据的主键，即ID，如此就能保证拥有相同ID值的同类数据一定执行在同一个子任务中，进行同步处理，这就保证了数据处理的时序性。时序性与并行度带来的高性能，就能鱼与熊掌兼得了。</p>
<p>即便如此，我们提升的性能依旧有限，毕竟受到资源的限制，我们不能盲目增大并行度。由于单条消息数据的处理逻辑非常复杂，它的处理能力已经达到我们能够优化的极限。最后，评估任务的处理能力，仅能做到每秒处理6条左右的数据，这一结果自然不能接受。一种立竿见影的手段是增加更多的资源，但我们还是想在没有更多资源支持下，看看能否竭尽所能提升性能。——这时，我们才想到去探索<strong>性能瓶颈</strong>到底在哪里？</p>
<p>我们开始监控实时流任务的执行，通过日志记录执行时间，在单条数据处理能力已经无法优化的情况下，发现真正的性能瓶颈不在于Flink自身，而是任务末端将处理后的数据写入到ElasticSearch这一阶段。</p>
<p>在执行流式处理过程中，上游一旦采集到数据，就会及时逐条处理，这也是流式处理的实时特征。根据我们的业务特征，平台在接收到上游采集的流式数据后，经过验证、清洗、转换与业务处理，会按照主题治理的要求，将处理后的数据写入到ElasticSearch。然而，这并非流任务处理的终点。数据在写入到ElasticSearch后，平台需要触发一个事件，应下游系统的要求，将上游传递的消息转换为出口消息。由于上游传递的消息不一定包含了出口消息的所有数据，在转换消息时，平台还需要查询ElasticSearch，获得包括最近更新的数据，作为组成出口消息的数据内容。</p>
<p>这里仍然存在时序性问题！在组成出口消息时需要查询ElasticSearch，这就要求最新的数据已经写入成功并能被检索到。由于ElasticSearch要支持全文本检索，写入数据时需要为其建立索引，也就是Lucene中的Segments，使得每次写操作的延迟相对于读操作而言要高一些。为了提升写入性能，ElasticSearch引入了in-memory buffer（内存缓冲区），提供了refresh（刷新）的三种方式：</p>
<ul>
<li><p>即刻刷新</p>
</li>
<li><p>指定周期刷新，默认周期为1s，它也是ElasticSearch的默认值</p>
</li>
<li><p>当内存缓冲区满时刷新</p>
</li>
</ul>
<p>只有即刻刷新，才能在一条数据写入到 Elasticsearch 后，能被马上搜索到。当上游采集的数据量非常多，且采用流式方式传入时，下游ElasticSearch的逐条写入与即刻刷新机制就成为了性能瓶颈。如果采用后两种刷新机制，又会导致索引未建立，无法即时搜索到最新数据，就会导致数据不一致。换言之，在我们的场景中，选择“即刻刷新”是必然的！要解决写入瓶颈的问题，最佳做法是放弃逐条写入，改为ElasticSearch支持的批量写入，如此即可减少不必要的连接，也能减少IO的次数。</p>
<p>虽说上游传递的流式数据需要实时进行处理，却并未要求它必须实时写入ElasticSearch，也未要求它必须实时推送给下游系统。当然，也不能延迟太长的时间。</p>
<p>为了权衡写入性能和数据正确性以及一致性，可以<strong>将实时写入改造为微批量的写入</strong>，如此，既能通过批量写入提升ElasticSearch的写入性能，又能保证数据必须成功写入到ElasticSearch后再推送消息，确保数据正确性与一致性。</p>
<p>团队成员想到了引入Flink的窗口，具体说来，是使用Flink时间窗口中的会话窗口与滚动窗口。</p>
<p>会话窗口的作用是在指定窗口周期内将相同key值的数据汇聚起来，我们为不同的key分配对应的会话窗口，而窗口好似一个桶，每个桶各自装各自key值的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.keyBy(<span class="keyword">new</span> KeyById())</span><br><span class="line">.window(ProcessingTimeSessionWindows.withGap(Time.seconds(<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>



<p>如此这般，就能将1秒内相同key值的数据放到相同的会话窗口中，然后，通过<code>reduce()</code>算子对同一会话窗口中的数据进行合并，形成状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.reduce(<span class="keyword">new</span> MergeWighSameId())</span><br></pre></td></tr></table></figure>



<p>这一方式虽然实现了相同key数据的合并，但由于窗口的数量太过分散，导致数据汇聚的作用并不明显，没有达到批量写入提升性能的目的。</p>
<p>既然已经合并了相同key的数据，我们就可以减少窗口的数量，从而让不同key值的数据也能够汇聚到同一个窗口，形成数据的集合，交由下游进行批量写入。此时，选择的窗口为滚动窗口。</p>
<p>虽说窗口数量需要减少，但为了更好地利用资源，最好保证窗口的数量等于并行度。通过<code>env.getParallelism()</code>方法可以获得当前环境的并行度，在对数据的ID（它是数据的key）进行哈希值计算后，将并行度作为因子进行取模，就能将窗口数量压缩，天然实现数据的汇聚：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 再执行了reduce后</span></span><br><span class="line">.keyBy(<span class="keyword">new</span> KeyById(env.getParallelism()))</span><br><span class="line">.window(TumblingProcessingTimeWindows.of(Time.second(<span class="number">1</span>)))</span><br><span class="line">.reduce(<span class="keyword">new</span> CellectEntities())</span><br><span class="line">...<span class="comment">// 汇聚后写入到ElasticSearch</span></span><br></pre></td></tr></table></figure>



<p>对比改进前后的流式任务，下图是执行未加窗口的流式任务结果：</p>
<img src="/solution-to-performance-bottleneck/before.png" class="">



<p>下图是执行加窗口后的流式任务结果：</p>
<img src="/solution-to-performance-bottleneck/after.png" class="">



<p>相同环境下，前者处理流式数据的频率大概为6条/秒左右，后者则达到了20条/秒左右，整体性能提升了3倍多，实现了不通过横向添加资源就完成了流式任务的性能优化，归根结底，在于我们发现了性能瓶颈，然后再对症下药，方可取得疗效。</p>
<p><strong>说明：</strong>本文的技术方案与部分内容来自我的团队成员郑雄杰同学。</p>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>Flink</tag>
        <tag>BigData</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>职责驱动设计以及状态模式的变化</title>
    <url>/state-pattern-and-rdd/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>针对某通信产品，我们需要开发一个版本升级管理系统。该系统需要通过由Java开发的管理后台，由Telnet发起向前端基站设备的命令，以获取基站设备的版本信息，并在后台比较与当前最新版本的差异，以确定执行什么样的命令对基站设备的软件文件进行操作。基站设备分为两种：</p>
<ul>
<li>主控板（Master Board）</li>
<li>受控板（Slave Board）</li>
</ul>
<p>基站设备允许执行的命令包括transfer、active、inactive等。这些命令不仅受到设备类型的限制，还要受制于该设备究竟运行在什么样的终端。类型分为：</p>
<ul>
<li>Shell</li>
<li>UShell</li>
</ul>
<p>对命令的约束条件大体如下表所示（不代表真实需求）：</p>
<img src="/state-pattern-and-rdd/01.jpg" class="">


<p>通过登录可以连接到主控板的Shell终端，此时，若执行enterUshell命令则进入UShell终端，执行enterSlaveBoard则进入受控板的Shell终端。在受控板同样可以执行enterUshell进入它的UShell终端。系统还提供了对应的退出操作。整个操作引起的变迁如下图所示：</p>
<img src="/state-pattern-and-rdd/02.png" class="">


<p>执行升级的流程是在让基站设备处于失效状态下，获取基站设备的软件版本信息，然后在后端基于最新版本进行比较。得到版本之间的差异后，通过transfer命令传输新文件，put命令更新文件，deleteFiles命令删除多余的文件。成功更新后，再激活基站设备。因此，一个典型的升级流程如下所示：<br>0. login (Master Board Shell)</p>
<ol>
<li>inactive (Master Board UShell)</li>
<li>get  (Slave Board Shell)</li>
<li>transfer(Master Board Shell)</li>
<li>put(Slave Board Shell)</li>
<li>deleteFiles(Slave Board Ushell)</li>
<li>active(Master Board UShell)</li>
<li>logout</li>
</ol>
<p>整个版本升级系统要求：无论当前基站设备属于哪种分类，处于哪种终端，只要Telnet连接没有中断，在要求升级执行的命令必须执行成功。如果当前所处的设备与终端不满足要求，系统就需要迁移到正确的状态，以确保命令的执行成功。</p>
<span id="more"></span>

<h2 id="寻找解决方案"><a href="#寻找解决方案" class="headerlink" title="寻找解决方案"></a>寻找解决方案</h2><p>根据这个需求，我们期待的客户端调用为（为简便起见，省略了所有的方法参数）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//client </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upgrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TelnetService service = <span class="keyword">new</span> TelnetService();</span><br><span class="line">    service.login();</span><br><span class="line">    service.inactive();</span><br><span class="line">    service.get();</span><br><span class="line">    service.transfer();</span><br><span class="line">    service.put();</span><br><span class="line">    service.deleteFiles();</span><br><span class="line">    service.active();</span><br><span class="line">    service.logout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样简便直观的调用，实则封装了复杂的规则和转换逻辑。我们应该怎么设计才能达到这样的效果呢？</p>
<h3 id="使用条件分支"><a href="#使用条件分支" class="headerlink" title="使用条件分支"></a>使用条件分支</h3><p>一种解决方法是使用条件分支，因为对于每条Telnet命令而言，都需要判断当前的状态，以决定执行不同的操作，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TelnetService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String currentState = <span class="string">&quot;INITIAL&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        swich (currentState.toUpperCase()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;INITIAL&quot;</span>:</span><br><span class="line">                login();</span><br><span class="line">                currentState = <span class="string">&quot;MASTER_SHELL&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;MASTER_SHELL&quot;</span>:</span><br><span class="line">                <span class="comment">// ignore</span></span><br><span class="line">                ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行transfer命令</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而这样的实现是不可接受的，因为我们需要对每条命令都要编写相似的条件分支语句，这就导致出现了重复代码。我们可以将这样的逻辑封装到一个方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TelnetService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String currentState = <span class="string">&quot;INITIAL&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        swichState(<span class="string">&quot;MASTER_SHELL&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行transfer命令</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">switchState</span><span class="params">(String targetState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (currentState.toUpperCase()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;INITIAL&quot;</span>:</span><br><span class="line">                <span class="keyword">switch</span> (targetState.toUpperCase()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;INITIAL&quot;</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;MASTER_SHELL&quot;</span>:</span><br><span class="line">                        login();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 其他分支略</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 其他分支略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switchState()</code>方法避免了条件分支的重复代码，但是它同时也加重了方法实现的复杂度，因为它需要同时针对当前状态与目标状态进行判断，这相当于是一个条件组合。</p>
<p>Kent Beck认为：“（条件分支的）所有逻辑仍然在同一个类里，阅读者不必四处寻找所有可能的计算路径。但条件语句的缺点是：除了修改对象本身的代码之外，没有其他办法修改它的逻辑。……条件语句的好处在于简单和局部化。”显然，由于条件分支的集中化，导致变化发生时，我们只需要修改这一处；但问题在于任何变化都需要对此进行修改，这实际上是重构中“发散式变化（Divergent Change）”坏味道。</p>
<h3 id="引入职责驱动设计"><a href="#引入职责驱动设计" class="headerlink" title="引入职责驱动设计"></a>引入职责驱动设计</h3><p>职责驱动设计强调从“职责”的角度思考设计。<strong>职责</strong>是“拟人化”的思考模式，这实际上是面向对象分析与设计的思维模式：将对象看作是有思想有判断有知识有能力的“四有青年”。这也就是我所谓的“智能对象”。只要分辨出职责，就可以从知识和能力的角度入手，寻找哪个对象具备履行该职责的能力？</p>
<p>回到版本升级系统这个例子，从诸如transfer、put等命令的角度思考职责，则可以识别职责为：</p>
<ul>
<li>执行Telnet命令<ul>
<li>迁移到正确的状态</li>
<li>运行Telnet命令</li>
</ul>
</li>
</ul>
<p><code>TelnetService</code>具有执行Telnet命令的能力，如果要运行的命令太多，也可以考虑将运行各个命令的职责再分派给对应的<code>Command</code>对象。那么，又该谁来执行“迁移到正确的状态”呢？看能力？——谁具有迁移状态的能力？一个对象能够履行某个职责，必须具备履行职责的知识，所以就要看知识。</p>
<p>迁移到正确状态需要哪些知识？——当前状态、目标状态以及如何迁移状态。只要确定了当前状态和目标状态，根据前面的状态变迁图就可以知道该如何迁移状态了。那么，谁确定地知道当前状态呢？——<strong>只有状态对象自身才知道！</strong>在条件分支实现中，状态是通过字符串表达的，字符串对象自身并不知道其值到底是什么，需要取出其值进行判断，这就是使用条件分支的原因。当状态从一个字符串升级为状态对象时，状态的值就是状态对象“自己知道”的知识。当每种状态都知道自己的状态值时，它们若要履行“迁移状态”的职责，就无需再对当前状态进行判断了，这正是为何多态能够替代条件分支的原因。</p>
<p>我们可以定义一个状态的继承树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NodeState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">switchTo</span><span class="params">(???)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialState</span> <span class="keyword">implements</span> <span class="title">NodeState</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterShellState</span> <span class="keyword">implements</span> <span class="title">NodeState</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当状态变为对象且具有职责时，对象就是有思想的职能对象。遗憾的是，它具有的知识还不足以完全履行“迁移到正确状态”的职责，因为它并不知道该迁移到哪个目标状态。这个知识只有具体的Telnet命令才知道，因而需要传递给它。一种做法是作为方法参数传入，但这会导致方法体内需要对传入的参数作条件分支判断。另一种方法则利用方法的多态，显式地定义多种方法来履行迁移到不同目标状态的职责：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NodeState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">switchToInitial</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">switchToMasterShell</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">switchToMasterUshell</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">switchToSlaveShell</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">switchToSlaveUshell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialState</span> <span class="keyword">implements</span> <span class="title">NodeState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitialState</span><span class="params">(TelnetService service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchToInitial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchToMasterShell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.login();</span><br><span class="line">        service.setCurrentState(<span class="keyword">new</span> MasterShellState(service));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchToMasterUshell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.login();</span><br><span class="line">        service.enterUshell();</span><br><span class="line">        service.setCurrentState(<span class="keyword">new</span> MasterUshellState(service));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchToSlaveShell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.login();</span><br><span class="line">        service.enterSlave();</span><br><span class="line">        service.setCurrentState(<span class="keyword">new</span> SlaveShellState(service));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchToSlaveUshell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.login();</span><br><span class="line">        service.enterSlave();</span><br><span class="line">        service.enterUshell();</span><br><span class="line">        service.setCurrentState(<span class="keyword">new</span> SlaveShellState(service));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterShellState</span> <span class="title">implement</span> <span class="title">NodeState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MasterShell</span><span class="params">(TelnetService service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchToInitial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.logout();</span><br><span class="line">        service.setCurrentState(<span class="keyword">new</span> InitialState(service));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchToMasterShell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchToMasterUshell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.enterUshell();</span><br><span class="line">        service.setCurrentState(<span class="keyword">new</span> MasterUshellState(service));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchToSlaveShell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.enterSlave();</span><br><span class="line">        service.setCurrentState(<span class="keyword">new</span> SlaveShellState(service));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchToSlaveUshell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.enterSlave();</span><br><span class="line">        service.enterUshell();</span><br><span class="line">        service.setCurrentState(<span class="keyword">new</span> SlaveShellState(service));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelnetService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NodeState currentState = <span class="keyword">new</span> InitialState(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(NodeState state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.switchToMasterUshell();</span><br><span class="line">        <span class="comment">//inactive impl</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.switchToMasterShell();</span><br><span class="line">        <span class="comment">//real transfer impl</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">active</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.switchToMasterUshell();</span><br><span class="line">        <span class="comment">// real active impl</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.switchToSlaveShell();</span><br><span class="line">        <span class="comment">// get</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的设计并没有做到“开放封闭原则”，当增加了新的状态时，由于需要在<code>NodeState</code>接口中增加新的方法，使得所有实现该接口的状态类都需要修改。这相当于从条件分支的“发散式变化”坏味道变成了“霰弹式修改（Shotgun Surgery）”坏味道，即一个变化引起多处修改。然而比起条件分支方案而言，由于不用再判断当前状态，复杂度降低了许多，可以有效减少bug的产生。</p>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>将一个状态进化为对象，这种设计思想是状态模式的设计。根据GOF的《设计模式》，一个标准的状态模式类图如下所示：</p>
<img src="/state-pattern-and-rdd/03.png" class="">

<p>当我们要设计的业务具有复杂的状态变迁时，往往通过状态图来表现。利用状态图，可以非常容易地将其转换为状态模式。状态图的每个状态被封装一个状态对象，所有状态对象实现同一个抽象接口。该抽象接口的方法则为状态图上触发状态迁移的命令。<code>Context</code>对象持有一个全局变量，用以保存当前状态对象。每个状态对象持有<code>Context</code>对象，通过<code>Context</code>访问全局的当前状态变量，以完成状态的迁移。具体的状态对象在实现状态接口时，倘若是不符合条件的命令，则实现为空，或者抛出异常。</p>
<p>依据状态图，可以实现为状态模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NodeState</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enterUshell</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exitUshell</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enterSlaveBoard</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exitSlaveBoard</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitialState</span> <span class="keyword">implements</span> <span class="title">NodeState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TelnetService telnetService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InitialState</span><span class="params">(TelnetService telnetService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.telnetService = telnetService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//login</span></span><br><span class="line">        telnetService.login();</span><br><span class="line">        <span class="keyword">this</span>.telnetService.setCurrentState(<span class="keyword">new</span> MasterShellState(telnetService));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span> </span>&#123; <span class="comment">//do nothing &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterUshell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IlegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他状态对象略</span></span><br></pre></td></tr></table></figure>

<p>在实现Telnet的transfer等命令时，这一设计却未达到意料的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TelnetService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NodeState currentState = <span class="keyword">new</span> InitialState();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(NodeState state)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// currentState到底是哪个状态？</span></span><br><span class="line">        <span class="keyword">if</span> (!currentState.isMasterShell()) &#123;</span><br><span class="line">            <span class="comment">// 需要迁移到正确的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// transfer implementation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入了状态模式后，在<code>transfer()</code>方法中仍然需要判断当前状态，这与条件分支方案何异？是状态模式存在问题吗？非也！这实际上是应用场景的问题。让我们联想一下地铁刷卡进站的场景，该场景只有Opened和Closed两个状态，其状态迁移如下图所示：</p>
<img src="/state-pattern-and-rdd/04.png" class="">

<p>比较两个状态图。对于地铁场景，当地铁门处于Closed状态时，需要支付刷卡才能切换到Opened状态，如果不满足条件，这个状态将一直保持。也就是说，对于客户端调用者而言，合法的调用只能是<code>pay()</code>，如果调用行为是<code>pass()</code>或者<code>timeout()</code>，状态对象将不给予响应。版本升级系统则不然。当系统处于Initial状态时，系统无法限制客户端调用者只能发起正确的<code>login()</code>方法。因为提供给客户端的命令操作并非<code>login()</code>、<code>enterUShell()</code>等引起状态变迁的方法，而是transfer、put等命令。同时，需求又要求无论当前处于什么状态，执行什么命令，都要迁移到正确的状态。这正是版本升级管理系统无法按照标准状态模式进行设计的原因所在。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>如果我们熟悉状态模式，针对本文的业务场景，或许会首先想到状态模式。然而，设计模式是有应用场景的，我们不能一味蛮干，或者按照模式的套路去套用，这是会出现问题的。通过分辨职责的设计方法，同时明确所谓“智能对象”的意义，我们照样可以推导出一个好的设计。我们虽然抽象出了状态对象，但抽象的方法并非引起状态迁移的行为，而是迁移状态的行为。我们没有从设计模式开始，而是从“职责”开始对设计进行驱动，这是<strong>职责驱动设计</strong>的设计驱动力。</p>
<p>当我们引入状态智能对象时，我们并没有获得一个完全遵循开放封闭原则的设计方案。实际上，当状态发生变化时，要做到对扩展完全开放是非常困难的。即使可行，在状态变化的需求是未知的情况下，为此付出太多的设计与开发成本是没有必要的。恰如其分的设计来满足当前的需求即可。当然，我们可以考虑将抽象的状态接口修改为抽象类，这样就可以把增加新方法对实现类带来的影响降低。不过，Java 8为接口提供了默认方法，已经可以规避这个问题了。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>Design Pattern</tag>
        <tag>OO</tag>
        <tag>RDD</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式编程的实践</title>
    <url>/summary-of-reactive-programming/</url>
    <content><![CDATA[<p>响应式编程在前端开发以及Android开发中有颇多运用，然而它的非阻塞异步编程模型以及对消息流的处理模式也在后端得到越来越多的应用。除了Netflix的OSS中大量使用了响应式编程之外，最近阿里也提出Dubbo 3.0版本将全面拥抱响应式编程。</p>
<p>我之前针对某些项目需求也给出了响应式编程的方案，较好地解决了并行编程与异步编程的问题。不过在深入了解响应式编程之后，我也给出了自己的一些实践总结。</p>
<h3 id="响应式编程并非银弹"><a href="#响应式编程并非银弹" class="headerlink" title="响应式编程并非银弹"></a>响应式编程并非银弹</h3><p>响应式编程并非银弹。事实上在软件领域，Brooks提出的“没有银弹”一说或许将永远生效。当我们在选择使用响应式编程时，一定要明确它的适用场景，主要包括：</p>
<ul>
<li>处理由用户或其他系统发起的事件，如鼠标点击、键盘按键或者物联网设备等无时无刻都在发射信号的情况</li>
<li>处理磁盘或网络等高延迟的IO数据，且保证这些IO操作是异步的</li>
<li>业务的处理流程是流式的，且需要高响应的非阻塞操作</li>
</ul>
<p>除此之外，我们当然也可以利用一些响应式编程框架如Rx，简化并发编程与数据流操作的实现。诸如RxJava就提供非常完整的工厂方法，可以将非响应式编程的Iterable、Array以及与响应式编程有一定相关性的Future、Callable转换为Observable或Flowable。</p>
<span id="more"></span>

<h3 id="理解Source的本质"><a href="#理解Source的本质" class="headerlink" title="理解Source的本质"></a>理解Source的本质</h3><p>Akka Stream将流数据源定义为Source，RxJava则定义为Observable或Flowable。这些响应式编程框架都为Source提供了丰富的operator。其中除了组合流的操作之外，最基本的操作即为：filter、map、flatMap、reduce等。</p>
<p>粗略看来，这些操作皆为函数式的编程接口，从FP的角度看，我们甚至可以将Source视为一个monad。而站在Java编程的角度看，我们则很容易将Source视为等同于集合的数据结构。更何况，响应式编程实则脱胎于Observer模式与Iterator模式，其中Iterator模式就是针对集合的操作，只不过Observable或Flowable是push模型，而Iterator模式则为pull模型罢了。</p>
<p>然而这就是本质的区别，即<strong>Source是一个不断发射事件（data、error、complete）的源头，具有时间序列的特点</strong>，而Iterable则是一个静态的数据结构，在对它进行操作时，该数据结构中存储的数据就已经存在了。</p>
<h3 id="合理设计Source的粒度"><a href="#合理设计Source的粒度" class="headerlink" title="合理设计Source的粒度"></a>合理设计Source的粒度</h3><p>在演示Observable或Flowable的API时，我们往往喜欢采用Fluent Interface的方式连续地调用它的operator，形成一个整体的流处理过程。这并非总是合理的。当一个Source被多个operator串联起来的时候，会使得这个Source更加<strong>难以被重用</strong>。</p>
<p>例如，在加载网页时，默认发起对后端服务的调用并返回需要的用户信息，若建模为<strong>流A</strong>，其转换如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uri ----&gt; user ----&gt; | --&gt;</span><br></pre></td></tr></table></figure>

<p>同时，有一个鼠标点击事件也会通过随机生成URL发起对后端服务的调用并返回需要的用户信息，倘若建模为<strong>流B</strong>，其转换如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">click ----&gt; uri ----&gt; user ----&gt; | --&gt;</span><br></pre></td></tr></table></figure>

<p>显然，这两个流在从uri到user的流处理上出现了重复。如果我们创建的流A与流B并不包含uri到user的转换，就可以通过merge等合并操作将A与B合并，然后再<strong>共同重用从uri到user的转换</strong>。我们也无需担心创建细粒度流的成本，因为这些流的创建是lazy的，流虽然创建了，对流的操作却不会立即执行。</p>
<h3 id="分离操作的逻辑"><a href="#分离操作的逻辑" class="headerlink" title="分离操作的逻辑"></a>分离操作的逻辑</h3><p>无论是哪个响应式框架，都为流（Source）提供了丰富的operator。这些operator多数都支持lambda表达式。在处理简单的业务逻辑时，这样的实现是没有问题的；然而一旦逻辑变得非常复杂，lambda表达式的表达能力就不够了。从编程实践看，lambda表达式本身就应该保持微小的粒度。这时，就应该将这些逻辑单独分离出来，放到单独的类与方法中。</p>
<p>例如，我们根据device的配置信息去调用远程服务获取设备信息，然后提取信息获得业务需要的指标，对指标进行转换，最后将转换的数据写入到数据库中。结合函数的转换本质，我们可以将这些操作拆分为多个连续的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deviceConfig --&gt; deviceInfo --&gt; List&lt;extractedInfo&gt; --&gt; transformedInfo --&gt; write</span><br></pre></td></tr></table></figure>

<p>倘若这些转换的逻辑非常复杂，就可以将这些逻辑分别封装到DeviceFetcher、DeviceExtractor、DeviceTransformer与DeviceWriter这四个类中，于是代码可以写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flowable.fromIterable(deviceConfigs)</span><br><span class="line">    .parallel()</span><br><span class="line">    .runOn(Schedulers.computation())</span><br><span class="line">    .map(DeviceFetcher::fetch)</span><br><span class="line">    .flatMap(DeviceExtractor::extract)</span><br><span class="line">    .map(DeviceTransformer::transform)</span><br><span class="line">    .sequential()</span><br><span class="line">    .blockingSubscribe(</span><br><span class="line">        info -&gt; DeviceWriter.write(info), </span><br><span class="line">        err -&gt; log(err), </span><br><span class="line">        () -&gt; log(<span class="string">&quot;done.&quot;</span>)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>这一实践提倡将流的操作与每个操作的业务分离开，既能够保证流操作的简单与纯粹，又能保证操作业务的重用与可扩展。</p>
<h3 id="API的设计"><a href="#API的设计" class="headerlink" title="API的设计"></a>API的设计</h3><p>如果我们要设计符合响应式编程设计的API，则应该尽可能保证每个方法都是非阻塞的。要做到这一点，就应该保证每个方法返回的类型是Source或Publisher。例如针对要返回多个数据的流，可以返回<code>Observable&lt;T&gt;</code>或者<code>Flowable&lt;T&gt;</code>；如果确定只返回一个数据，则可以返回<code>Single&lt;T&gt;</code>；倘若不确定，则返回<code>Maybe&lt;T&gt;</code>。倘若该API方法仅仅是一个命令，无需返回结果，又需要保证方法是非阻塞的，则可以考虑返回<code>Completable&lt;T&gt;</code>。</p>
<p>从某种意义上说，返回<code>Future&lt;T&gt;</code>、<code>CompletableFuture&lt;T&gt;</code>或者<code>CompletableStage&lt;T&gt;</code>也可以认为是响应式的。这三个类型由于是JDK自身提供的，因此更纯粹。唯一不便的是这些接口没有提供类似Observable那样丰富的operator，但好在Observable与Flowable都提供了<code>fromFuture()</code>方法对其进行转换，因而这样的设计也是可取的。</p>
<h3 id="Akka-Stream的流拓扑图"><a href="#Akka-Stream的流拓扑图" class="headerlink" title="Akka Stream的流拓扑图"></a>Akka Stream的流拓扑图</h3><p>Akka Stream对流处理的抽象被建模为图。这一设计思想使得流的处理变得更加直观，流的处理变成了“搭积木”游戏。可惜Java的DSL能力实在太弱，如果对比Scala与Java，你会发现GraphDSL对Graph的构造在表现上简直是天壤之别。</p>
<p>例如这是官方文档中Java版本对Graph的构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RunnableGraph.fromGraph(GraphDSL.create(builder -&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Outlet&lt;Integer&gt; A = builder.add(Source.single(<span class="number">0</span>)).out();</span><br><span class="line">    <span class="keyword">final</span> UniformFanOutShape&lt;Integer, Integer&gt; B = builder.add(Broadcast.create(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">final</span> UniformFanInShape&lt;Integer, Integer&gt; C = builder.add(Merge.create(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">final</span> FlowShape&lt;Integer, Integer&gt; D = builder.add(Flow.of(Integer.class).map(i -&gt; i + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">final</span> UniformFanOutShape&lt;Integer, Integer&gt; E = builder.add(Balance.create(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">final</span> UniformFanInShape&lt;Integer, Integer&gt; F = builder.add(Merge.create(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">final</span> Inlet&lt;Integer&gt; G = builder.add(Sink.&lt;Integer&gt;foreach(System.out::println)).in();</span><br><span class="line"></span><br><span class="line">    builder.from(F).toFanIn(C); <span class="comment">//feedback loop</span></span><br><span class="line">    builder.from(A).viaFanOut(B).viaFanIn(C).toFanIn(F);</span><br><span class="line">    builder.from(B).via(D).viaFanOut(E).toFanIn(F);</span><br><span class="line">    builder.from(E).toInlet(G);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ClosedShape.getInstance();</span><br><span class="line">&#125;)).run(mat);</span><br></pre></td></tr></table></figure>

<p>如下是官方文档中Scala版本对同一个Graph的构造：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">RunnableGraph</span>.fromGraph(<span class="type">GraphDSL</span>.create() &#123; <span class="keyword">implicit</span> builder =&gt;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">A</span>: <span class="type">Outlet</span>[<span class="type">Int</span>]                  = builder.add(<span class="type">Source</span>.single(<span class="number">0</span>)).out</span><br><span class="line">  <span class="keyword">val</span> <span class="type">B</span>: <span class="type">UniformFanOutShape</span>[<span class="type">Int</span>, <span class="type">Int</span>] = builder.add(<span class="type">Broadcast</span>[<span class="type">Int</span>](<span class="number">2</span>))</span><br><span class="line">  <span class="keyword">val</span> <span class="type">C</span>: <span class="type">UniformFanInShape</span>[<span class="type">Int</span>, <span class="type">Int</span>]  = builder.add(<span class="type">Merge</span>[<span class="type">Int</span>](<span class="number">2</span>))</span><br><span class="line">  <span class="keyword">val</span> <span class="type">D</span>: <span class="type">FlowShape</span>[<span class="type">Int</span>, <span class="type">Int</span>]          = builder.add(<span class="type">Flow</span>[<span class="type">Int</span>].map(_ + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">val</span> <span class="type">E</span>: <span class="type">UniformFanOutShape</span>[<span class="type">Int</span>, <span class="type">Int</span>] = builder.add(<span class="type">Balance</span>[<span class="type">Int</span>](<span class="number">2</span>))</span><br><span class="line">  <span class="keyword">val</span> <span class="type">F</span>: <span class="type">UniformFanInShape</span>[<span class="type">Int</span>, <span class="type">Int</span>]  = builder.add(<span class="type">Merge</span>[<span class="type">Int</span>](<span class="number">2</span>))</span><br><span class="line">  <span class="keyword">val</span> <span class="type">G</span>: <span class="type">Inlet</span>[<span class="type">Any</span>]</span><br><span class="line">  </span><br><span class="line">                <span class="type">C</span>     &lt;~      <span class="type">F</span></span><br><span class="line">  <span class="type">A</span>  ~&gt;  <span class="type">B</span>  ~&gt;  <span class="type">C</span>     ~&gt;      <span class="type">F</span></span><br><span class="line">         <span class="type">B</span>  ~&gt;  <span class="type">D</span>  ~&gt;  <span class="type">E</span>  ~&gt;  <span class="type">F</span></span><br><span class="line">                       <span class="type">E</span>  ~&gt;  <span class="type">G</span></span><br><span class="line">  <span class="type">ClosedShape</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们也看到，倘若在GraphDSL中我们能够将构成Graph的“材料”对象事先创建好，而将build工作统一放在一起，可以在一定程度改进代码的表现力。</p>
<p>我们可以将Akka Stream的Graph（完整的Graph，称为ClosedShape，是可以运行的，又称之为RunnableShape）看做是流处理的”模具“，至于那些由Inlet与Outlet端口组成的基础Shape，则是设计这些模具的”基础材料“。</p>
<p><strong>模具</strong>是静态的，<strong>基础材料</strong>与<strong>组合材料</strong>是可重用的单元，然后再组合可以重用的<strong>业务单元</strong>（以函数、类或者接口形式进行封装），这个模具就具有了业务处理能力。如果这个拓扑图过于复杂，我们还可以利用基础Shape组合形成一个个更粗粒度Partial Shap。这些Partial Shape不是封闭的，可以理解为更粗粒度的Source、Sink和Flow，它使得模具的组装变得更加简单。</p>
<p>材料、业务单元、模具之间的关系可以形象地用下图来表示：</p>
<img src="/summary-of-reactive-programming/flow-graph.jpg" class="">

<p>一旦流处理的模具打造完毕，打开数据流的”水龙头“，让数据源源不断地流入Graph中，流处理就可以”自动“运行。只要Source没有发出complete或error信号，它就将一直运行下去。Akka Stream之所以将Graph的运行器称之为materializer，大约也是源于这样的隐喻吧。</p>
<p>使用Akka Stream进行响应式流处理，我建议参考这样的思维。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Reactive Programming</tag>
        <tag>RxJava</tag>
        <tag>Akka</tag>
      </tags>
  </entry>
  <entry>
    <title>《实践领域驱动设计》目录</title>
    <url>/table-of-contect-practice-ddd/</url>
    <content><![CDATA[<p>我正在撰写《实践领域驱动设计（Practice Domain-Driven Design，暂定名）》，本书的简略版会在近几个月陆续在GitChat上发布，而完整版会充实更多内容，然后出版纸质书。</p>
<p>最近十年，我在许多项目以及咨询中都在尝试实践领域驱动设计，也体会到这种设计方法给设计质量带来的好处。当然，领域驱动设计确乎博大精深，越要尝试去掌握它，就越发发现它的深邃。</p>
<p>在进行领域驱动设计咨询和培训过程中，我深刻体会到领域驱动设计的难以落地。即使是DDD的专家，也未必能非常轻易地给初学者讲清楚如何进行领域建模，如何改进领域设计的质量。专家们当然可以设计得很好，可一旦问他们为何要这样设计，他们或许会说“by experience”；但这真不是他们的故弄玄虚，而是真实感受，因为很多设计idea其实都是只可意会不可言传的。</p>
<span id="more"></span>

<p>然而在这些项目设计、咨询与培训过程中，因为碰到这样的理解障碍，我反倒是能够设身处地地从初学者角度去思考问题，并尝试给出一些所谓的“技巧”。我当然没法达到Eric Evans的高度，内容也没法超出经典著作《领域驱动设计》的范围，但自我感觉还是有一些属于自己独到的东西，这是我写书的底气。</p>
<p>从2007年出版《软件设计精要与模式》第一版，2009年出版《软件设计精要与模式》第二版之后，近10年的时间，我没有写书，只是翻译了好几本书。这期间也曾有计划继续写与软件设计有关的书籍，也准备了不少资料。因为想写好，反而有些不敢写，拖拖踏踏至今。这些写作计划以及准备的资料仍然在我的笔记中，以后会争取做到完成写作。</p>
<p>还是回到我计划写的这本书。内容上确实参考了DDD社区的好几本经典著作，但结合了我自身的经验和心得体会，因此写到书上，可以说多数都变成了自己的内容。我不知道最后的质量会如何，但我可以自信说，这是我自己的领域驱动设计作品。顺利地话，若能在今年完成，或许能成为国内第一本讲解领域驱动设计的书籍。</p>
<p>以下是目录：</p>
<ul>
<li>第一章 领域驱动设计概览：整体介绍领域驱动设计的过程，并从软件复杂度的角度讲解领域驱动设计的价值。</li>
<li>第二章 提炼领域知识：团队与领域专家的沟通与协作，利用统一语言提炼领域知识，并引入场景驱动设计以及用例、行为驱动设计等方法帮助我们提炼领域知识。</li>
<li>第三章 限界上下文的实践意义：剖析限界上下文的本质，认识限界上下文的价值，并给出识别限界上下文的过程与方法。</li>
<li>第四章 限界上下文的协作与集成：深入剖析限界上下文之间的协作与集成模式，并为后面讲解微服务奠定基础。同时，基于Context Map重构前面识别的限界上下文。</li>
<li>第五章 运用限界上下文：给出识别和运用限界上下文的实际案例。在这一章中，会使用第三章和第四章介绍的方法与过程，对实际案例进行分析。</li>
<li>第六章 核心领域与子领域：从边界来看，限界上下文的粒度应该比module粗，但是从领域识别的角度来看，可能存在多个限界上下文属于同一个领域的情况。因而在领域驱动设计中，有必要引入一个更粗粒度的概念——核心领域与子领域。领域的划分是基于高内聚松耦合原则，从业务角度进行划分的。</li>
<li>第七章 运用设计原则重新规划架构层次：领域驱动设计的分层架构，六边形架构以及Uncle Bob提出的Clean Architecture都从架构层面是对领域驱动设计的补充。如何让这些模式与思想产生指导作用？我们需要结合在普适性的设计原则来重新审视它们。</li>
<li>第八章 领域驱动设计与微服务设计：限界上下文、核心领域、子领域，这些概念与微服务存在一定的映射关系。这也是领域驱动设计在架构模式中的价值所在。本章会结合微服务设计的角度，进一步阐释这些概念。</li>
<li>第九章 浮现领域模型：在限界上下文边界内，基于统一语言对领域进行建模。会介绍常用的建模方法，包括四色建模。</li>
<li>第十章 领域模型与编程范式：领域模型与程序设计存在指导与共同演进的关系。对领域进行建模实则就是DDD提出的模型驱动设计。如何建立模型，与选择的编程范式有关。主流的领域驱动设计以面向对象设计为主，但函数式编程思想也颇值得借鉴。</li>
<li>第十一章 表达领域模型：如何利用Entity、Value Object以及Service等构造块来表达领域模型。</li>
<li>第十二章 高质量地设计聚合：聚合在领域驱动设计中是一个相对棘手的概念。本章会给出设计聚合的原则与实践。</li>
<li>第十三章 领域对象的生命周期：运用工厂和Repository管理领域对象的生命周期。</li>
<li>第十四章 运用领域模型：讲解如何运用领域模型进行程序设计的案例，其中会运用到常用的设计模式、时序图等方法。</li>
<li>第十五章 事件驱动架构对模型的影响：以事件为设计驱动力在建模上存在不同的设计理念。以事件为驱动力，又会与Event Storming、Event Sourcing以及CQRS结合起来。本章会重点讲解event。</li>
<li>第十六章 战略设计与战术设计的融合：从战略设计到战术设计，并非一个单向的自顶向下的过程，而是螺旋式的迭代过程。当设计进入到战术阶段后，经过程序设计到编程实现，可能会发现隐藏的概念，也可能发现之前识别的限界上下文存在偏差，因而需要对前面的设计进行重构。</li>
</ul>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>艾舍尔的《画手》与尾递归</title>
    <url>/tail-recursion/</url>
    <content><![CDATA[<img src="/tail-recursion/hand.jpg" class="">

<p>这是一幅奇妙的图，如你所见，画中的两只手各自画着对方，当我们明晓这样一种怪异的循环时，一瞬间，仿佛这张静止的画突然流动起来，而且是一种永恒的运动，作画的两只手似乎永远无法停止。正如<a href="https://book.douban.com/subject/1291204/">《哥德尔艾舍尔巴赫》</a>一书的作者侯世达在评价艾舍尔的这幅《画手》时提到的：</p>
<blockquote>
<p>《画手》给我们提供了一个更紧凑的圈，这幅画中的每一只手都在画另一只手：这是个只包含两个阶段的怪圈。</p>
</blockquote>
<p>侯世达在巴赫的音乐、艾舍尔的绘画以及哥德尔不完全定理中发现了“<strong>怪圈</strong>”这个概念。</p>
<blockquote>
<p>所谓“怪圈”现象，就是当我们向上（或向下）穿过某种层次系统中的（这里，系统是音乐的调子）一些层次时，会意外地发现我们正好回到了我们开始的地方。有时我用“缠结的层次结构”这个词来形容出现怪圈的系统。</p>
</blockquote>
<p>我在阅读<a href="https://book.douban.com/subject/1291204/">《哥德尔艾舍尔巴赫》</a>这本书时，改不了作为程序员的积习，尤其当我看到这幅令人震撼的《画手》时，我即刻从“怪圈”想到了“递归（Recursion）”。因为“递归”正是这样自身调用自身的编程技巧。当然，一段正确的递归程序，必须要有一个必定能够到达或满足的终止条件，否则就会像《画手》那样永恒地循环下去。程序术语称之为“死循环”。</p>
<span id="more"></span>

<p>递归可以让代码变得极为简洁，这种逐步递减而又自我调用的方式确有一种神秘意味，然而，它却并非是一种高效的算法实现。仔细琢磨递归的运算轨迹，会发现它最终形成了“先逐步展开而后收缩的形状”，如下图所示：</p>
<img src="/tail-recursion/factorial-01.png" class="">

<p>将这种运算过程转换为scala代码，则如下所示：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(n: <span class="type">Int</span>): <span class="type">Long</span> = </span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="number">1</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><a href="https://book.douban.com/subject/1451622/">《Structure and Interpretation of Computer Programs，计算机程序的构造和解释》（简称SICP）</a>对递归进行了深刻的阐释：</p>
<blockquote>
<p>这一过程构造了一条推迟执行的操作链条，收缩阶段则表现为这些操作的实际执行。这种过程被称之为“递归过程（recursive process）”。要执行这一过程，需要解释器记录后面要执行的操作。在计算阶乘n!时，推迟执行的乘法链条的长度也就是为保存其轨迹需要保存的信息量，这个长度随着n值而线性增长，故而称为“线性递归过程（linear recursive process）”。</p>
</blockquote>
<p>正因为此，递归固然让代码变得简洁，但由于它要保存推迟执行的操作，链条越长，需要保存的信息越多，因而执行的效率取决于这条“链条”的长度。</p>
<p>让我们再回过头来看艾舍尔的《画手》。在这个左手画右手，右手画左手无限纠缠的怪圈之外，实际上“隐藏着一直未画出但正在画的手，它属于艾舍尔，左手和右手二者的创作者。”</p>
<p>“艾舍尔处于这两只手所在的空间之外”，因此能够做到旁观者清。侯世达将其视为两个不同的层次，如下图所示：</p>
<img src="/tail-recursion/draw-hand.jpg" class="">

<p>以阶乘运算为例。阶乘本身其实不应该陷入到自我调用的递归圈中，正如绘画的艾舍尔应该置身怪圈之外。<strong>递归仅应该出现在递进的运算中，每次递进的结果则作为参数传入到递归的函数中。</strong>正如SICP对阶乘运算的分析。线性递归的算法体现的是阶乘运算的朴素数学知识，即：对于一个正整数n，n!就等于n乘以(n-1)!。</p>
<p>除此之外，SICP给出了另外一种观察的视角：</p>
<blockquote>
<p>我们可以将计算阶乘n!的规则描述为：先乘1和2，而后将<strong>得到的结果</strong>乘以3，而后再乘以4，这样下去直到达到n。更形式地说，我们要维持着一个<strong>变动中的乘积product</strong>，以及一个从1到n的计数器counter。</p>
</blockquote>
<p>我们需要将计数器counter与变动的乘积product抽离出来，放到如侯世达所说的“可见的层次结构”中，即单独定义一个函数factIter：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(n: <span class="type">Int</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">  <span class="meta">@tailrec</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">factIter</span></span>(product: <span class="type">Long</span>, counter: <span class="type">Int</span>, maxCount:<span class="type">Int</span>): <span class="type">Long</span> =</span><br><span class="line">    <span class="keyword">if</span> (counter &gt; maxCount) product</span><br><span class="line">    <span class="keyword">else</span> factIter(product * counter, counter+<span class="number">1</span>, maxCount)</span><br><span class="line">  factIter(<span class="number">1</span>, <span class="number">1</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在factorial函数内部定义的函数factIter实现了递归，它有一个特征是方法的尾部是且只能是对函数自身的调用。</p>
<p>product变量就是前面我所谓的“每次递进的结果”，也就是SICP中提到的“变动中的乘积”。准确来讲，应该将product看作是一个<strong>accumulator</strong>。它每次存储的都是每一步计算的结果，然后通过其汇集，最后收获最终的运算结果。至于counter与maxCount变量的引入，不过是为了完成递进的运算，以及给出终止运算的满足条件而已。</p>
<p>SICP认为：</p>
<blockquote>
<p>（这种运算过程）并没有任何增长或者收缩。对于任何一个n，在计算过程中的每一步，在我们需要保存的轨迹里，所有的东西就是变量product、counter和maxCount的当前值。我们称这种过程为一个<strong>迭代过程（iterative process）</strong>……在计算n!时，所需的计算步骤随着n线性增长，因而被称为线性迭代过程（linear iterative process）。</p>
</blockquote>
<p>由于其特性是内部的函数总是在函数尾部被递归调用，故而这种调用方式又被称之为<strong>尾递归（tail recursive）</strong>。它的执行过程如下图所示：</p>
<img src="/tail-recursion/factorial-02.png" class="">

<p>我们可以比较前面线性递归过程的执行结果，很显然，线性迭代过程的执行步骤要远远少于前者。本质上，虽然尾递归名为“递归”，其实执行的是一个迭代过程。在Scala或者其他很多语言中，尾递归就是一种编译技巧。例如当Scala发现某个递归调用其实是一个尾递归时，会自动将该递归编译为循环迭代，从而避免了每次进行栈的操作（因为递归需要记录延迟运算）。Scala还提供了@tailrec标记来标识尾递归。若你编写的递归函数不是尾递归，只要标记了@tailrec，编译时会提示错误。</p>
<p>要将一个递归过程编写为迭代过程，而又要避免显示地循环调用方式，关键之处就在于我们要转换视角（跳出互相绘制的两只手）。个人认为，“四两拨千斤”的着眼点就是<strong>寻找accumulator</strong>。</p>
<p>我在项目中希望对一个类似树结构的样例类做一次“拍平”的操作。定义如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingElement</span>(<span class="params">itemType: <span class="type">BindingItemType</span>, fieldId: <span class="type">ID</span>, children: <span class="type">Option</span>[<span class="type">List</span>[<span class="type">BindingElement</span>]]</span>)</span></span><br></pre></td></tr></table></figure>

<p>BindingElement的内部“可能”嵌套了子的BindingElement列表。而子列表中的BindingElement也可能继续嵌套。如此的嵌套自然就形成了一棵树，且非最简单的二叉树。</p>
<p>需求要求将根节点BindingElement嵌套的所有子节点（包括间接嵌套）全部拍平，最后形成一个没有任何子节点的BindingElement列表。</p>
<p>我在实现时，直觉告诉我这个“拍平”的动作其实就是对一棵树的遍历，完全可以用尾递归来完成。可是写了许久，都未能将这个尾递归函数实现。问题的症结就是我没有去寻找关键的accumulator。实质上，针对这个场景，我们要返回的结果是<code>List[BindingElement]</code>，在迭代过程中，就是每次叠加的值。初始值则为Nil。这里没有阶乘运算中的counter与maxCount，而是一个作为children的<code>List[BindingElement]</code>。因为参与递归的结构是列表中每个BindingElement中的children，对于List而言，我们可以判断其值是否为Nil来作为终止条件。</p>
<p>找到了accumulator，尾递归的迭代算法自然就水到渠成了。代码如下所示：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingElement</span>(<span class="params">itemType: <span class="type">BindingItemType</span>, fieldId: <span class="type">ID</span>, children: <span class="type">Option</span>[<span class="type">List</span>[<span class="type">BindingElement</span>]]</span>) </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatten</span></span>:<span class="type">List</span>[<span class="type">BindingElement</span>] = &#123; </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneToLeaf</span></span>(item: <span class="type">BindingElement</span>) = <span class="type">BindingElement</span>(item.itemType, item.fieldId, <span class="type">None</span>) </span><br><span class="line"></span><br><span class="line">    <span class="meta">@tailrec</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse</span></span>(items: <span class="type">List</span>[<span class="type">BindingElement</span>], acc: <span class="type">List</span>[<span class="type">BindingElement</span>]): <span class="type">List</span>[<span class="type">BindingElement</span>] = </span><br><span class="line">      items <span class="keyword">match</span> &#123; </span><br><span class="line">        <span class="keyword">case</span> <span class="type">Nil</span> =&gt; acc </span><br><span class="line">        <span class="keyword">case</span> head :: tail =&gt; traverse(head.children.getOrElse(<span class="type">Nil</span>) ::: tail, acc :+ cloneToLeaf(head)) </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    traverse(children.getOrElse(<span class="type">Nil</span>), <span class="type">List</span>[<span class="type">BindingElement</span>](cloneToLeaf(<span class="keyword">this</span>))) </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里的acc（即accumulator）在Scala中其实是一个不变的变量；所以通过运算符<code>:+</code>添加元素项后得到的是另外一个List。然而，作为accumulator，其实它是以参数形式传递给下一个迭代，故而下一次迭代中的acc已经变成了累加了元素后的结果，这是traverse函数之所以能够奏效的原因。</p>
<p>因为尾递归函数tranverse遍历的是<code>List[BindingElement]</code>，这会导致返回的结果会缺失根元素自身，所以在初始化acc时，将根元素（即this）赋值给了acc。</p>
<p>递归充满了艺术的神秘美感，而尾递归则在艺术美与工程高效之间取得了平衡。《画手》的两个层次（可见的和不可见的）给了我们一个启发，就是在观察事物时，需要尝试不同的视角，要学会跳出具体的实现细节，找到职责上的抽象分解。对于程序员而言，我们还可以尝试跳出计算机科学的范畴，从绘画、数学、建筑或者音乐中寻找到灵感，利用跨界思想来体悟软件设计与编程。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Scala</tag>
        <tag>FP</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据流处理平台的技术选型参考</title>
    <url>/technical-choice-of-streaming-platform/</url>
    <content><![CDATA[<p>选择太多，是一件好事情，不过也容易乱花渐欲迷人眼。倘若每个平台（技术）都去动手操练一下，似乎又太耗时间。通过阅读一些文档，可以帮我们快速做一次筛选。在将选择范围进一步缩小后，接下来就可以结合自己的应用场景去深入Spike，做深度的甄别，这是我做技术选型的一个方法。</p>
<p>技术没有最好，只有最适用。在做技术选型时，需要选择适合需求、适合项目类型、适合团队的技术。这是实用主义的判断，而非理想主义的追捧。若是在实用的技术选型中，再能点燃一些些技术上的情怀，那就perfect了！</p>
<h3 id="属性矩阵-Attributes-Matrix"><a href="#属性矩阵-Attributes-Matrix" class="headerlink" title="属性矩阵(Attributes Matrix)"></a>属性矩阵(Attributes Matrix)</h3><p>我在《<a href="https://iamzhangyi.github.io/Apache-Streaming-Projects/">Apache下流处理项目巡览</a>》一文中翻译了Janakiram的这篇文章，介绍了Apache基金会下最主流的流处理项目。巧的是，我在<a href="http://www.infoq.com/cn/articles/overview-of-apache-streaming-technology">InfoQ</a>上又发现了Ian Hellstrom的文章，他用一张图给出了非常棒的总结。</p>
<span id="more"></span>

<p>为了更好地阅读，我将这张图的内容转成如下的矩阵表。由于Ian的文章是2016年撰写的，我对其内容做了适度更新。</p>
<p><strong>表一: 流平台的质量属性</strong></p>
<p>流平台 | 当前版本 | 主要推动者 | Event Size | 消息传递保证 | 状态管理<br>— | — | — | — | — | — | —<br>Flume | 1.8.0 | Apple, Cloudera | single | at least once | 事务型更新<br>NiFi | 1.5.0 | Hortonworks | single | at least once | 本地及分布式快照<br>Gearpump | 0.8.4 | single | Intel, Lightbend | exactly once，若不需要支持容错，则为at least once | checkpoints<br>Apex | Apex Core 3.6.0, Apex Malhar 3.8.0 | Data Torrent | single | exactly once | checkpoints<br>Kafka Streams | 1.0 | Confluent | single | at least once | 本地及分布式快照<br>Spark Streaming | 2.2.1 | AMPLab, Databricks | micro-batch | exactly once，若不需要支持容错，则为at least once | checkpoints<br>Storm | 1.1.1 | Backtype, Twitter | single | at least once | record acknowledgements<br>Samza | 0.14.0 | Linkedin | single | at least once | 本地快照，分布式快照则支持容错<br>Flink | 1.4.0 | dataArtisans | single | exactly once | 分布式快照<br>Ignite Streaming | 2.3.0 | GridGain | single | at least once | checkpoints<br>Beam | 2.2.0 | Google | single | exactly once | 事务型更新</p>
<p><strong>表一（续）：流平台的质量属性</strong></p>
<p>流平台 | 容错 | 处理顺序 | 事件的优先级 | Windowing | Back-pressure(背压）<br>— | — | — | — | — | — | —<br>Flume | yes(只针对file channel) | no | no | no | no<br>NiFi | yes | no | yes | no | yes<br>Gearpump | yes | yes | programmable | time-based | yes<br>Apex | yes | no | programmable | time-based | yes<br>Kafka Streams | yes | yes | programmable | time-based | N/A<br>Spark Streaming | yes | no | programmable | time-based | yes<br>Storm | yes | yes | programmable | time-based, count-based | yes<br>Samza | yes | yes(单分区情况则不支持) | programmable | time-based, count-based | yes<br>Flink | yes | yes | programmable | time-based, count-based | yes<br>Ignite Streaming | yes | yes | programmable | time-based, count-based | yes<br>Beam | yes | yes | programmable | time-based | yes</p>
<p><strong>表一（再续）：流平台的质量属性</strong></p>
<p>流平台 | 数据抽象 | 数据流 | 延迟 | 资源管理 | Auto-scaling<br>— | — | — | — | — | — | —<br>Flume | Event | agent | low | native | no<br>NiFi | FlowFile | flow | configurable | native | no<br>Gearpump | Message | streaming application | very low | YARN | no<br>Apex | Tuple | streaming application | very low | YARN | yes<br>Kafka Streams | KafkaStream | process topology | very low | YARN, Mesos, Chef, Puppet, Salt, Kubernetes等 | yes<br>Spark Streaming | DStream | application | medium | YARN, Mesos | yes<br>Storm | Tuple | topology | very low | YARN, Mesos | no<br>Samza | Message | job | low | YARN | no<br>Flink | DataStream | streaming dataflow | low(configurable) | YARN | no<br>Ignite Streaming | IgniteDataStreamer | job | very low | YARN, Mesos | no<br>Beam | PCollection | pipeline | low | integrated | yes</p>
<p><strong>表一（终）：流平台的质量属性</strong></p>
<p>流平台 | 热修改 | API | 主要开发语言 | API语言<br>— | — | — | — | — | — | —<br>Flume | no | declarative | Java | text files, Java<br>NiFi | yes | compositional | Java | REST(GUI)<br>Gearpump | yes | declarative | Scala | Scala, Java<br>Apex | yes | declarative | Java | Java<br>Kafka Streams | yes | declarative | Java | Java<br>Spark Streaming | no | declarative | Scala | Scala, Java, Python<br>Storm | yes | compositional | Clojure | Scala, Java, Clojure, Python, Ruby<br>Samza | no | compositional | Scala | Java<br>Flink | no | declarative | Java | Java, Scala, Python<br>Ignite Streaming | no | declarative | Java | Java, .NET, C++<br>Beam | no | declarative | Java | Java</p>
<h3 id="数据流模型"><a href="#数据流模型" class="headerlink" title="数据流模型"></a>数据流模型</h3><p>在进行流数据处理时，必然需要消费上游的数据源，并在处理数据后输出到指定的存储，以待之后的数据分析。站在流数据的角度，无论其对数据的抽象是什么，都可以视为是对消息的生产与消费。这个过程是一个数据流（data flow），那么负责参与其中的设计元素就可以称之为是“<strong>数据流模型（Data flow model）</strong>”。</p>
<p>不同流处理平台的数据流模型有自己的抽象定义，也提供了内建的支持。我针对Flume、Flink、Storm、Apex以及NiFi的数据流模型作了一个简单的总结。</p>
<h4 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h4><p>Flume的数据流模型是在Agent中由Source、Channel与Sink组成。</p>
<img src="/technical-choice-of-streaming-platform/flume.png" class="">

<p>内建的Source支持：</p>
<ul>
<li>Avro</li>
<li>Thrift</li>
<li>JMS</li>
<li>Taildir</li>
<li>Exec</li>
<li>Spooling Directory</li>
<li>Twitter</li>
<li>Kafka</li>
<li>NetCat</li>
<li>Sequence Generator</li>
<li>Syslog</li>
<li>HTTP</li>
</ul>
<p>内建的Sink支持：</p>
<ul>
<li>HDFS</li>
<li>Hive</li>
<li>Logger</li>
<li>Avro</li>
<li>Thrift</li>
<li>IRC</li>
<li>File Roll</li>
<li>HBase</li>
<li>Solr</li>
<li>Elasticsearch</li>
<li>Kite Dataset</li>
<li>Kafka</li>
<li>HTTP</li>
</ul>
<p>Flume还支持自定义Source、Sink与Channel。</p>
<h4 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h4><p>Flink将数据流模型抽象为Connector。Connector将Source与Sink连接起来，一些特殊的connector则只有Source或Sink。Flink定义的connector包括：</p>
<ul>
<li>Kafka（支持Source/Sink）</li>
<li>Elasticsearch（仅为Sink）</li>
<li>HDFS（仅为Sink）</li>
<li>RabbitMQ（支持Source/Sink）</li>
<li>Amazon Kinesis Streams（支持Source/Sink）</li>
<li>Twitter（仅为Source）</li>
<li>NiFi（支持Sink/Source）</li>
<li>Cassandra（仅为Sink）</li>
<li>Redis、Flume和ActiveMQ（仅为Sink）</li>
</ul>
<p>Flink也支持用户自定义Connector。</p>
<h4 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h4><p>Storm对数据流模型的抽象则形象地定义为Spout和Bolt。为了支持其他数据源的读取，并将数据存储到指定位置，Storm提供了与诸多外部系统的集成，并针对这些外部系统去定义对应的Spout与Bolt。</p>
<img src="/technical-choice-of-streaming-platform/storm-flow.png" class="">

<p>Storm集成的外部系统包括：</p>
<ul>
<li>Kafka：通过<code>BrokerHosts</code>的<code>ZKHosts</code>支持Spout</li>
<li>HBase：提供<code>HBaseBolt</code></li>
<li>HDFS：提供<code>HdfsBolt</code></li>
<li>Hive：提供<code>HiveBolt</code></li>
<li>Solr：提供<code>SolrUpdateBolt</code>与对应的Mapper</li>
<li>Canssandra：提供<code>CassandraWriterBolt</code></li>
<li>JDBC：提供<code>JdbcInsertBolt</code>与<code>JdbcLookupBolt</code>等</li>
<li>JMS：提供JMS Spout与JMS Bolt</li>
<li>Redis：提供<code>RedisLookupBolt</code>、<code>RedisStoreBolt</code>与<code>RedisFilterBolt</code>等</li>
<li>Event Hubs：提供了Event Hubs Spout</li>
<li>Elasticsearch：提供<code>EsIndexBolt</code>、<code>EsPercolateBolt</code>与<code>EsLookupBolt</code>等</li>
<li>MQTT：MQTT主要用于物联网应用的轻量级发布/订阅协议，提供了对应的Spout</li>
<li>MongoDB：提供了<code>MongoInsertBolt</code>、<code>MongoUpdateBolt</code></li>
<li>OpenTSDB</li>
<li>Kinesis</li>
<li>Druid</li>
<li>Kestrel</li>
</ul>
<p>Storm和Storm Trident都支持用户自定义Spout和Bolt。</p>
<h4 id="Apex"><a href="#Apex" class="headerlink" title="Apex"></a>Apex</h4><p>Apex将数据流模型称之为Operators，并将其分离出来，放到单独的Apex Malhar中。对于Source，它将其称之为Input Operators，对于Sink，则称为Output Operators，而Comput Operators则负责对流数据的处理。</p>
<img src="/technical-choice-of-streaming-platform/malhar-operators.png" class="">

<p>Apex Malhar支持的Input/Output Operators包括：</p>
<ul>
<li>文件系统：支持存储到HDFS、S3，也可以存储到NFS和本地文件系统</li>
<li>关系型数据库：支持Oracle、MySQL、Sqlite等</li>
<li>NoSQL数据库：支持HBase、Cassandra、Accumulo、Aerospike、MongoDB和CouchDB</li>
<li>消息系统：支持对Kafka、JMS、ZeroMQ和RabbitMQ消息的读写</li>
<li>通知系统：支持通过SMTP发送通知</li>
<li>内存数据库和缓存：支持Memcached和Redis</li>
<li>社交媒体：支持Twitter</li>
<li>协议：支持HTTP、RSS、Socket、WebSocket、FTP和MQTT</li>
</ul>
<p>毫无疑问，Apex也支持用户自定义Operator。除了可以用Java编写之外，还可以使用JavaScript、Python、R和Ruby。</p>
<h4 id="NiFi"><a href="#NiFi" class="headerlink" title="NiFi"></a>NiFi</h4><p>NiFi对流模型的主要抽象为Processor，并且提供了非常丰富的数据源与数据目标的支持。</p>
<img src="/technical-choice-of-streaming-platform/nifi-arch.png" class="">

<p>常用的数据采集方法包括：</p>
<ul>
<li>GetFile</li>
<li>GetFtp</li>
<li>GetSFtp</li>
<li>GetJMSQueue</li>
<li>GetJMSTopic</li>
<li>GetHTTP</li>
<li>ListenHTTP</li>
<li>ListenUDP</li>
<li>GetHDFS</li>
<li>ListHDFS / FetchHDFS</li>
<li>FetchS3Objet</li>
<li>GetKafka</li>
<li>GetMongo</li>
<li>GetTwitter</li>
</ul>
<p>发送数据的方法包括：</p>
<ul>
<li>PutEmail</li>
<li>PutFile</li>
<li>PutFTP</li>
<li>putSFTP</li>
<li>PutJMS</li>
<li>PutSQL</li>
<li>PutKafka</li>
<li>PutMongo</li>
</ul>
<p>Nifi也支持用户自定义Processor，例如通过继承NiFi定义的<code>AbstractProcessor</code>类。自定义的Processor可以和内建的Processor一样添加到NiFi定义Flow的GUI上，并对其进行配置。</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Streaming</tag>
        <tag>Big Data</tag>
      </tags>
  </entry>
  <entry>
    <title>GitChat独家采访：聊聊领域驱动设计</title>
    <url>/talking-with-gitchat-about-ddd/</url>
    <content><![CDATA[<img src="/talking-with-gitchat-about-ddd/ddd-tactic.jpeg" class="">

<p>相信很多朋友对领域驱动设计会有这样或那样的困惑，比如领域驱动设计是什么？它在工作中有什么作用？为什么国内关于这方面的书籍少之又少？……为了解决这些困惑，有幸邀请到专家张逸老师来聊聊领域驱动设计，下面是GitChat独家采访记录。</p>
<span id="more"></span>

<p>GitChat：在探讨领域驱动设计问题时，每个人都有每个人的认识，有的时候可能谁也无法说服对方，这时候该怎么办呢？</p>
<p>张逸：简单说，就是show me your code。不管领域设计做得怎么样，最终都是要落地的，看实现的效果最有说服力。当然，为了保证交流的顺畅与效率，代码这种形式可能容易让人迷失到纷繁复杂的细节中去，因此还有一种方式就是show me your model。</p>
<p>这里说的model就是领域模型。注意，团队在交流领域驱动设计问题时，不应该只是对建模活动的产出物进行讨论，建模的过程同样非常重要。现在诸如Event Storming等活动都非常强调利用可视化手段把业务专家与开发团队都包含进来，大家一块协作一块交流，并利用便利贴等工具直观地展现建模活动中的每一个步骤，可以更容易消除误会与分歧。</p>
<p>GitChat：可以谈谈领域驱动设计的流程吗？比如是先建模？还是做设计？以及应用的场景是什么？</p>
<p>张逸：领域驱动设计强调的是将分析、设计与实现统一到一个领域模型中来，同时又相对清晰地划分为战略设计和战术设计两个阶段。当然，这两个阶段并非瀑布式的，而是迭代和演进的过程。</p>
<p>我认同领域模型对分析、设计与实现的统一，这个思想没有问题。但在我亲身经历的项目中，我还是发现由于沟通角色与建模目标的不同，分析、设计与实现在三个不同的活动是无法完全统一的，就好像在重构时不能实现新功能，这三顶帽子自然也不能同时戴起来。因此，我在《领域驱动战术设计实践》GitChat课程中，清晰地将这三个活动称之为领域分析建模、领域设计建模与领域实现建模，它们各自的产出是领域分析模型、领域设计模型与领域实现模型，这三者合起来就是领域模型，而这个过程就是领域模型驱动设计。</p>
<p>之所以在模型驱动设计前面加上“领域”作为定语，是因为我认为二者不能划等号，例如采用数据模型的，同样是模型驱动设计。在《领域驱动战术设计实践》GitChat课程中，我根据建模视角的不同，将其分别定义为数据模型驱动设计、服务模型驱动设计、领域模型驱动设计，并用了相当篇幅的内容分别介绍了这三种不同的模型驱动设计过程。</p>
<p>GitChat：针对一些设计能力不足的开发团队，可以采用领域驱动设计来改进设计和编码质量吗？</p>
<p>张逸：我个人的观点，这二者之间有关系，但并非必要关系。领域驱动设计的关键不是设计能力，而是要抓住设计的驱动力，必须是领域，且必须要求领域专家参与到分析建模活动中来。</p>
<p>要说明的是，这个所谓“领域专家”不是一个头衔，也不是对技能级别的要求，它其实就是一个指代，代表“懂业务”的人：可以是客户，可以是Product Owner，可以是业务分析师，可以是产品经理，也可以是懂业务的开发人员，甚至可以是一个负责业务分析的团队。</p>
<p>领域驱动设计能否成功，还是要看建模尤其是分析建模做得是否足够好，这其实是整个设计过程的上游。至于设计能力，则要看领域驱动设计与什么样的编程范式结合？常见的编程范式包括结构范式、对象范式和函数范式。所以这里的“设计能力不足”，究竟指的是哪方面的设计能力不足呢？</p>
<p>当然，从主流的领域驱动设计来看，主要采用的还是对象范式的设计思想与领域驱动设计结合，这就要求团队掌握基本的面向对象设计能力。这方面能力不足的团队，确实会影响到最终的设计和编码质量。这是必须要正视的问题，因此我建议那些希望实践领域驱动设计的团队，不要忘了去提高团队的面向对象设计能力。</p>
<p>提升设计能力并非一朝一夕就可以做到。正是考虑到面向对象设计能力不足对领域驱动设计的影响，我在《领域驱动战术设计实践》GitChat课程中尝试总结了一个<strong>相对固化</strong>的设计过程。这个过程结合了DCI、职责驱动设计等设计方法，它不要求团队掌握太多面向对象设计思想、原则与模式，只要懂业务，完全可以以“知其然而不知其所以然”的方式去实践领域驱动设计。</p>
<p>这种方法不能让你的设计变得非常优秀，却可以保证你的设计不至于太糟糕，甚至可以说是不错的设计。</p>
<p>GitChat：应用服务与领域服务的区别是什么呢？</p>
<p>张逸：这个是老生常谈的问题了。从分层架构的角度看，应用服务属于应用层，领域服务属于领域层。应用层是一个包装的外观，按照该层的职责来说，应用服务根本就不该干业务的活儿，它只是一个对外公开的接口而已。</p>
<p>从业务粒度看，应用服务的每个公开方法会对应一个具有业务价值的业务场景或者说用例。领域服务则不然，它实现了业务功能，这个业务功能或者是无状态的，又或者是因为需要协调多个聚合，又或者需要和外部资源协作。</p>
<p>在针对业务场景驱动设计时，应用服务的一个方法往往会暴露给调用者，然后它再将该请求委派给领域层的对象。一般要求领域服务的粒度要小，这样可以避免设计为事务脚本的过程方式，也可以在一定程度上避免贫血模型。</p>
<p>总结：</p>
<ul>
<li>应用服务：一组面向业务场景的业务外观方法，只是一个对外提供接口、对内分配职责的协作对象，属于应用层。</li>
<li>领域服务：一个领域服务对应最多一个业务场景，往往需要和聚合、Repository、甚至领域服务一起协作。</li>
</ul>
<p>GitChat：已经上线的《领域驱动战略设计实践》与刚上线的《领域驱动战术设计实践》之间的区别是？有学习的先后顺序吗？</p>
<p>张逸：这两个课程刚好对应领域驱动设计的战略设计与战术设计。</p>
<p>前者强调系统层面的架构模式，包括限界上下文、上下文映射、分层架构等，可以运用这些模式对整个系统的领域进行“分而治之”，从而降低业务复杂度，同时围绕“领域”为核心，建立业务复杂度与技术复杂度的边界。</p>
<p>后者强调领域层面的设计模式，以“模型驱动设计”为主线，贯穿分析、设计与编码实现这三个不同的建模活动，并引入领域驱动设计的战术设计要素，如实体、值对象、领域服务、领域事件、聚合、资源库、工厂等。</p>
<p>当然在我的《领域驱动战术设计实践》课程中，我扩大了领域驱动战术设计的范畴，讲解了数据模型驱动与服务模型驱动，探讨了建模范式与编程范式之间的关系。同时，在设计过程中，我引入了职责驱动设计和DCI模式来阐释实体、值对象、领域服务与应用服务之间的协作关系。在编码实现过程中，我又引入了测试驱动开发来推进从设计模型到实现模型。</p>
<p>战略设计和战术设计并非单向的过程，而是一个迭代演进与不断融合的过程。整体来讲，前者更偏向于架构设计，后者更偏向于详细设计与编码。主要还是看读者的关注点与侧重点，并没有一个绝对的学习先后顺序。我个人还是建议先学习《领域驱动战略设计实践》，虽然它更偏向于理论，难度更高一些，但是它毕竟概括了领域驱动设计的全貌。</p>
<p>GitChat：<strong>战略</strong>这个课程分析了“EAS 系统”，在<strong>战术</strong>课程也介绍了“EAS 系统”，两者的侧重点有什么不同吗？</p>
<p>张逸：与战略设计和战术设计的侧重点一样，在战术课程中，会针对EAS系统进行领域建模，并最终对其进行编码实现。从内容来看，后者会更接地气一些，毕竟讲的是落地的实现。</p>
<p>将战略和战术的EAS系统案例结合起来，就是一个系统的完整设计案例了。</p>
<hr>
<p>购买我在GitChat上发布的《领域驱动战略设计实践》+《领域驱动战术设计实践》套餐，请扫描下图的二维码：</p>
<img src="/talking-with-gitchat-about-ddd/ddd-all.jpeg" class="">

<p>购买我在GitChat上发布的《领域驱动战略设计实践》课程，请扫描下图的二维码：</p>
<img src="/talking-with-gitchat-about-ddd/ddd-strategy.jpeg" class="">

<p>购买我在GitChat上发布的《领域驱动战术设计实践》课程，请扫描下图的二维码：</p>
<img src="/talking-with-gitchat-about-ddd/ddd-tactic-small.jpeg" class="">


]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>主题数据区的设计</title>
    <url>/the-design-of-topic-data/</url>
    <content><![CDATA[<p>关于主题数据区的设计，首先需要明确的是按照什么对数据进行归类。大的原则，当然还是按照业务来分类，但是分类的出发点不同，划分的类别也不相同。例如针对机场数据，可以从业务特征分类，那么可以分为运行保障、旅客服务、航班资源等；如果按照功能区分类，则可以分为空侧、陆侧、航站楼侧等。</p>
<span id="more"></span>

<p>不管采用什么原则对数据进行分类，我认为都需要遵循以下两个原则：</p>
<ul>
<li>保证数据的分类是正交的：正交的数据分类可以避免数据的重复。例如航班与旅客存在关联关系，但只允许这二者之间存在一个交点，旅客的信息不允许出现在航班中，航班的信息也不允许出现在旅客中。如果需要，通过主外键关联。</li>
<li>保证数据类别的抽象层次处于同一个层次：这是SLAP（单一抽象层次原则）的体现，如果数据类别的层次不一致，就会失去数据的平衡。例如航班主题与货运主题就不在一个抽象层次上，货运主题与行李主题为同一抽象层，两者的共同抽象为物流，物流主题与航班主题才是同一个抽象层次。</li>
</ul>
<p>当然，对于主题数据区的数据，从分类的依据看，在满足以上两个原则的基础上，我认为还是应贴近<strong>数据特征</strong>的角度进行类别划分，并尽量保障数据的类别是正交的，同时在保证数据存取性能的前提下，力求更细的数据粒度。而在数据集市区，才会根据不同的业务流程、业务目标去建立集市。建立集市的基础是主题数据，一个正交的主题数据（甚至可能遵循三范式）才能更好地满足集市的业务需求，对其进行重用。</p>
<p>所谓“数据特征”，就是该数据的本质属性，是体现了最基础特征信息的数据。这就要求对数据进行抽象，撇开数据源对业务的影响，也要撇开业务场景对分类的影响。可能符合某个数据特征的数据同时来自多个系统，也可能它同时为多个业务场景提供服务。在机场数据领域，最根本的具有本质属性的数据就是：</p>
<ul>
<li>航班</li>
<li>旅客</li>
<li>物流</li>
<li>资源</li>
<li>气象</li>
<li>……</li>
</ul>
<p>在确定了第一级主题（也可以认为是主题域，即subject area）后，在讨论下一级数据分类时，我们出现了分歧。最初提出的类别草案中，将“航班旅客信息”放到了旅客主题中，该信息包括：</p>
<ul>
<li>值机截载旅客统计信息</li>
<li>登机截载旅客统计信息</li>
<li>起飞截载旅客统计信息</li>
<li>实时旅客数据：如实时值机人数、实时登机人数、实时安检人数</li>
<li>累计旅客数据：如累计值机人数、累计登机人数、累计安检人数</li>
</ul>
<p>我认为这种划分是不合理的，虽然这里的信息都与旅客相关，但这些信息并非旅客的明细数据，同时它又与具体某个航班是粘连在一起的。到底该怎么归属呢？类似这样的场景，旅客的一些数据在特性上无法清晰地界定到底属于哪一个主题，因为在关系上，可能这些数据属性与两个乃至多个主题都存在一定关系，分类时就容易混淆。</p>
<p>我提出了解决此类数据分类的两个原则：</p>
<ul>
<li>主次之分：判断该数据属性所关联的主题究竟以谁为主。以航班旅客信息为例，我们应该思考这些信息到底是以航班为主，还是旅客为主？</li>
<li>强弱之分：判断该数据属性与哪一个主题关联更强，哪一个主题关联更弱。若还是无法分清，可以看看当变化发生时，对谁的影响更大？ 仍然以航班旅客信息，如这里的截载旅客统计信息，究竟是与航班关联更紧密，还是与旅客关联更紧密？从变化上看，可能更清楚。例如当实时值机人数发生了变更，究竟是对当前航班影响更大，还是对某位旅客的信息影响更大？</li>
</ul>
<p>不言而喻，无论是“主次之分”还是“强弱之分”，我们都可以清晰地分辨出航班旅客信息更多地是与航班相关，故而应分属于“航班”主题。</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Big Data</tag>
        <tag>Data Warehouse</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动建模与面向对象建模的差异</title>
    <url>/the-difference-between-ddd-and-oo/</url>
    <content><![CDATA[<p>即便采用面向对象建模范式，领域驱动设计的建模仍与面向对象建模存在较大差异，原因在于领域驱动设计引入了<strong>限界上下文（Bounded Context）</strong>与<strong>聚合（Aggregate）</strong>，使得建模的风景变得迥然不同。二者为领域模型引入了边界的约束，使得建模者不能随心所欲地建模，亦改变了模型的面貌。</p>
<p>在我的《解构领域驱动设计》一书中，提炼了领域驱动设计之精髓，在于对边界的控制。其中，限界上下文与聚合是解空间边界控制中最为重要的两个要素。我们构建的领域模型必然位于限界上下文中，构成领域模型中的主力军——实体和值对象——又必然位于聚合的边界内：</p>
<span id="more"></span>

<img src="/the-difference-between-ddd-and-oo/boundary.png" class="">



<p>虽然限界上下文只是逻辑边界，但它的<strong>自治</strong>特性需要保证其内部领域模型的独立性，建模时，必须避免出现跨限界上下文之间领域模型的直接引用。至于聚合之间的协作，社区的大多数声音认为：聚合之间需通过根实体的ID建立协作关系。</p>
<p>限界上下文与聚合边界的约束，使得我们需要重新正视领域模型类之间的关系，在面向对象世界中，设计者耳熟能详的继承、组合、依赖关系，可能需要做出改变。</p>
<p>以教育领域之用户模型为例。学生、教师、家长是3种不同类型的用户，各自业务不同，又有一些共用业务，如：修改密码。从面向对象的角度思考模型的建立，自然会想到通过为它们建立继承关系，将用户定义为基类，封装共同的领域逻辑满足复用的要求。由此形成如下的领域模型：</p>
<img src="/the-difference-between-ddd-and-oo/OO-user.png" class="">



<p>我将限界上下文视为<strong>领域模型的知识语境</strong>，通过它形成领域知识的逻辑边界。对相同的一个领域概念因为观察视角的不同，需要关注的领域知识（属性与行为）各有不同。犹如盲人摸象，在此，并非讽刺盲人只见大象之局部而错以为是整头大象，相反，代表了一种正面的含义，即从当前上下文观之，虽然明知此乃大象之局部，我仍然认为它就是大象之整体。</p>
<img src="/the-difference-between-ddd-and-oo/elephant.png" class="">    



<p>无论现实世界还是软件世界，谁又能穷尽任意一个领域概念的全部呢？就以“人”这一领域概念而言，在居民身份管理系统中，关注公民这一身份，除了姓名、性别、出生年月等基本信息之外，需关注籍贯、户籍所在地、照片等与公民身份有关的重要属性；在员工管理系统中，关注的内容又变成角色、职位以及教育背景、工作经验等与员工能力息息相关的属性。如果将一个“人”的所有属性加在一起，可以认为是一头完整的“大象”的话，居民身份管理系统与员工管理系统看到的“人”，何尝不像是盲人看到的大象局部呢？而在各自的上下文中，公民与员工就是当前需要关注的全部了。</p>
<p>系统如此，限界上下文亦如此，只是边界更小罢了。因而在教育领域的身份上下文，用户的全部就是诸如姓名、账号、密码以及身份认证等领域知识；切换到学籍上下文，知识语境发生了变化，用户变为了学生，关注的领域知识不再是对身份的认证，而是对学生信息如学籍号的管理，此时的家长，作为学生附带属性的一部分，表达了学生的家庭关系，抽象其概念，可以表示为“家庭成员”；再切换到教务上下文，则需要建立以教师、课程、年级、班级为核心的领域模型，此时的学生概念，变成了教学活动的参与者，建立了班级与学生之间的关系，需要明确学生的“学号”而非“学籍号”，抽象其概念，实则代表了“班级成员”。</p>
<p>在各自知识语境的界定下，如果仍然要保持学生、家长、教师与用户之间的继承关系，就显得“不合时宜”了。本质上，它们是同一个概念在不同语境下的局部知识，在切换上下文时，每个建模者看到的局部概念，都应视为一个整体，如果让学籍管理上下文的学生继承自身份管理上下文的用户，就好似让一头“局部的大象”去继承另外一头“局部的大象”，真是匪夷所思了！正确的领域模型应该如下图所示：</p>
<img src="/the-difference-between-ddd-and-oo/model-in-bc.png" class="">



<p>因此，在领域驱动设计的领域建模中，需要建立<strong>上下文为王</strong>的意识。形成的一个个自治的限界上下文，就是领域模型的“独立王国”，除了需要调用必须的对外公开的业务能力之外，它们几乎是”老死不相往来“的。在跨限界上下文的领域模型之间，即便是相对弱耦合的依赖关系也当避免，更不用说继承、合成与聚合关系了。除非，我们将某个限界上下文设计为“共享内核（shared kernel）”。</p>
<p>在领域驱动设计获得的设计模型中，一个聚合作为边界封装了实体和值对象。我们可以将聚合“伪装”为一个完整的类（其实质是领域模型的边界），与之对应的设计要素还包括管理聚合生命周期的资源库（repository）和负责协作外部资源或多聚合的领域服务（domain service）。多数情况下，一个聚合、一个资源库和一个领域服务可能都需要定义，它们的关系如下图所示：</p>
<img src="/the-difference-between-ddd-and-oo/service-repo-agg.png" class="">



<p>资源库和领域服务在操作聚合时，是将<strong>聚合当作一个完整的整体概念来看待</strong>的。领域驱动设计尤其重视聚合对领域模型的边界控制。在设计领域模型时，需要清晰定义出聚合的边界，然后再由此推导出资源库和领域服务。在学籍管理上下文中，我将家长放到了以学生为根实体的聚合中，如下图所示：</p>
<img src="/the-difference-between-ddd-and-oo/student.png" class="">



<p>一方面，家长信息如家庭住址一般都是学生的属性，另一方面，需要约束学生与家长关系的<strong>不变量（Invariant）</strong>，例如，在为学生添加家长信息时，总不能出现两个父亲吧？——谁愿意呢！</p>
<p>由此可知，当限界上下文作为领域模型的边界时，一方面它限制了跨限界上下文之间领域模型的关系，另一方面它作为知识语境，分离了同一个领域概念的不同视角。我将限界上下文称为<strong>战略设计的基本架构单元</strong>。</p>
<p>聚合作为领域模型的边界，维护的是当前上下文领域概念的完整性，并将其作为一个不可分割的整体，由资源库管理其生命周期。它平衡了领域对象粒度与数量的矛盾，既可以确保每个领域概念的细粒度，又可通过聚合根的封装在形式上减少领域对象的数量。通过聚合边界的控制，减少了领域对象之间不必要的依赖，并通过约束聚合之间的关系来降低耦合。我将聚合称为<strong>战术设计的基本设计单元</strong>。</p>
<p>对象建模范式的领域建模确乎是建立在面向对象思想之上的，但领域驱动设计考虑了软件世界与理想的对象世界之差异，不只是考虑领域模型的关系与协作，还考虑领域模型与外部资源的关系，这就需要施加恰当的约束，进一步保证领域模型的质量。这是我们在进行领域建模时务必谨记的要点。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>富内斯的思维模式</title>
    <url>/thinking-pattern-after-reading-borges/</url>
    <content><![CDATA[<img src="/thinking-pattern-after-reading-borges/logo.jpg" class="">
<p>博尔赫斯(Jorge Luis Borges)有一篇奇文，曰《博闻强记的富内斯》，以纪实手法杜撰了一个具有非凡记忆能力的传奇人物富内斯。博尔赫斯自云：“（《博闻强记的富内斯》）是长夜失眠的隐喻。”博尔赫斯大约是文学大师中最擅长使用隐喻的人了。他在诺顿讲座的演讲中，专门做了一次题为“隐喻”的演讲。极限编程的创始人Kent Beck非常推崇“隐喻”，并将其作为Spike阶段理解架构的重要手段，也是XP敏捷实践之一。</p>
<span id="more"></span>

<p>我在读一些文学作品时，常产生对软件设计思想的遐想。这或许可以称之为“比较学”，但我认为可以说是“隐喻”。</p>
<p>回到这篇奇文。博尔赫斯用诗的语言向我们描述了抽象与具象。他写道：</p>
<blockquote>
<p>我们能够充分直感的形象是黑板上的一个圆圈、一个直角三角形、一个菱形；伊雷內奥却能直感马匹飞扬的鬃毛、山岗上牲口的后腿直立、千变万化的火焰和无数的灰烬，以及长时间守灵时死者的种种面貌。</p>
</blockquote>
<p>伊雷內奥即富内斯，他的超凡记忆力在19岁被马摔下地的时候被神奇的触发。他能记住他之所观、所听、所感的任何一刻纷繁复杂的细节，“非但记得每一座山林中每一株树的每一片叶子，而且还记得每次看到或回想到它时的形状。”然而，富内斯却不具备<strong>抽象</strong>的能力——“富内斯几乎不会进行一般的、纯理论的思维。他非但难以理解‘狗’这个共性符号包括不同大小、不同形状的许许多多、各色各样的个别的狗；麻烦的是，从侧面看的编号为3-14的狗，名称会和从正面看的编号为3-14的狗一样。”</p>
<p>所以博尔赫斯说：“思维是忘却差异，是归纳，是抽象化。在富内斯的满坑满谷的世界里有的只是伸手可及的细节。”</p>
<p>富内斯可以是一个好的记忆者，他可以用极短的时间学会世间任何一门语言，我想，程序语言自然也不例外，所以他若从事编码工作，一定是一个不错的高效程序员；但是，他却不一定是一个好的软件设计者。Dijkstra就指出：“抽象来自于对真实世界中特定对象、场景或处理的相似性的认知，并决定关注这些相似性而忽略不同之处。”这里所谓的“决定”就是设计时的一种判断，且需要具备抽象的能力去支撑。富内斯显然做不到这一点。</p>
<p>抽象是一种归纳的能力，是一种识别共同特征的能力。抹掉细节，只辨其共同之处，并将其归纳为一个抽象的名词，这是设计者需要具备的。不如此，则不能化繁为简；不如此，则不能应对变化。我们很难成为博闻强记的富内斯，这就意味着当我们面对太多如枝头纷繁堆叠的叶子一般的细节时，我们不可能都能记住它们的样子。从面向对象的角度来讲，远处山林中每一株树都是一个对象实例，但我们可以以抽象的Tree名之。树上生长的每一片叶子都是一个对象实例，但我们可以以抽象的Leaf名之。</p>
<p>在软件设计中，抽象除了是对共同特征的概括之外，还应该是对对象边界的一种控制与分离，即通过抽象将对象分离为“外部视图”与“内部视图”。Abelson与Sussman将抽象的这种能力称之为<strong>抽象壁垒</strong>。这是用更加强烈的语气强调了“边界的意义”。</p>
<p>在我曾经负责设计的SaaS产品中，需要根据元数据生成报表。报表的所有元素最终需要导出到Excel与Html网页上。我借用了“绘制”的隐喻来表示导出功能，因而Excel的Sheet与Html的Page都可以视为“画布”。基于这么一个隐喻，我提炼出与导出相关的报表元素的共同特征，即针对“画布”而言，它们都是一种“绘制元素”。于是，我得到了两个抽象概念：<code>DrawingElement</code>与<code>ReportCanvas</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DrawingElement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(ReportCanvas canvas)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> object <span class="title">getElement</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReportCanvas</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(DrawingElement element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DrawingElement</code>的<code>draw()</code>方法负责将绘图元素绘制到<code>ReportCanvas</code>对象中。这种抽象提供了导出功能的<strong>外部视图</strong>，它隐藏了具体的实现细节，使得该功能是可扩展的。</p>
<p>抽象的方向有二：自上而下又或自下而上。</p>
<p>在进行自上而下的抽象时，我们往往需要遵循一些范式、模式乃至设计风格。例如针对业务模型，我们可以参考Martin Fowler的《分析模式》，直接套用该模式定义的模型对整个设计进行指导。又例如说针对一连串的数据流处理，我们可以参考Pipe-Filter模式，抽象出可以组合和扩展的filter。在自上而下抽象的过程中，偶尔需要设计者利用“隐喻”来给出一个形象而恰当的抽象概念。例如在Facebook的FBML架构中，就引入了“flavor（风味）”来形容不同上下文对输入的约束。</p>
<p>当面对未知领域时，又或者我们无法寻找到已有模式（范式）去follow时，我们就需要自下而上的抽象能力。这个过程就好像整理一堆打散了的扑克牌一样，我们要按照花色分类，然后再按照数值进行排序。扑克牌的花色就是抽象过程中要寻找的“共同特征”，扑克牌的数值以及排序过程则是需要封装的细节。例如在报表处理的上下文中，我们分辨出填充参数的多种实现方式，进而提炼出<code>ParameterFilling</code>这个抽象行为；在租赁系统上下文中，我们分辨出可以租赁的各式物品，进而提炼出<code>Rentable</code>这个抽象特征。</p>
<p>请注意，<strong>分类</strong>与<strong>识别共同特征</strong>都属于一种抽象。前者获得的是<strong>is-a</strong>的关系，后者获得的是<strong>can-do</strong>或<strong>have</strong>的关系。无所谓优劣，抽象关系的选择取决于具体的场景。</p>
<p>博尔赫斯杜撰的富内斯能够过目不忘地背诵冗长晦涩的拉丁文《自然史》，超凡的记忆力让他可以拥有海量的知识，但他的思维方式仍然停留在留声机的初级阶段。他记住了知识，却不能有效地运用知识，因为他无法归纳、无法推演、无法演绎，换言之，他缺乏的是提炼知识的抽象能力。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>OO</tag>
        <tag>Reading</tag>
      </tags>
  </entry>
  <entry>
    <title>面向流的设计思想</title>
    <url>/thinking-rule-of-rp/</url>
    <content><![CDATA[<p>响应式编程（Reactive Programming）的本质是异步非阻塞的高响应式处理，最核心思想则为<strong>Everything is stream</strong>，即针对流进行处理，这是其根本。从这个角度讲，我们可以将响应式编程的设计思想视为Stream-Oriented Design，即面向流的设计。</p>
<p>正如面向对象设计以对象为基本设计要素，函数式编程思想以函数为基本设计要素，响应式编程则应该以流为基本设计要素。这带来设计思想上根本的变化，包括：</p>
<ul>
<li>以流作为建模的元素</li>
<li>流存在松耦合的上下游关系</li>
<li>以流为重用的单位</li>
<li>对流进行转换、运算、合并与拆分</li>
</ul>
<p>在Rx框架中，一个流就是一个Observable或者Flowable。例如我们要统计网页的字数，则流的源头就是对网页内容的获取，而流就是<code>Observable&lt;String&gt;</code>类型的网页内容。至于统计操作，则需要经历分词、字数统计两个阶段，则可以视为是对流的转换与运算操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flowable.fromFuture(pageContent)</span><br><span class="line">    .flatMap(content -&gt; Flowable.fromArray(s.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">    .map(w -&gt; <span class="keyword">new</span> Pair&lt;&gt;(w, <span class="number">1</span>))</span><br><span class="line">    .groupBy(Pair::getKey);</span><br></pre></td></tr></table></figure>

<p>由于Rx框架提供了诸如merge、combineLatest、zip等操作符来完成多个流之间的组合，我们就可以分别建立各自的流，然后再利用这些操作符对其进行合并，或者反其道而行之。这样就能尽可能地分解出诸多原子的可重用的流。例如，针对UI的click操作以及response响应，我们就可以分别建立两个流，然后利用combineLatest进行组合。无论哪个流发射了数据，它都会将这两个流最近发射的数据组合起来，并按照指定的函数进行运算。</p>
<span id="more"></span>

<p>Akka Stream提出来的Graph更能体现流作为建模元素的思想。只要规划好我们的流程，思考组成这些流程的步骤的输入和输出，就可以分别将这些步骤分别建模为Source、Sink、Flow以及Fan-in、Fan-out和BidiFlow，如下图所示：</p>
<img src="/thinking-rule-of-rp/graph-shape.png" class="">

<p>例如针对银行交易业务，如果我们需要执行如下流程：</p>
<ul>
<li>根据给定的账户编号获得所有的账户</li>
<li>根据账户同时获得所有的银行交易（BackingTransaction）和结算交易（SettlementTransaction）</li>
<li>获得这些交易后对交易进行验证</li>
<li>验证后的数据分别用于用于审计和计算净值</li>
</ul>
<p>我们对该流程进行领域建模时，实则可以绘制一个可以表达Akka Streams中Graph的可视化图：</p>
<img src="/thinking-rule-of-rp/bank.png" class="">

<p>通过这样的可视化图，我们就可以针对这些图中的节点建模为Akka Streams中的Graph Shape。至于流的广播与合并，则对应着框架的Broadcast Fan-out与Merge Fan-In。除了入口的accountNos是Source，以及用于最后的审计与净值计算作为Sink外，其余节点都是Flow类型。实现代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">val</span> graph = <span class="type">RunnableGraph</span>.fromGraph(<span class="type">GraphDSL</span>.create(netTxnSink) &#123; <span class="keyword">implicit</span> b =&gt; ms =&gt;</span><br><span class="line">    <span class="keyword">import</span> <span class="type">GraphDSL</span>.<span class="type">Implicits</span>._</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> accountBroadcast = b.add(<span class="type">Broadcast</span>[<span class="type">Account</span>](<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">val</span> txnBroadcast = b.add(<span class="type">Broadcast</span>[<span class="type">Transaction</span>](<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">val</span> merge = b.add(<span class="type">Merge</span>[<span class="type">Transaction</span>](<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> accounts = <span class="type">Flow</span>[<span class="type">String</span>].map(queryAccount(_, <span class="type">AccountRepository</span>))</span><br><span class="line">    <span class="keyword">val</span> bankingTxns = <span class="type">Flow</span>[<span class="type">Account</span>].mapConcat(getBankingTransactions)</span><br><span class="line">    <span class="keyword">val</span> settlementTxns = <span class="type">Flow</span>[<span class="type">Account</span>].mapConcat(getSettlementTransactions)</span><br><span class="line">    <span class="keyword">val</span> validation = <span class="type">Flow</span>[<span class="type">Transaction</span>].map(validate)</span><br><span class="line"></span><br><span class="line">    accountNos ~&gt; accounts ~&gt; accountBroadcast ~&gt; bankingTxns ~&gt; merge ~&gt; validation ~&gt; txnBroadcast ~&gt; ms</span><br><span class="line">                              accountBroadcast ~&gt; settlementTxns ~&gt; merge</span><br><span class="line">    txnBroadcast ~&gt; audit</span><br><span class="line">    <span class="type">ClosedShape</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>Scala语言由于提供了操作符重载，隐式转换等语法糖，在语言的表现能力更符合DSL的语义。例如代码中的<code>~&gt;</code>符号非常清晰地表达出了数据流动的方向，流经什么样的节点。最关键的是，这些Flow定义彼此之间并没有强耦合关系，只要保证传输的数据是正确的，就可以利用组合操作符将Flow与Flow连接起来。这样的Flow同样是Lazy的，可以很好地得到高效重用。</p>
<p>因此，使用响应式编程，需得围绕“<strong>流</strong>”为中心进行设计思考，并将其作为一个非常重要的重用元素进行组合。这也就是我所谓的面向流设计（Stream-Oriented Design）的想法来源。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Reactive Programming</tag>
        <tag>RxJava</tag>
      </tags>
  </entry>
  <entry>
    <title>架构设计的三个原则</title>
    <url>/three-principles-of-architecture/</url>
    <content><![CDATA[<img src="/three-principles-of-architecture/2021-05-07.jpeg" class="">

<p>在进行架构设计时，我认为需要遵循如下原则：</p>
<ul>
<li>一致原则</li>
<li>简单原则</li>
<li>演进原则</li>
</ul>
<span id="more"></span>

<h3 id="一致原则"><a href="#一致原则" class="headerlink" title="一致原则"></a>一致原则</h3><p>一致性是软件架构质量原则的根基，遵循一致原则的软件架构可以有效地保证整个架构解决方案的清晰直接，降低了解决方案的复杂度。尤其对于一个大规模系统，往往需要多个团队共同开发完成，如果不遵循一致原则，就会导致整个平台的建设缺乏完整性和规范性，各个子系统各自为政，业务功能重复开发，技术实现五花八门，服务集成复杂低效，信息冗余制造出知识壁垒。</p>
<p>一致原则具体体现为：</p>
<ul>
<li>架构风格的一致性：针对相同的业务复杂度和技术复杂度，要形成统一的架构风格。例如，对外公开的业务能力采用微服务架构风格，保证各个服务的高内聚低耦合，确保了整个系统的可扩展能力；数据采集、治理和分析业务采用基于Lambda架构模式的大数据架构风格，为数据的处理建立批处理层与速度处理层，满足不同业务场景的数据需求；服务之间的异步消息协作采用事件驱动架构风格，保证服务之间消息传递的高效性与实时性，提高整个系统的响应能力；</li>
<li>技术选型的一致性：针对相同或相似的问题，应采用相同的方案和技术，从而使得开发人员在掌握了其中一种解决方案后，针对相似的问题，可以推导出相同的解决方案，降低了方案的复杂度，规避了重复开发，降低了代码的维护成本。以微服务架构为例，技术选型涉及的内容主要包括微服务组件、日志处理、权限管理、分布式事务、数据库访问、消息通信机制、缓存技术、安全策略、开发语言、框架版本、监控运维，同时，还要求开发团队遵循一致的编码规范。</li>
</ul>
<h3 id="简单原则"><a href="#简单原则" class="headerlink" title="简单原则"></a>简单原则</h3><p>软件架构的目的就是为了控制软件系统的复杂度。分析软件系统的复杂度成因，主要来自规模、结构和变化。</p>
<p>对于规模引起的复杂度，可以通过“分而治之”的思想来解决，也就是将整个系统按照业务维度拆分为多个细小而简单的模块（组件或服务），每个服务的规模都是团队或团队成员可以控制的。</p>
<p>结构引起的复杂度取决于参与协作的模块（组件或服务）的数量，数量越多，模块之间的关系就越复杂，因为协作产生的依赖很容易让整个系统变得混乱而无序，增加了开发和维护的成本。要降低复杂度，就需要清晰地定义模块的边界，合理地分配职责，以减少不必要的依赖关系；同时，定义一致而稳定的协作接口，让模块之间的协作变得有序，清晰地体现彼此之间的调用链，明确消息数据的传递方向。</p>
<p>需求的变化总是会带来解决方案的调整，最终使得持续变化的解决方案变得越来越复杂。如何有效地应对需求变化？一方面需要团队提前识别出可能发生变化的热点功能，另一方面也需要注意避免对未来做出过度设计。若能识别出变化的热点功能，就能通过封装或抽象的设计原则，让实现方案尽可能具有可扩展能力，将变化产生的影响降到最低。然而，未来的变化总是不可预测的，如果不能确定未来是否会发生变化，则不要引入太多的间接和抽象，形成过度设计，增加了解决方案的复杂度。</p>
<p>遵循简单原则的架构体现为：</p>
<ul>
<li>引入领域驱动设计的限界上下文模式帮助合理地识别微服务，明确微服务之间的协作模式，确定业务需求与微服务之间的映射关系，减少不必要的微服务协作；</li>
<li>采用前后端分离，避免了前端用户体验复杂度与后端业务复杂度之间混合导致的复杂度叠加，也可以保证前、后端开发团队明确前后端协作的接口，进行并行开发；</li>
<li>保持模块之间接口的松耦合，从架构上考虑数据分析场景与业务处理场景的分离，以定义数据平台的边界，驱动出数据交换的接口，确定数据平台和业务服务之间的协作方式；</li>
<li>识别复用的业务能力：站在产品高度和全面视角分析业务能力，将满足单一职责的业务能力封装为高内聚的服务或组件，完成功能的复用，降低系统的代码规模，保证了系统的简单性。</li>
</ul>
<h3 id="演进原则"><a href="#演进原则" class="headerlink" title="演进原则"></a>演进原则</h3><p>架构设计不是一蹴而就的，由于需求会不断发生变化，架构设计也需要针对变化的需求做出调整。由于架构做出的设计和决策往往是一个软件系统最为重要的部分，对架构做出的调整成本和难度都比较大，因此，在进行架构设计时，应考虑解决方案的演进能力，即能够随着需求的变化以最小的修改成本实现架构方案的不断演进。</p>
<p>遵循演进原则的架构应满足：</p>
<ul>
<li>响应变化的能力：演进能力的一个体现是响应变化的能力，一个设计原则是将变化产生的影响控制到最小范围。这一原则确定了架构方案需要按照变化的方向进行模块的划分，从而顺应变化，同时，保证业务复杂度与技术复杂度的正交关系，避免业务的变化影响到技术实现的变化，反之亦然。我们可遵循企业架构的设计思想，根据不同的观察视角将整个系统架构划分为业务架构、应用架构、数据架构和技术架构。其中，为了降低变化影响，让系统的应用架构和数据架构对准业务架构，即按照业务能力对系统的模块（组件或服务）进行职责划分，同时保证每个应用模块中的领域模型与数据模型对应；对于技术架构，则通过分层架构模式将业务与技术分离，保证二者的松散耦合；</li>
<li>职责分配与合理抽象：识别和设计微服务的质量直接影响到系统的演进能力，整个系统需要针对领域进行分析，从业务能力的角度进行功能的职责分配，保证每个微服务是内聚的，同时，通过有效识别变化的热点，对其利用抽象降低彼此之间的耦合，保证了具体实现的可扩展能力与可替换能力；</li>
<li>架构模式的运用：对于业务系统而言，通过采用微服务架构模式、事件驱动架构模式和分层架构模式，尽可能保证整个业务系统的松散耦合，提高系统架构的演化能力；对于数据平台，可采用基于流处理的管道-过滤器模式，通过将数据处理功能拆分为一个个过滤器（processor），然后在管道中自由组合这些过滤器，满足整个数据处理流程的需要。这一模式保证了功能的复用性和可扩展性。</li>
</ul>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>《解构领域驱动设计》目录</title>
    <url>/toc-of-ddd-explained/</url>
    <content><![CDATA[<h2 id="《解构领域驱动设计》目录"><a href="#《解构领域驱动设计》目录" class="headerlink" title="《解构领域驱动设计》目录"></a>《解构领域驱动设计》目录</h2><p>本书经过近4年的准备和写作，基于GitChat《领域驱动设计实践》战略篇和战术篇的内容，我又历经一年的时间来打磨本书，相信本书呈现给读者的内容已经达到我目前的极限了。书名暂定为《解构领域驱动设计（Domain-Driven Design Explained）》，说明了我的“野心”也罢，“宏图”也罢，就是要全方位的解构领域驱动设计这一套方法体系。</p>
<p>一些订阅了我的GitChat课程的同学可能会问，这本即将出版的纸质书与GitChat课程有什么差别呢？实际上，基于线上更新的写作方式，进度压力颇大，很多内容缺乏系统的梳理，在写作时，难免会有前后矛盾、重复之处，有的内容待写在后面会有更深刻的理解，因为时间关系，也就没有来得及调整。当然，这些内容差别都是细节差异，最主要的差别还是因为我重新梳理了DDD的体系，提出了所谓的“领域驱动设计统一过程（Domain-Driven Design Unified Process）”。</p>
<p>总结出的这个过程对我而言意义重大，正是因为有此过程，我整本书的结构才明晰起来，有了一个前后呼应且成体系的目录结构，这个过程还弥补了我一直认为非常重要的“需求分析”的知识，因为我一直认为要做到好的领域驱动设计，必须要有好的需求分析为基础。于是，针对这套统一过程，我对GitChat课程的内容做了全方位的手术，如果仅仅是对比文字，你会发现纸质版的内容很少与GitChat课程内容重复，并非我对内容做了彻底改写，而是对内容做了修改、修饰和调整，改变了原来内容相对粗糙的一面，这也是为何从GitChat课程到纸质书的完成，居然花了我一年时间的缘故。</p>
<span id="more"></span>


<p>目前，《解构领域驱动设计（Domain-Driven Design Explained）》的初稿基本完成，预计在本月中旬可以将书稿交付给出版社，接下来还有好长一段时间对书稿进行审校和调整。我对本书可谓呕心沥血，倾尽了几乎全副心血，付出的精力远超我第一本书《软件设计精要与模式》，目的就在于尽我所能做到完美。我宁愿推迟书的出版，也要尽可能做到更好。当然，限于我的能力水平，本书存在错误也是难免的，这就需要各位读者批评指正了。</p>
<p>全书分为五个篇章，加上序和后记，一共27章。具体字数我还未来得及统计，以每章接近2万字来计算，大约有50万字左右。我会尽量加快书稿的完善工作，也会尽快推进本书的编辑、排版、印刷与出版工作，还请各位读者稍安勿躁。</p>
<p>以下是本书拟定的目录，后续还会在我的个人网站、微信公众号[逸言]与知识星球[DDD Explained]上推出本书的一些内容摘选，还有部分被裁剪作废的内容，我觉得仍有价值的，也会陆续更新。</p>
<p>为了保证本书的质量，我特别邀请了几位行业内的DDD大牛，也是我的好朋友：阿里蚂蚁金服的于右军，腾讯的王立，京东的周吉鑫，台湾亚马逊的高翊凯以及我的前东家ThoughtWorks的王威为我做技术把关；同时，还会邀请两位读者提前试读，根据这些专家和读者提前试读提出的反馈意见，及时更正和完善我的书稿。</p>
<p><strong>序</strong></p>
<h3 id="第一篇-开篇"><a href="#第一篇-开篇" class="headerlink" title="第一篇 开篇"></a>第一篇 开篇</h3><ul>
<li>01 剖析软件复杂度</li>
<li>02 领域驱动设计概览</li>
<li>03 领域驱动设计统一过程</li>
</ul>
<h3 id="第二篇-全局分析"><a href="#第二篇-全局分析" class="headerlink" title="第二篇 全局分析"></a>第二篇 全局分析</h3><ul>
<li>04 探索问题空间</li>
<li>05 价值需求分析</li>
<li>06 业务需求分析</li>
<li>07 全局分析过程</li>
</ul>
<h3 id="第三篇-架构映射"><a href="#第三篇-架构映射" class="headerlink" title="第三篇 架构映射"></a>第三篇 架构映射</h3><ul>
<li>08 同构系统的映射</li>
<li>09 系统上下文</li>
<li>10 限界上下文</li>
<li>11 上下文映射</li>
<li>12 领域驱动架构</li>
<li>13 服务契约设计</li>
<li>14 架构映射过程</li>
</ul>
<h3 id="第四篇-领域建模"><a href="#第四篇-领域建模" class="headerlink" title="第四篇 领域建模"></a>第四篇 领域建模</h3><ul>
<li>15 模型驱动设计</li>
<li>16 领域建模范式</li>
<li>17 领域分析建模</li>
<li>18 领域模型设计要素</li>
<li>19 领域设计建模</li>
<li>20 领域实现建模</li>
<li>21 事件驱动模型</li>
<li>22 领域建模过程</li>
</ul>
<h3 id="第五篇-融合"><a href="#第五篇-融合" class="headerlink" title="第五篇 融合"></a>第五篇 融合</h3><ul>
<li>23 领域驱动设计的战略考量</li>
<li>24 领域驱动设计的战术考量</li>
<li>25 领域驱动设计知识体系</li>
</ul>
<p><strong>后记</strong></p>
]]></content>
      <categories>
        <category>Book</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Writing</tag>
        <tag>Book</tag>
      </tags>
  </entry>
  <entry>
    <title>设计概念的统一语言</title>
    <url>/ubiquitous-language-of-design-concept/</url>
    <content><![CDATA[<img src="/ubiquitous-language-of-design-concept/cover.jpg" class="">



<p>当我们在讨论领域驱动设计时，不止要谈到领域驱动设计固有的设计概念，结合开发语言和开发平台的设计实践，又会有其他设计概念穿插其中，它们之间的关系并非正交的，解决的问题和思考的角度都不太一致，许多设计概念更有其历史渊源，却又在提出之后或者被滥用，后者被错用，到了最后已经失去了它本来的面目。因此，我们首先需要揭开这些设计术语的历史迷雾，理解其本真的概念，然后再确定它的统一语言。</p>
<span id="more"></span>



<h3 id="POJO对象"><a href="#POJO对象" class="headerlink" title="POJO对象"></a>POJO对象</h3><p>POJO（Plain Old Java Object）的概念来自Martin Fowler、Rebecca Parsons和Josh MacKenzie在2000年一次大会的讨论。它的本质含义是指一个常规的Java对象，不受任何框架、平台的约束和限制。除了遵守Java语法之外，它不应该继承预先设定的类、实现预先设定的接口或者包含预先指定的注解。如果一个模块定义的对象皆为POJO，那么除了依赖JDK之外，它不会依赖任何框架或平台。在.NET框架中，借助这个概念，也提出了POCO（Plain Old CLR Object）的概念。</p>
<p>Martin Fowler等人之所以提出POJO，是因为他们看到了使用POJO封装业务逻辑的益处，而在2000年那个时代，恰恰是EJB开始流行的时代，受到EJB规范的限制，Java开发人员更愿意使用Entity Bean，而Entity Bean却是与EJB强耦合的。</p>
<p>一些人错误地将Entity Bean理解为仅仅支持持久化的持久化对象（Persistence Object），实际并非如此。即使是EJB规范也认为Entity Bean可以包含复杂的业务逻辑，例如Oracle的官方网站对Entity Bean的定义就包括：</p>
<ul>
<li><p>管理持久化数据</p>
</li>
<li><p>通过主键形成唯一标识</p>
</li>
<li><p>引入依赖对象执行复杂逻辑</p>
</li>
</ul>
<p>当Entity Bean还封装了复杂的业务逻辑时，带来的危害更多。由于定义一个Entity Bean类需要继承自javax.ejb.EntityBean，这就使得业务逻辑与EJB框架紧耦合，不利于对业务逻辑的测试、部署与运行。这也正是Rod Johnson要提出抛开EJB进行J2EE开发的原因。当然，Entity Bean与EJB框架紧耦合的为人诟病，主要是针对EJB 3.0之前的版本，随着Spring与Hibernate等轻量级框架出来之后，EJB也开始向轻量级方向发展，通过大量使用标注来降低EJB对Java类的侵入性。</p>
<p>总之，POJO对象并非只有get/set方法的贫血对象，它的主要特征不在于它究竟定义了什么样的成员，而在于它作为一个常规的Java对象，并不依赖于除语言之外的任何框架。当然，它的目的不在于数据传输，也不在于数据持久化，它其实是一种设计模式。</p>
<h3 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h3><p>严格讲来，Java Bean其实是一种Java开发规范。一个Java Bean类必须同时满足以下三个条件：</p>
<ul>
<li><p>类必须是具体的、公共的</p>
</li>
<li><p>具有无参构造函数</p>
</li>
<li><p>提供一致性设计模式的公共方法将内部字段暴露为成员属性，即为内部字段提供规范的get和set方法</p>
</li>
</ul>
<p>认真解读这三个条件，你会发现它们都是为框架通过反射访问类成员而准备的前置条件，包括创建Java Bean实例和操作内部字段。只要遵循Java Bean规范，就可以采用完全统一的一套代码实现对Java Bean的访问。这一规范并没有提及业务方法的定义，这是因为规范无法对公开的方法做出任何一致性的限制。这意味着框架使用Java Bean，看重的其实是该对象携带的数据，且能够减少不必要的访问代码。例如，JSP对Java Bean的使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:useBean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sample.javabeans.Student&quot;</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">jsp:setProperty</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">property</span>=<span class="string">&quot;firstName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Bill&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">jsp:setProperty</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">property</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Gates&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">jsp:setProperty</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp:useBean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>JSP标签中使用的Student类就是一个Java Bean。如果没有遵循Java Bean规范定义类，JSP就可能无法实例化Student对象，无法设置firstName等字段值。</p>
<p>至于Session Bean、Entity Bean和Message Driven Bean则是Enterprise Java Bean的三种分类，它们都是Java Bean，但EJB对它们又有框架的约束，例如Session Bean需要继承自javax.ejb.SessionBean，Entity Bean需要继承自javax.ejb.EntityBean。</p>
<p>通过追本溯源，就可以发现POJO与Java Bean并没有任何关系。一个POJO如果遵循了Java Bean的设计规范，可以成为一个Java Bean，但并不意味着POJO必须是Java Bean。反过来，一个Java Bean如果仅仅遵循了设计规范，并没有依赖任何框架，也可以认为是一个POJO。但是，Enterprise Java Bean一定不是一个POJO。</p>
<h3 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h3><p>贫血模型准确地说，应该被称之为“贫血领域模型（Anemic Domain Model）”，因为这个术语其实是在领域模型这个语境中使用的。这个术语来自Martin Fowler的创造，从贫血这个词可知，这样的一种领域模型必然是不健康的，它违背了面向对象设计的关键原则，即“数据与行为应该封装在一起”。在领域驱动设计中，会导致贫血模型的对象是实体与值对象。如果一个实体或值对象除了内部字段之外，就只有一系列的getter/setter方法，它就成为了贫血对象。</p>
<p>关于贫血领域模型的坏处，我在本书已经阐述了很多，例如它会影响对象之间的协作方式，它违背了“迪米特法则”与“信息专家模式”，它会导致“特性依恋”坏味道的产生，最后，它其实破坏了封装，导致领域服务形成一种事务脚本的实现。</p>
<p>与贫血领域模型相对的是富领域模型（Rich Domain Model），也就是封装了领域逻辑的领域模型。这才是符合面向对象设计思想的领域设计建模。在领域模型设计建模过程中，我们定义的实体与值对象都应该建立为富领域模型。这才是真正的领域模型，也就是Martin Fowler在《企业应用架构模式》中定义的领域模型模式，作为一种领域逻辑模式（Domain Logic Pattern），它与事务脚本（Transaction Script）、表模块（Table Module）属于不同的表达领域逻辑的模式。倘若遵循这一模式的定义，即默认为领域模型就应该是富领域模型，而贫血领域模型会导致事务脚本，不应该将这样的模型称为领域模型。</p>
<p>当我们在讨论领域模型时，发现更有好事者在贫血模型的基础上衍生出各种与“血”有关的各种模型，统计下来，除了Martin Fowler提出的贫血模型之外，还包括失血模型、充血模型与胀血模型。我将这些模型戏称为“X血模型”。我个人其实并不赞成制造出这么多的模型。实际上，贫血模型的核心关键在于面向对象设计思想的职责分配。如果我们能够按照合理的职责分配原则来设计领域模型，就无所谓这些X血模型了。只要职责分配合理，有可能领域模型中的一个类确乎没有定义具有领域逻辑的行为，那也只能说明该领域概念确实不具有领域逻辑，那么这样的类也不应当称之为是贫血对象。</p>
<p>我还看到有的人错误的理解或者误用了“贫血模型”的定义，将只有字段和字段的getter/setter方法的类称之为“失血模型”，而将Martin Fowler提出的富领域模型称之为“贫血模型”。这一说法绝对是“谬种流传”。顾名思义，贫血（Anemic）这个词代表着不健康，贫血模型当然就意指不健康的模型。如果采用这篇文章的定义，Martin Fowler所推崇的富领域模型反倒成了不健康的贫血模型（虽然该文作者未必认为贫血模型不健康），该何其无辜啊！因此，在这些“X血模型”中，我们必须坚定果断地去掉失血模型，并让贫血模型回到本初的含义上。</p>
<p>在去掉了错误的失血模型后，一般认为充血模型其实就是Martin Fowler提出的富领域模型。我总觉得“充血”这个词仍然带有不健康的隐含意义，故而不愿意使用这一模式名称，更不用说更加惊悚的“胀血模型”了。这种胀血模型违背了单一职责原则，将与该领域概念相关的所有逻辑都放到了领域模型对象中，包括对持久化类（如传统的DAO，DDD中的Repository）的依赖以及事务、授权等横切关注点的调用。这实际上就是让一个领域模型对象承担了聚合、领域服务以及应用服务的职责，这样的模型显然有悖于面向对象的设计原则。</p>
<p>有的观点认为混入了持久化能力的领域模型属于充血模型，这更进一步混淆X血模型的边界。实际上，Martin Fowler将这种对象称之为“活动记录（Active Record）”，它属于数据源架构模式（Data Source Architectural Patterns）中的一种。这种设计方式是领域驱动设计努力避免的，如果让每个实体都混入了持久化能力，就会丢失聚合的边界保护作用，资源库也就失去了存在的价值。</p>
<p>还有人混淆了领域模型与POJO的概念，认为贫血模型对象就是一个POJO，殊不知这二者根本就是两个迥然不同的维度。POJO关注类的定义是否纯粹，领域模型关注的是对领域逻辑的表达与封装。即使是一个只有getter/setter方法的贫血模型对象，只要它依赖了任何外部框架，例如标记了javax.persistence.Entity标注，它也不属于一个POJO。严格说来，Dubbo服务化最佳实践给出的建议——“服务参数及返回值建议使用POJO对象，即通过setter, getter方法表示属性的对象”，对POJO的描述也是不正确的，因为Dubbo服务的参与与返回值需要支持序列化，这不符合POJO的定义。</p>
<p>由此可以看出，定义种类繁多的模式会让人“乱花渐欲迷人眼”，随着信息的多次传递，就会迷失它们本来的面目。我们需要做减法，在领域驱动战术设计中，只要遵循领域驱动设计的原则定义了实体、值对象、领域服务和应用服务，就不用考虑这些模式，只需要把握一条：避免设计出贫血领域模型！</p>
<h3 id="诸多XO"><a href="#诸多XO" class="headerlink" title="诸多XO"></a>诸多XO</h3><p>在分层架构的约束下，在职责分离的指引下，一个软件系统需要定义各种各样的对象，在分层架构中承担了不同的职责，又彼此协作，共同响应系统外部的各种请求，执行业务逻辑，并让整个软件系统能够真正地跑起来。然而，若没有真正理解这些对象在架构中扮演的角色，承担的职责，导致误用和滥用，就有可能适得其反。因此，有必要在领域驱动设计的方法体系下，将各式各样的对象进行一次梳理，形成一套统一语言，就不至于出现理解上的分歧，使用上的不当。由于这些对象皆以O结尾，故而戏称为XO对象。</p>
<p>这些XO对象包括：</p>
<h4 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h4><p>DTO（Data Transfer Object，数据传输对象）用于在进程间传递数据，远程服务接口的输入参数与返回值都可以认为是一个DTO。我个人又根据调用者的不同，将其分为视图模型对象与消息契约对象。DTO必须支持序列化，同时它通常应该设计为一个Java Bean，即定义为公开的类，具有默认构造函数和getter/setter方法。这样就有利于一些框架通过反射来创建与组装DTO对象。DTO还应该是一个贫血对象，因为它的目的是为了传输数据，没有必要定义封装逻辑的方法。</p>
<h4 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h4><p>VO（View Object，视图对象）其实是DTO的一种，即我提到的视图模型对象。本质上，它应该遵循MVC模式，为前端的视图提供数据，即MVC中的模型对象。视图对象可能仅传输视图需要呈现的数据，但也可能为了满足前端UI的可配置，由后端传递与视图元素相关的属性值，如视图元素的位置、大小乃至颜色等样式信息。在领域驱动设计中，有些人会将值对象（Value Object）简称为VO，要注意不要混淆这两个缩写。</p>
<h4 id="BO"><a href="#BO" class="headerlink" title="BO"></a>BO</h4><p>BO（Business Object，业务对象）这是一个非常宽泛的定义，在软件系统中，它的定义来自于分层架构的定义，即数据访问层、业务逻辑层与UI呈现层。故而BO就是定义在业务逻辑层中封装了业务逻辑的对象。在领域驱动设计中，可以认为就是领域对象。为避免混淆，我建议不要在领域驱动设计中使用该概念。</p>
<h4 id="DO"><a href="#DO" class="headerlink" title="DO"></a>DO</h4><p>由于领域驱动设计将业务逻辑层分解为应用层和领域层，业务对象在领域层中就变成了DO（Domain Object，领域对象）。不过，在领域驱动设计中，更准确的说法是领域模型对象。通常，领域模型对象包括实体、值对象、领域服务与领域事件。有时候，领域模型对象单指组成聚合的实体与值对象。宽泛地讲，只要表达了现实世界的领域概念，或者封装了领域行为逻辑，都可以认为是领域模型对象。</p>
<h4 id="PO"><a href="#PO" class="headerlink" title="PO"></a>PO</h4><p>对象字段持有的数据需要被持久化到数据表中，但不要由此认为PO（Persistence Object，持久化对象）就只能定义字段以及对应的getter/setter方法，变成一个贫血对象。前面讨论的富领域模型对象也可以成为PO，只是在持久化时，不会用到封装在领域模型对象中的方法罢了。由于需要告知持久化框架对象与关系表之间的映射，往往需要以某种形式在PO中展现这种关系，这就导致PO变得不够纯粹，不是一个POJO。</p>
<h4 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h4><p>DAO（Data Access Object，数据访问对象）作用在映射了关系表的PO之上对其进行持久化，实现对数据的访问。由于领域驱动设计引入了聚合边界，并力求领域模型与数据模型之间的分离，且引入了资源库（Repository）来实现对聚合的生命周期管理，因此在领域驱动设计中，不再使用DAO这个概念。</p>
<p>经过对以上概念的历史追寻与本质分析，我们基本上理清了这些概念的含义与用途。在归纳到领域驱动设计这个方法体系中，我们可以得出如下统一语言：</p>
<ul>
<li><p>领域模型对象包含实体、值对象、领域服务与领域事件，有时候也可以单指组成聚合的实体与值对象。</p>
</li>
<li><p>领域模型必须是富领域模型</p>
</li>
<li><p>远程服务与应用服务接口的输入参数和返回值定义为DTO，根据客户端的不同，可以分为视图模型对象与消息契约对象。</p>
</li>
<li><p>领域模型对象中的实体与值对象同时也可以作为PO</p>
</li>
<li><p>只有资源库对象，没有DAO对象</p>
</li>
</ul>
<h3 id="发布声明"><a href="#发布声明" class="headerlink" title="发布声明"></a>发布声明</h3><p>本文首先发表于我的微信公众号「逸言」，欢迎关注：</p>
<img src="/ubiquitous-language-of-design-concept/wechat.png" class="">



<h3 id="干货推荐"><a href="#干货推荐" class="headerlink" title="干货推荐"></a>干货推荐</h3><p>张逸老师携手Gitchat为大家带来《领域驱动设计实践》精讲课，限时特价只需¥128即可学习更多关于领域驱动设计的干货哟，扫描下方二维码即可报名啦。</p>


<img src="/ubiquitous-language-of-design-concept/02.png" class="">]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>重新理解Martin Fowler对微服务的定义</title>
    <url>/understanding-micro-service-definition/</url>
    <content><![CDATA[<p>2014年，ThoughtWorks的Martin Fowler与James Lewis对一种新的架构风格——微服务（微服务这个术语最早诞生2011年在威尼斯召开的一次软件架构师工作坊）——提供了完整的定义。随着他们的定义，微服务这种架构风格迅速地成为软件行业的热词，并被许多互联网公司采纳，陆续开始迈入微服务的演进过程。如今微服务已经进入所谓的Service Mesh 2.0时代，诸多微服务框架、平台以及设计原则如雨后春笋般出现。在微服务走入成熟的时刻，再来重读Martin  Fowler对微服务的定义，或许会另有一番收获。</p>
<p>微服务的完整定义来自Martin Fowler的文章《<a href="https://www.martinfowler.com/articles/microservices.html">MicroServices</a>》。作者是James Lewis与Martin Fowler，他们对微服务的定义如下所示：</p>
<img src="/understanding-micro-service-definition/01.png" class="">

<p>根据这个定义，我们可以勾勒出微服务的基本构成要素：</p>
<ul>
<li>每个服务运行在自己的进程中；</li>
<li>微服务之间采用轻量级通信；</li>
<li>微服务应基于业务能力进行构建；</li>
<li>采用自动化部署机制实现微服务的独立部署；</li>
<li>服务的管理应采用最小的中心化管理。</li>
</ul>
<span id="more"></span>

<p>“每个服务运行在自己的进程中”。随着Docker等容器化技术的发展，一个微服务的物理边界不一定等于网络边界，最小的物理边界变成了“进程”。在Java平台下，诸如Spring Boot等框架引入了更加便捷的Web容器部署方式，使得定义、部署与运行一个微服务都变得更加简单。由于微服务粒度比传统的SOA服务更小，它对Web应用服务器的要求也变得更加轻量级。除了Tomcat，还可以使用Jetty等更加轻量级的Web容器。</p>
<p>不仅运行微服务变得轻量，微服务之间的通信也变得更加轻量，如定义中的第二个要素——“微服务之间采用轻量级通信”。什么是轻量级通信？文章认为是基于HTTP协议的资源API，通常指的是RESTful API。不过随着类似Netty、gRPC等RPC框架、PB序列化协议以及Kafka等消息中间件的广泛运用，在生产应用中，微服务之间的通信也不仅限于RESTful。毕竟HTTP协议在传输性能和可靠性方面仍然存在局限性，而JSON的序列化能力也是差强人意。因此，除了基于http协议的REST服务，如Spring Boot/Cloud；还可以是RPC协议，例如使用阿里的Dubbo或新浪的Motan；甚至使用消息中间件传递消息来完成通信。</p>
<p>定义强调了微服务与业务能力（Business Capability）之间的关系。显然，是业务而非技术在驱动微服务的设计。现在，有越来越多的人认识到了这一点，随之开始重视领域驱动设计（DDD），并尝试将领域驱动设计引入到微服务架构设计中。领域驱动设计的潜能还有待挖掘，培养具有领域驱动设计能力的团队成员，可能会成为决定微服务架构演进成败的一个重要因素。此外，采用微服务架构的团队是否遵循康威定律，并在文化上与之吻合则是微服务演进的另一个挑战。</p>
<p>在推动持续集成和持续交付时，自动化部署已经得到了普及，Docker与K8S之类的容器化技术在某种程度上改变了自动化部署的方式。DevOps的理念也成为了运维团队的建设目标。但是，在许多传统企业的微服务化进程中，属于基础设施层面的持续集成、持续交付和DevOps显然还未准备好。技术上，持续集成与持续交付的成熟度还有待提高，许多团队还未能完全做到自动化测试与自动化部署，还需要花费很多精力与成本来偿还这些技术债。在运维文化上，困难更大。开发与运维仍然属于两个“老死不相往来”的团队，开发不操心运维的脏活累活，运维不具备编写自动化脚本的能力。这些现状可能会极大地制约微服务的演进，甚至会导致企业的微服务演进成为一种形式。</p>
<p>定义中提及的“最小中心化管理”是从语言层面讲解的，即采用微服务时，将不再受限于服务实现的技术栈，无论是开发语言还是数据库，都可以自由选择。如果我们仅仅将微服务视为一种简单的服务化，无疑，对服务的调用确实是一种跨平台的通信。从理论上讲，只要规定了服务的通信协议以及服务的接口，就可以自由选择技术栈。然而，当微服务被分解得越来越小，微服务的数量变得越来越多时，微服务架构其实已经衍生为一个庞大的生态圈。从微服务的生命周期看，我们需要考虑微服务的定义、开发、测试、上线、监控以及最后的消亡（降级）。从微服务的系统架构看，我们需要考虑微服务的注册、发现、编排、监控、运维等。这些需求衍生出许多微服务框架，如Spring Cloud、Dubbo。但是，这些框架为了实现这些功能，采用的实现都或多或少导致了代码的侵入，使得微服务对开发语言的选择受到许多限制。若要满足Martin Fowler定义的“最小中心化管理”，服务网格（Service Mesh）才是最佳答案。自2016年9月Linkerd第一次公开使用之后，伴随着Linkerd、Envoy、Istio、NGINX Application Platform、Conduit等新框架的涌现，服务网格和它的边车（Sidecar）模式让多语言的微服务协作变得更加容易。未来几年的微服务发展，应该是服务网格占据主流。</p>
<p>整体来看，微服务的技术实践已经开始向更加成熟迈进。在微服务的实践与运用上，互联网企业走在了前面，它们甚至在诸多方面都成为了微服务技术发展的先行者。然而，对于微服务的设计、技术落地以及相应的文化建设和基础设施搭建，许多团队的能力与意识仍显不足，尤其是针对一些传统企业，要实现企业架构向微服务转型，依旧是“路漫漫其修远兮”。James Lewis与Martin Fowler两位大师对微服务的定义依旧具有蓬勃的生命力。因此，许多正在或者计划实践微服务的架构师们，还需要深入理解这一定义，结合实践找到符合自己企业和团队的微服务演进之路。</p>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>Architecture</tag>
        <tag>Micro Service</tag>
      </tags>
  </entry>
  <entry>
    <title>在Scala项目中使用Spring Cloud</title>
    <url>/using-spring-cloud-in-scala-project/</url>
    <content><![CDATA[<p>由于Scala本身属于JVM下的语言，因此它能够较好地与Java项目融合在一起。在Scala中调用Java库，基本上与在Java中调用Java库的方式是相同的（反过来则未必，必将Java没有Scala中独有的语法糖）。因此，在Scala中可以非常方便地调用Spring Cloud，使其支持Spring Cloud提供的微服务基础设施，例如Eureka、Feign以及Spring Boot等。</p>
<p>不过仍然有几点需要注意，这些方面包括：</p>
<ul>
<li>Maven依赖</li>
<li>Spring的语法</li>
<li>Json的序列化</li>
</ul>
<span id="more"></span>

<h3 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h3><p>在Scala项目中，如果仍然使用Maven管理依赖，则它与在Java项目中添加Spring Boot依赖几乎完全相同，不同在于项目要支持Scala，需要添加对Scala语言库的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要支持用ScalaTest编写单元测试，则还需要添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scalatest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scalatest_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时，添加对编译Scala代码的插件依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>build-helper-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>add-source<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>add-source<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">sources</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">source</span>&gt;</span>src/main/scala<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">sources</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>add-test-source<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-test-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>add-test-source<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">sources</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">source</span>&gt;</span>src/test/scala<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">sources</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.alchim31.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>testCompile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring的语法"><a href="#Spring的语法" class="headerlink" title="Spring的语法"></a>Spring的语法</h3><p>Scala语言中照样可以使用Java的Annotation，因此scala项目的Application，可以这样实现：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlEngineApplication</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SqlEngineApplication</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="type">SpringApplication</span>.run(classOf[<span class="type">SqlEngineApplication</span>], args: _*)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，Spring Cloud以及Spring Boot提供的annotation是运用在类上面的，而Scala可以运用的Application则可以直接定义为与类同名的object。</p>
<p>而对于Spring Boot的Controller，在语法上有少许差异，即在值中要使用Scala的<code>Array</code>类型，例如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="type">Array</span>(<span class="string">&quot;/&quot;</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlStatementController</span> <span class="keyword">extends</span> <span class="title">SqlGenerator</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="type">Array</span>(<span class="string">&quot;/sql&quot;</span>), method = <span class="type">Array</span>(<span class="type">GET</span>))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getSql</span></span>:<span class="type">String</span> = ???</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(value = <span class="type">Array</span>(<span class="string">&quot;/sql&quot;</span>), method = <span class="type">Array</span>(<span class="type">POST</span>))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generateSql</span></span>(<span class="meta">@RequestBody</span> request: <span class="type">GenerateSqlRequest</span>): <span class="type">String</span> = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Json的序列化"><a href="#Json的序列化" class="headerlink" title="Json的序列化"></a>Json的序列化</h3><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>Spring Boot使用Jackson作为Json的序列化支持，若要在Scala项目也要使用Jackson，则需要添加jackson对scala的支持模块：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.module<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-module-scala_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="添加WebConfig"><a href="#添加WebConfig" class="headerlink" title="添加WebConfig"></a>添加WebConfig</h4><p>同时还需要添加WebConfig，告诉Spring Boot选择Scala Module对对象进行映射：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">configureMessageConverters</span></span>(converters: java.util.<span class="type">List</span>[<span class="type">HttpMessageConverter</span>[_]]): <span class="type">Unit</span> =</span><br><span class="line">  converters.add(jackson2HttpMessageConverter())</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">jackson2HttpMessageConverter</span></span>(): <span class="type">MappingJackson2HttpMessageConverter</span> =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">MappingJackson2HttpMessageConverter</span>(objectMapper())</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">objectMapper</span></span>(): <span class="type">ObjectMapper</span> =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ObjectMapper</span>() &#123;</span><br><span class="line">      setVisibility(<span class="type">PropertyAccessor</span>.<span class="type">FIELD</span>, <span class="type">Visibility</span>.<span class="type">ANY</span>)</span><br><span class="line">      registerModule(<span class="type">DefaultScalaModule</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对多态的支持"><a href="#对多态的支持" class="headerlink" title="对多态的支持"></a>对多态的支持</h4><p>客户端发过来的Request中，包含了一棵表达式树。这棵树的节点分为两种类型：</p>
<ul>
<li>Condition Group</li>
<li>Condition</li>
</ul>
<p>Condition Group作为根节点，可以递归嵌套Condition Group和Condition，如下图所示：</p>
<img src="/using-spring-cloud-in-scala-project/expr-tree.png" class="">

<p>在Scala中的定义如下所示：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">GenerateSqlRequest</span>(<span class="params">sqlTemplateName: <span class="type">String</span>, criteria: <span class="type">Option</span>[<span class="type">ConditionGroup</span>] = <span class="type">None</span>, groupBy: <span class="type">List</span>[<span class="type">GroupByField</span>] = <span class="type">Nil</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionExpression</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionGroup</span>(<span class="params">logicOperator: <span class="type">String</span>, conditions: <span class="type">List</span>[<span class="type">ConditionExpression</span>]</span>) <span class="keyword">extends</span> <span class="title">ConditionExpression</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Condition</span>(<span class="params">fieldName: <span class="type">String</span>, operator: <span class="type">String</span>, values: <span class="type">List</span>[<span class="type">String</span>], dataType: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">ConditionExpression</span></span></span><br></pre></td></tr></table></figure>

<p><code>GenerateSqlRequest</code>中包含的criteria属性的类型就是前面提及的表达式树，它对应的Json结构需要支持Json类型的多态，即前面代码所示的<code>ConditionExpression</code>抽象类型，子类<code>ConditionGroup</code>与<code>Condition</code>拥有不同的属性定义。要支持这种Json的多态，则必须在抽象类型<code>ConditionExpression</code>上添加如下annotation：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo</span>(</span><br><span class="line">  use = <span class="type">JsonTypeInfo</span>.<span class="type">Id</span>.<span class="type">NAME</span>,</span><br><span class="line">  include = <span class="type">JsonTypeInfo</span>.<span class="type">As</span>.<span class="type">PROPERTY</span>,</span><br><span class="line">  property = <span class="string">&quot;type&quot;</span>)</span><br><span class="line"><span class="meta">@JsonSubTypes</span>(<span class="type">Array</span>(</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Type</span>(value = classOf[<span class="type">Condition</span>], name = <span class="string">&quot;condition&quot;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Type</span>(value = classOf[<span class="type">ConditionGroup</span>], name = <span class="string">&quot;group&quot;</span>)</span><br><span class="line">))</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionExpression</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">evaluate</span></span>: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使<code>ConditionGroup</code>与<code>Condition</code>子类没有定义type属性，在对应的Json结构中也需要添加type，并给出符合上述代码定义的值：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;sqlTemplateName&quot;</span>: <span class="string">&quot;name1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;criteria&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;group&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;logicOperator&quot;</span>: <span class="string">&quot;and&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;conditions&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;condition&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fieldName&quot;</span>: <span class="string">&quot;sales&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;between&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;values&quot;</span>: [<span class="string">&quot;3&quot;</span>, <span class="string">&quot;100&quot;</span>],</span><br><span class="line">            <span class="attr">&quot;dataType&quot;</span>: <span class="string">&quot;Integer&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;group&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;logicOperator&quot;</span>: <span class="string">&quot;or&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;conditions&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;condition&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;fieldName&quot;</span>: <span class="string">&quot;brand&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;=&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;values&quot;</span>: [<span class="string">&quot;apple&quot;</span>],</span><br><span class="line">                  <span class="attr">&quot;dataType&quot;</span>: <span class="string">&quot;String&quot;</span></span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;condition&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;fieldName&quot;</span>: <span class="string">&quot;location&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;operator&quot;</span>: <span class="string">&quot;in&quot;</span>,</span><br><span class="line">                  <span class="attr">&quot;values&quot;</span>: [<span class="string">&quot;Sichuan&quot;</span>, <span class="string">&quot;Shanghai&quot;</span>],</span><br><span class="line">                  <span class="attr">&quot;dataType&quot;</span>: <span class="string">&quot;String&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;groupBy&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;fieldName&quot;</span>: <span class="string">&quot;location&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;fieldName&quot;</span>: <span class="string">&quot;brand&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这种对多态的支持不仅仅是针对Scala，同样支持Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnoreProperties;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonSubTypes;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonTypeInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonIgnoreProperties(ignoreUnknown = true)</span></span><br><span class="line"><span class="meta">@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)</span></span><br><span class="line"><span class="meta">@JsonSubTypes(&#123;</span></span><br><span class="line"><span class="meta">    @JsonSubTypes.Type(value = Condition.class, name = &quot;condition&quot;),</span></span><br><span class="line"><span class="meta">    @JsonSubTypes.Type(value = ConditionGroup.class, name = &quot;group&quot;) &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionExpression</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>一旦在Scala项目中使用了Spring Boot以及Spring Cloud，在编译打包后，使用方式和普通Java项目结合Spring Boot与Spring Cloud是完全一样的，毕竟scala编译后生成的就是一个不同的Jar包。</p>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>Micro Service</tag>
        <tag>Scala</tag>
        <tag>Spring Boot</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>何时以及如何正确使用静态方法</title>
    <url>/when-use-static-method/</url>
    <content><![CDATA[<img src="/when-use-static-method/logo.png" class="">
<p>要知道何时以及如何正确使用静态方法，首先要搞清楚静态方法与实例方法的区别。静态（static）本身说明该行为是无状态的，无需实例化，调用时无需再格外分配内存来存放实例。所以，针对全局的单例场景、无状态的行为时，就可以考虑用使用静态方法。但是，静态方法有一个致命的问题，即它与具体类型是强耦合的。如果该行为可能存在变化，就要避免使用静态方法。</p>
<span id="more"></span>

<p>因此，有如下情形：</p>
<ul>
<li>对于确定不会变化的工具行为，使用静态方法；</li>
<li>需要提供语法糖让代码更易于阅读，可以定义静态方法，因为它可以被static import。</li>
</ul>
<p>例如，google的common库里面有一些工具类<code>Files</code>、<code>Preconditions</code>。这些工具类提供的方法通常是不会变的。如在<code>Preconditions</code>工具类中，非空检查的逻辑在将来并不会发生变化，该行为又没有状态，此时就可以用静态方法作为工具方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">checkNotNull</span><span class="params">(T reference, <span class="meta">@Nullable</span> Object errorMessage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(reference == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(String.valueOf(errorMessage));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reference;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Preconditions.checkNotNull(name, <span class="string">&quot;name is null&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>对于第二种情形，例如单元测试时需要使用断言，为了提高测试代码的表现力，应力求测试更符合自然语言的阅读习惯。基于Java编写的AssertJ验证框架以拥有流畅的接口而著称。譬如说它提供的assertThat()方法，为了更好地体现DSL的特征，就被定义为静态方法，并通过static import隐藏类型信息，让方法调用变得更自然：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(fellowship).extracting(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                      .contains(<span class="string">&quot;Boromir&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Frodo&quot;</span>, <span class="string">&quot;Legolas&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果不满足这两个条件，就尽量不要用静态方法，因为静态方法不利于扩展，不利于Mock，因而也不利于编写测试。至于针对一些无状态的服务方法，例如电商系统中针对促销策略的变化封装OnSalePolicy类，由于促销策略随时发生变化，因此也不能使用静态方法。最佳选择是定义为服务接口，然后通过依赖注入（Dependency Injection）实现松耦合，拥抱变化。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从拼多多事件看电商的促销模型</title>
    <url>/analysis-model-for-promotion/</url>
    <content><![CDATA[<img src="/analysis-model-for-promotion/cover.jpg" class="">

<p>最近一段时间，电商圈出了一件大事情，拼多多再次吸引了大家的眼球。2019年1月20日，拼多多出现了数额巨大的羊毛Bug，起因在于一张无门槛的优惠券，券面价值100元，可以全场通用（特殊商品除外），有效期一年。如果仅仅从业务角度分析，定义这样的优惠券自身并没有任何问题。当然，也有人说像这样的无门槛券本身就不该用于花费充值、Q币充值等几乎等于现金业务的商品，这是从促销层面去考虑的问题。还有人提到风控问题，为何等到损失达200亿（事后拼多多说明这些优惠券涉及到千万）才发现问题？更有人质疑这是一次别出心裁的炒作。</p>
<p>从薅羊毛的角度看这个Bug，似乎是因为该无门槛券可以被无限次使用导致的。本质上，这确实是一个Bug，我不明白这样的Bug是如何产生的，是测试不到位，还是说该优惠券本身是一个内部测试数据，被不小心放到生产环境？正好，最近正在考虑如何利用分析模式建立电商系统中的促销模型，算是应景之作吧。</p>
<span id="more"></span>

<h2 id="分析模式对模型的精炼"><a href="#分析模式对模型的精炼" class="headerlink" title="分析模式对模型的精炼"></a>分析模式对模型的精炼</h2><p>在领域驱动设计中，通过统一语言与“名词动词法”的结合，可以快速获得初步的分析模型。但是这种方法获得的模型品质，受限于语言描述的写作技巧，统一语言的描述更多体现在是对现实世界的模型描述，缺乏深入精准的分析与统一的抽象，使得我们很难发现一些隐含在统一语言背后的重要概念。一言以蔽之，由此获得分析模型还需要进一步精炼。</p>
<p>对相同或相近的领域进行建模分析时，一定有章法和规律可循。例如同样都是电商系统，它们的领域模型定有相似之处；如果都为财务系统，自然也得遵循普适性的会计准则。这并非运用行业术语这么简单，而是结合领域专家的知识，将这些相同或相似的模型抽象出来，形成可以参考和重用的概念模型，这就是Martin Fowler提出的分析模式。Fowler认为：“分析模式是一组概念，这些概念反映了业务建模中的通用结构。它可以只与某个特定的领域相关，也可以跨越多个领域。”由于分析模式是独立于软件技术的，就使得领域专家可以理解这些模式，这是分析建模过程中关键的一点。</p>
<p>每个行业都可以定义自己的分析模式，当然我们也可以参考一些已经被别人总结好的分析模式。例如在Martin Fowler的著作《分析模式》中，模式所覆盖的领域就包括组织结构、单位数量、财务模型、库存与账务、计划以及合同（期权、期货、产品以及交易）等领域。Eric Evans认为利用这些分析模式，“可以避免一些代价高昂的尝试和失败过程，而直接从一个已经具有良好表达力和易实现的模型开始工作，并解决了一些可能难于学习的微妙的问题。我们可以从这样一个起点来重构和实验。”</p>
<p>要获得这样的分析模式，需要专精的领域专家与软件设计师共同来完成。只可惜沟通与知识的壁垒让这样一个重要的分析工作变得举步维艰。Martin Fowler撰写《分析模式》正是希望通过引入更多的模式来降低建模的难度，至少可以做到一定程度的模型复用。然而，分析模式与领域知识息息相关，这就限制了分析模式的通用性；但这并不能说明分析模式不重要。领域驱动设计尤其强调为领域建模，对于那些具有较长生命周期的产品而言，<strong>针对产品的核心领域建立一套分析模式绝对值得，因为它是分析阶段的重要资产，它的稳定与扩展能力可能会直接影响到领域模型中的设计模型与实现模型</strong>。</p>
<h3 id="案例：促销策略的分析模式"><a href="#案例：促销策略的分析模式" class="headerlink" title="案例：促销策略的分析模式"></a>案例：促销策略的分析模式</h3><p>促销（Promotion）是一种运营手段，目的是通过这种手段去刺激消费的各种信息，把信息传递到一个或更多的目标对象，以影响其态度和行为，提高转化率。为了拉动消费，无论是线上还是线下，商家总是会绞尽脑汁提供各种促销手段，这就带来了促销策略的复杂性；然而从消费心理角度考虑，要刺激消费，简单有效的方式就是让消费者认为花了更少的钱却买了更多的商品，这就带来了促销策略的相似性。从某种意义上讲，拼多多的这次促销极大地“刺激”了消费者的热情！</p>
<h4 id="促销策略的业务背景"><a href="#促销策略的业务背景" class="headerlink" title="促销策略的业务背景"></a>促销策略的业务背景</h4><p>在电商系统中，对促销的管理主要牵涉到对促销活动与促销规则的管理。同时，促销还会影响到订单、库存、物流以及支付。如果我们将促销视为核心领域，那么在为它建立分析模型时，应以促销领域为主。</p>
<p><strong>促销活动</strong></p>
<p>促销活动实际上是针对促销进行基本属性管理，负责提供活动方式和商品内容，主要包括：</p>
<ul>
<li>商品选择：参加促销的商品，分为活动商品和赠品两种；也可以选定商品的品种参与促销，例如针对图书类开展促销。</li>
<li>投放时间选择：即该促销的有效时段</li>
<li>投放区域选择：针对全平台还是部分平台（自营或指定店铺），或者仅针对APP平台</li>
<li>用户类型：针对新注册用户，VIP用户等</li>
</ul>
<p><strong>促销规则</strong></p>
<p>促销规则是促销管理的核心。一个促销系统的好坏取决于促销规则设计是否合理，设计时既要考虑到商品的促销，又要考虑到店铺的盈利，还要考虑滞销品和畅销品的差别，因此促销规则的制订是非常灵活的，范围和促销力度也各有不同。大体来看，我们可以从平台、商品种数、促销方式这三个维度来分别理解促销规则的制订：</p>
<ul>
<li>平台维度：促销规则可以分为自营促销和POP平台促销。</li>
<li>商品总数维度：站在商品角度看促销，则促销可以分为单品促销、集合促销和店铺促销：<ul>
<li>单品促销：以单个商品为维度进行的促销叫单品促销，例如限时抢。</li>
<li>集合促销：通过商品集合来满足促销规则进行的促销叫集合促销，例如满额减。</li>
<li>店铺级促销：以商家店铺为维度进行的促销叫店铺级促销，例如店铺级满额折。</li>
</ul>
</li>
<li>促销方式维度：<ul>
<li>直减类：限时抢、直减、多买多折、VIP专享价、手机专享价等</li>
<li>赠品：满赠</li>
<li>换购类：加价购，凑单</li>
<li>满额类：满额减、满额折等</li>
<li>返券类：满额返券</li>
<li>组合优惠类：套餐</li>
<li>预订类：团购</li>
</ul>
</li>
</ul>
<p>在配置促销规则时，还需要考虑规则的优先级，它会直接影响促销活动的<strong>共享与互斥</strong>。例如我们可以按照一定的优先级完成用户的优惠享用，如享用了单品促销，就不能参加集合促销，满减优先级大于代金券；这是互斥的情况。促销活动也可以共享，例如满额累促销可以与满额包邮共同使用。</p>
<h4 id="对促销领域的分析建模"><a href="#对促销领域的分析建模" class="headerlink" title="对促销领域的分析建模"></a>对促销领域的分析建模</h4><p>我们在为促销领域进行分析建模时，首先需要甄别出该领域的核心概念，然后分析这些概念在该领域中蕴含的业务意义。基于前面介绍的业务背景，我们知道促销领域的核心概念包括促销活动与促销规则。在管理促销活动时，需要指定促销规则，这就产生了二者之间的关联关系。表面看，是通过促销活动去配置促销规则，前者为主，后者为辅；但对于促销而言，其实是活动与规则合二为一组合形成一种<strong>促销产品（Promotion Product）</strong>。这种促销产品可以是“券（Coupon）”形式，也可以是“礼品卡（Gift Card）”形式，又或者是提供“打折（Discount）”或者“包邮（Free Shipping）”。</p>
<p>模型概念“促销产品”的获得实际上是分析建模过程中<strong>对关系建模</strong>的一种体现。在现实世界中，各种概念之间总是会存在各种错综复杂的关系，例如在学校中，有教师与学生之间的师生关系，有院长与教师之间的上下级关系，有教授与研究生之间的科研关系。一旦关系变得越来越多，越来越复杂，仅仅靠体现对象之间的委派关系来体现这种组合就会显得缺乏表现力，这个时候就可以将“关系”提炼为模型中一个显式的概念。</p>
<p><strong>建模原则：如果某个类型拥有多种相似的关联，可以为这些关联对象定义一个新的类型，并建立一个知识级类型来区分它们。</strong></p>
<p>前面所述的促销活动与促销规则在业务上存在一定的重复。例如平台维度的促销规则，其实对应的是促销活动中对投放平台或区域的选择。商品总数维度的促销规则，又与促销活动中适用商品（品种）选择的配置重叠了。这是因为我们扩大了所谓“规则”的外延。规则（Rule）不是计划，更不是策略，而应该是一条条具体的可判断是否满足条件的约束规则，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">购指定图书满100元减20元，满200元减40元，在2018年12月12日当天有效。</span><br></pre></td></tr></table></figure>

<p>以上描述并非<strong>促销规则</strong>，而是一次完整的<strong>促销</strong>，该促销的促销产品为“券（Coupon）”，券的类型为现金券（若描述中为满额折扣，就是折扣券）。描述“指定图书”属于促销活动中对适用商品（品种）的配置，描述“2018年12月12日当天有效”则是该促销的有效时段属性。唯有描述“满100元减20元，满200元减40元”，才是所谓的<strong>规则</strong>。该规则又包含了两条金额阈值的条件（Creteria）。面对这种场景，我们就可以在分析模型中引入“<a href="https://www.martinfowler.com/apsupp/spec.pdf">规格模式（Specification Pattern）</a>”。</p>
<p>规格模式由Martin Fowler与Eric Evans提出，他们对规格模式的描述如下所示：</p>
<p><strong>问题</strong>：<br>选择（Selection）：需要基于某些条件（Creteria）选择对象的一个子集，且需要多次刷新其选择<br>验证（Validation）：需要根据确定的目标获得满足条件的合适对象<br>按需构造（Construction-to-order）：需要描述对象应该做什么而无需解释对象执行的细节，这样就可以构造一个候选对象来满足需求</p>
<p><strong>解决方案：</strong><br>创建一个规格（Specification）对象，它能够辨别候选对象是否满足某些条件。规格对象定义了方法<code>isSatisfiedBy(anObject)</code>，如果anObject的所有条件均满足，则返回值true。</p>
<p><strong>结果：</strong></p>
<ul>
<li>解除需求设计、实现与验证之间的耦合</li>
<li>提供清晰的声明式的系统定义</li>
</ul>
<p>规格对象可以是单一的，也可以是合成的。</p>
<p>一个促销规则可以包含多个规格，而对于规格而言，在促销场景又可以分为：</p>
<ul>
<li>金额（Amount）阈值的规格：例如满200元减40元，或满200元9折</li>
<li>数量（Count）阈值的规格：例如满2件9折，又或者限量购</li>
</ul>
<p>结合业务分析与模型分析，我们可以得出如下的分析模型：</p>
<img src="/analysis-model-for-promotion/01.png" class="">

<p>分析促销产品时，我们发现模型中的概念并未处于同一个抽象层次，且相互间存在混合关联的关系。例如打折（Discount）或现金抵用（Reward）可以单独针对一次促销提供，也可以和券（Coupon）进行捆绑；礼品卡（Gift Card）和券均可以提供赠品或者包邮。显然，诸如打折、现金抵用、赠品和包邮等概念并非一种促销产品，而是一种促销产品类型，是促销产品的一种属性，例如券的促销产品类型若为打折，就是折扣券，若为现金抵用，就是现金券。这时，促销产品其实是这些产品类型的一种载体。</p>
<p>在电商系统的促销策略中，诸如打折、现金抵用之类的促销手段未必需要通过券或者礼品卡的形式呈现，它们其实是可以作为促销产品被单独使用的。但在建模过程中，我们却不允许概念层次的混乱，因为我们必须要避免领域概念的二义性。例如对于打折（Discount），到底是促销产品，还是促销类型，必须分辨清楚。既然概念层次不在同一个抽象层次上，我们就需要针对这些概念建立一层抽象，这个抽象概念是与券、礼品卡处于同一个抽象层次。这个抽象的促销产品概念就是“优惠（Special Offer）”。因此，前面建立的模型就可以改进为：</p>
<img src="/analysis-model-for-promotion/02.png" class="">

<p><strong>建模原则：保证分析模型中的概念遵循单一抽象层次原则。</strong></p>
<h4 id="知识级和操作级"><a href="#知识级和操作级" class="headerlink" title="知识级和操作级"></a>知识级和操作级</h4><p>当模型变得渐趋复杂时，《分析模式》引入了操作级（operational level）和知识级（knowledge level）两个层次来组织模型中的概念。操作级模型记录该领域每天发生的事件；知识级模型则定义了操作级对象的合法配置，记录控制着结构的各种通用规则。知识级和操作级二者之间并没有明确的差异，但Martin Fowler认为“将两者（知识级和操作级）分开有助于理清建模思路”。为此，我们需要明确这二者之间的差别。</p>
<p>在《分析模式》一书中，Martin Fowler引入了英国国民医疗服务制度的Cosmos项目作为分析模式的案例，这个模型的推导过程清晰地展现了引入这两个层级是怎么让模型变得更加清晰的。</p>
<p>Cosmos作为一个医疗保健系统，需要对医药行业的测量和观察需求建立模型。简单说来，每个患者的测量结果可以建模为“测量（Meassurement）”。然而针对整家医院，即使是一个患者也可能存在成千上万种可能的测量。如果为每种测量定义一个相应的属性，就意味着一个患者存在着成千上万种可能的测量操作——测量的接口就会变得格外复杂。分析模型的解决方案是将所有可以被测量的不同事物（身高、体重、血糖水平……）都作为测量对象，并将其抽象为“现象类型（Phenomenon Type）”。这里，测量属于操作级，现象类型属于知识级：</p>
<img src="/analysis-model-for-promotion/03.png" class="">

<p>在为测量引入现象类型后，患者可以有许多测量，但是针对某一种现象类型而言，患者就只有一个测量。例如John Smith身高1米75，在上述模型中，该描述信息整个代表一个测量，其中，患者是John Smith，现象类型是身高，数量是1米75。</p>
<p>那么为什么现象类型属于知识级，测量属于操作级呢？《分析模式》给出了一条建模原则：“操作级中的对象会经常发生变化，它们的配置由很少发生变化的知识级来约束。”这是<strong>从变化的角度</strong>来区分的。操作级中的“测量”可以被定义成多种多样的测量，但知识级的“现象类型”却是可以穷举的。因此这里提到的“变化”表达的并非类型的变化，而是对象值的变化。</p>
<p>领域概念中存在一些定性的描述，例如医疗观察模型中的血型A现象、汽车分类观察模型中的汽车油量不足现象，它们都是在系统中确确实实存在的客观事实，不会因为观察是否建立而消亡，像这样的定性描述放到知识级中，可以按照规则来使用它们。这是<strong>从领域概念的性质</strong>来区分的。</p>
<p>回到电商系统的促销策略模型，促销可以被定义为多种多样，但促销产品与促销类型在促销领域中却是可以穷举的，因此促销应该被定义在操作级，而促销产品与促销类型则属于知识级。当然，各自级别内部的属性自然也会归入到各自的级别中，正如数量之于测量，在促销策略模型中，有效时段就属于促销的属性，因此有效时段也属于操作级的概念。</p>
<p>促销活动属于操作级，因为它类似案例中的测量概念，针对某一种促销活动类型而言，一次促销只有一个促销活动。为了应对操作级对象（促销活动）的变化，驱动我们引入了知识级的促销活动类型（Activity Type）概念。</p>
<p>从领域概念的性质看，促销类型为折扣（Discount）是一种定性描述，券类型为现金券也是一种定性描述，因此促销类型和券类型属于知识级。那么，促销规格为“满200元减40元”是一种定性描述吗？——不是。虽然一旦定义了这样的规格，它确实是一种不变的事实，但它却是附着在促销规则上，一旦促销规则失效或者被删除，这样的规格就没有存在的意义了。因此促销规则与规格应属于操作级的概念。</p>
<p>每个促销都有属于自己的类别（Label），这个类别是促销的一种定性描述，属于操作级对象。在计算促销优惠时，不同类别的商品会分别计算，同一类别则可以兼容，这相当于分类汇总。对于促销而言，如果我们将一个具体的促销实例视为一个实体，在计算促销优惠时，同一实体的促销是互斥的，不同实体的促销可以叠加组合，也可以按照优先级（Priority）。这个优先级属于促销的属性。优先级可以在配置促销策略时事先配置，也可以由买家指定，例如买家在购买商品时，出现了多种促销叠加的情况，买家就可以根据具体的购买情况选择最适合自己的促销，这时用户指定的优先级要高于事先配置的优先级。</p>
<p>与优先级属性相同，我们还需要为“促销”概念引入“状态”属性，例如标记该促销对象的状态为“未使用”、“已使用”和“过期”。同一个促销不能被用户无限使用，又或者需要给定一个有效期。其中，“已使用”和“过期”都表达了促销实例的无效状态。显然，这个“状态”属性应该属于知识级。再以拼多多为例，刚才提到的优惠券Bug就是促销的“状态”属性未能在使用后设置为“已使用”状态；又或者说在用户使用该促销优惠时，不曾检查促销的“状态”属性，仅允许在“未使用”状态下才是有效可用的。</p>
<p>因此，我们引入分析模式中的建模原则与模式，可以获得如下的分析模型：</p>
<img src="/analysis-model-for-promotion/04.png" class="">

<h4 id="对分析模型的验证"><a href="#对分析模型的验证" class="headerlink" title="对分析模型的验证"></a>对分析模型的验证</h4><p>我们可以结合实际的业务场景验证获得的促销分析模型。以京东商城为例，如下图所示：</p>
<img src="/analysis-model-for-promotion/05.png" class="">

<p>上图给出了两种促销类别（Label）：联合促销活动与玩具元旦特惠。以玩具元旦优惠类别为例，<strong>促销（Promotion）</strong>为“跨店铺满减”。该促销的<strong>活动类型（Activity Type）</strong>包括适用店铺（值为“跨店铺”）、适用品种（值为“玩具”）。<strong>促销产品（Promotion Product）</strong>为优惠（Special Offer），<strong>促销产品类型（Product Type）</strong>为满减（Reward），<strong>规则（Rule）</strong>为金额阈值规则，<strong>规格（Specification）</strong>为满99.00元减。图中的两种玩具都属于同一个促销类别，因此在计算满减时，这两个商品是可以叠加的。对应的分析模型为：</p>
<img src="/analysis-model-for-promotion/06.png" class="">

<p>我们再来看另外一个促销场景：</p>
<img src="/analysis-model-for-promotion/07.png" class="">

<p>上图展现的促销场景包含了多种促销，它们的促销类别（Lebel）皆为京东自营，因此在进行优惠计算时，这些商品是可以叠加的。这里包含的促销实体包括：</p>
<ul>
<li>活动类型（Activity Type）之适用店铺为京东自营，促销产品为券（Coupon），促销产品类型为满减（Reward），优惠规则为金额阈值，规格分别为满49减6、满158减20、满258减30、满388减50等。</li>
<li>活动类型（Activity Type）之适用店铺为京东自营，适用商品为自营晨光指定商品，促销产品为券（Coupon），促销产品类型为满减（Reward），优惠规则为金额阈值，规格为满98减10。</li>
<li>活动类型（Activity Type）之适用店铺为京东自营，促销产品为优惠（Special Offer），促销产品类型为包邮（Free Shipping），优惠规则为金额阈值，规格为满99。</li>
<li>活动类型（Activity Type）之适用店铺为京东自营，促销产品为优惠（Special Offer），促销产品类型为换购（Trade-in），优惠规则为金额阈值，规格为满30。</li>
</ul>
<p>在促销模型中，这些促销实体就是一个个促销，在实现时，体现为多个促销实例，这些促销实例可以通过促销活动的“适用商品”活动类型，作用到同一件商品，形成这种促销优惠的叠加。</p>
<p>目前给出的促销模型考虑还不全面。一方面这取决于它适用的哪种电商应用场景，例如淘宝与京东的促销策略就不相同，有的电商仅仅支持虚拟商品，相关的促销领域逻辑就有所不同了。另一方面，该模型本身还未考虑如何与计算订单金额、支付以及退换货这些业务相结合。总之业务约复杂，模型也就变得相应的复杂，但同时也要学会利用抽象将模型化繁为简，又或者在模型表达中用不同的视图表达不同的概念，尽量让模型变得精简而直观，同时又不会缺少关键的领域概念。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>《解构领域驱动设计》第一章</title>
    <url>/chapter-1-of-ddde/</url>
    <content><![CDATA[<p>计算机编程的本质就是控制复杂度。</p>
<p>——Brian Kernighan</p>
<p>复杂的事物中蕴含着无穷的变化，让人既沉迷其美，又深恐自己无法掌控。我们每日每时对软件的构建就在与复杂的斗争中不断前行。软件系统的复杂度让我觉得设计有趣，因为每次发现不同的问题，都会有一种让人耳目一新的滋味油然而生，仿佛开启了新的旅程，看到了不同的风景。同时，软件系统的复杂度又让我觉得设计无趣，因为要探索的空间实在太辽阔，一旦视野被风景所惑，就会迷失前进的方向，感到复杂难以掌控，从而失去构建高质量系统的信心。</p>
<p>那么，什么是复杂系统？</p>
<span id="more"></span>



<h2 id="1-1-什么是复杂系统"><a href="#1-1-什么是复杂系统" class="headerlink" title="1.1　什么是复杂系统"></a>1.1　什么是复杂系统</h2><p>我们很难给复杂系统下一个举世公认的定义。专门从事复杂系统研究的Melanie Mitchell在接受Ubiquity杂志专访时，“勉为其难”地为复杂系统给出了一个相对通俗的定义：”由大量相互作用的部分组成的系统。与整个系统比起来，这些组成部分相对简单，没有中央控制，组成部分之间也没有全局性的通信，并且组成部分的相互作用导致了复杂行为。”</p>
<p>这个定义庶几可以表达软件复杂度的特征。定义中的“组成部分”对于软件系统，就是所谓的“软件元素”，基于粒度的不同可以是函数、类、模块、组件和服务等。这些软件元素相对简单，然而彼此之间的相互作用却导致了软件系统的复杂行为。软件系统符合复杂系统的定义，不过是进一步证明了软件系统的复杂度。然而该如何控制软件系统的复杂度呢？恐怕还要从复杂度的成因开始剖析。</p>
<p>Jurgen Appelo从理解能力与预测能力两个维度分析了复杂度的成因。这两个维度各自分为不同的复杂层次：</p>
<ul>
<li><p>理解能力维度——简单的（simple）和复杂的（complicated）；</p>
</li>
<li><p>预测能力维度——有序的（ordered）、复杂的（complex）和混沌的（chaotic）。</p>
</li>
</ul>
<p>两个维度都蕴含了“复杂”的含义：前者与简单相对，意为复杂至难以理解，可阐释为“复杂难解”；后者与有序相对，意为它的发展规律难以预测，可阐释为“复杂难测”。在预测能力维度，“难测”还不是最复杂的层次，最高层次为混沌，即根本不可预测。两个维度交叉，可以形成6种代表不同复杂意义的层次定义，Jurgen Appelo通过图1-1形象地说明了各个复杂层次的特征。</p>
<img src="/chapter-1-of-ddde/1-1.png" class="">

<p>图1-1　复杂系统的特征 </p>
<p>以下是Jurgen Appelo对这些例子给出的说明：</p>
<blockquote>
<p> 我的内衣很简单。我很容易理解它们的工作原理。我的手表是精密复杂的，如果把它拆开，我需要很长时间才能了解其设计原理和组件。但是我的手表或我的内衣都没有什么让人吃惊的（至少对我而言）。它们是有序的、可以预测的系统。</p>
</blockquote>
<blockquote>
<p> 一个三人软件开发团队也是简单的，只需要开几次会议，提供一些晚餐，外加几杯啤酒，就可以了解这个团队的每一个人了。一座城市是不简单的、繁杂的，出租车司机需要几年时间才能熟悉这座城市的所有街道、胡同、宾馆和饭店。但同时，团队和城市又都是复杂的。不管你有多了解它们，总会有意想不到的事情发生它们身上。在某种程度上，它们是可预测的，但是你永远不清楚明天会发生什么。</p>
</blockquote>
<blockquote>
<p> 双摆（两个摆锤互相连接）也是一个简单的系统，容易制作也很容易理解。但因为对钟摆的初始设置具有高度敏感性，所以它进行的是不可预测的混沌运动。股票市场也是混沌的，根据定义，它是不可预测的，否则每个人都知道怎么利用股票交易来赚钱，就会导致整个系统崩盘。但是，股票市场又不像钟摆那样，它是相当繁杂的。</p>
</blockquote>
<p>软件系统属于哪一个复杂层次呢？</p>
<p>大多数软件系统需要实现的整体功能往往是难以理解的，同时，随着需求的不断演进，它又在一定程度具有未来的不可预测性，这意味着软件系统的“复杂”同时覆盖了“复杂难解”（complicated）与“复杂难测”（complex）两个层面，对标图1-1给出的案例，就是一座城市的复杂特征。无独有偶，Pete Goodliffe也将软件系统类比为城市，他说：“软件系统就像一座由建筑和后面的路构成的城市——由公路和旅馆构成的错综复杂的网络。在繁忙的城市里发生着许多事情，控制流不断产生，它们的生命在城市中交织在一起，然后死亡。丰富的数据积聚在一起、存储起来，然后销毁。有各式各样的建筑：有的高大美丽，有的低矮实用，还有的坍塌破损。数据围绕着它们流动，形成了交通堵塞和追尾、高峰时段和道路维护。”既然如此，那么设计一个软件系统就像规划一座城市，既要考虑城市布局，以便居民的生活与工作，满足外来游客或商务人员的旅游或出差需求，又要考虑未来因素的变化，例如“当居民对城市的使用方式有所变化，或者受到外力的影响时，城市就会相应地演化”。参考城市的复杂度特征，我们要剖析软件系统的复杂度，就可以从理解能力与预测能力这两个维度探索软件复杂度的成因。</p>
<h2 id="1-2-理解能力"><a href="#1-2-理解能力" class="headerlink" title="1.2　理解能力"></a>1.2　理解能力</h2><p>是什么阻碍了开发人员对软件系统的理解？设想项目组招入一位新人，当这位新人需要理解整个项目时，就像一位游客来到一座陌生的城市。他是否会迷失在错综复杂的城市交通体系中，不辨方向？倘若这座城市实则是乡野郊外的一座村落，只有房屋数间，一条街道连通城市的两头，他还会生出迷失之感吗？</p>
<p>因而，影响理解能力的第一要素是规模。</p>
<h3 id="1-2-1-规模"><a href="#1-2-1-规模" class="headerlink" title="1.2.1　规模"></a>1.2.1　规模</h3><p>软件的需求决定了系统的规模。一个只有数十万行代码的软件系统自然不可与有数千万行代码的大规模系统相提并论。软件系统的规模取决于需求的数量，更何况需求还会像树木那样生长。一棵小树会随着时间增长渐渐长成一棵参天大树，只有到了某个时间节点，需求的数量才会慢慢稳定下来。当需求呈现线性增长的趋势时，为了实现这些功能，软件规模也会以近似的速度增长。</p>
<p>系统规模的扩张，不仅取决需求的数量，还取决于需求功能点之间的关系。需求的每个功能不可能做到完全独立，彼此之间相互影响相互依赖，修改一处就会牵一发而动全身，就好似城市中的某条道路因为施工需要临时关闭，车辆只得改道绕行，这又导致了其他原本已经饱和的道路因为涌入更多车辆而变得更加拥堵。这种拥堵现象又会顺势向其他分叉道路蔓延，形成辐射效应。</p>
<p>软件开发的拥堵现象或许更严重，这是因为：</p>
<ul>
<li><p>函数存在副作用，调用时可能对函数的结果做了隐含的假设；</p>
</li>
<li><p>类的职责繁多，导致开发人员不敢轻易修改，因为不知会影响到哪些模块；</p>
</li>
<li><p>热点代码被频繁变更，职责被包裹了一层又一层，没有清晰的边界；</p>
</li>
<li><p>在系统某个角落，隐藏着伺机而动的bug，当诱发条件具备时，就会让整条调用链瘫痪；</p>
</li>
<li><p>不同的业务场景包含了不同的例外场景，每种例外场景的处理方式都各不相同；</p>
</li>
<li><p>同步处理代码与异步处理代码纠缠在一起，不可预知程序执行的顺序。</p>
</li>
</ul>
<p>随着软件系统规模的扩张，软件复杂度也会增长。这种增长并非线性的，而是呈现出更加陡峭的指数级趋势。这实际上是软件的熵发挥着副作用。正如David Thomas与Andrew Hunt认为的：“虽然软件开发不受绝大多数物理法则的约束，但我们无法躲避来自熵的增加的重击。熵是一个物理学术语，它定义了一个系统的‘无序’总量。不幸的是，热力学法则决定了宇宙中的熵会趋向最大化。当软件中的无序化增加时，程序员会说‘软件在腐烂’。”</p>
<p>软件之所以无法躲避熵的重击，源于我们在构建软件时无法避免技术债（technical debt） 。不管软件的架构师与开发人员有多么的优秀，他们针对目前需求做出的看似合理的技术决策，都会随着软件的演化变得不堪一击，区别仅在于债务的多少，以及偿还的利息有多高。根据Ward Cunningham的建议，对付技术债的唯一方案就是尽量让它可见，例如通过技术债列表或者技术债雷达等可视化形式及时呈现给团队成员，并制订计划主动地消除或降低技术债。</p>
<p>我曾经负责设计与开发一款商业智能（business intelligence，BI）产品，它需要展现报表下的所有视图。这些视图的数据来自多个不同的数据集，视图的展现类型多种多样，如柱状图、折线图、散点图和热力图等。在这个“逼仄”的报表问题空间中，需要满足如下业务需求：</p>
<ul>
<li><p>在编辑状态下，支持对每个视图进行拖曳以改变视图的位置；</p>
</li>
<li><p>在编辑状态下，允许通过拖曳边框调整视图的尺寸；</p>
</li>
<li><p>点击视图的图形区域时，应高亮显示当前图形对应的组成部分；</p>
</li>
<li><p>点击视图的图形区域时，获取当前值，并对属于相同数据集的视图进行联动；</p>
</li>
<li><p>如果打开钻取开关，则在点击视图的图形区域时，获取当前值，并根据事先设定的钻取路径对视图进行钻取；</p>
</li>
<li><p>支持创建筛选器这样的特殊视图，通过筛选器选择数据，对当前报表中所有相同数据集的视图进行筛选。</p>
</li>
</ul>
<p>以上业务需求都是事先规划好，并且可以清晰预见的，由于它们都对视图进行操作，因此视图控件的多个操作之间出现冲突。例如，高亮与级联都需要响应相同的点击事件。钻取同样如此，不同之处在于它要判断钻取开关是否已经打开。在操作效果上，高亮与钻取仅针对当前视图，联动与筛选则会因为当前视图的操作影响到同一张报表下相同数据集的其他视图。对于拖曳操作，虽然它监听的是MouseDown事件，但该事件与Click事件存在一定的冲突。</p>
<p>多个功能点的开发实现以及功能点之间存在的千丝万缕的关系带来了软件规模的成倍扩张：不同的业务场景会增加不同的分支，导致圈复杂度的增加；设计上如果未能做到功能之间的正交，就会是的功能之间相互影响，导致代码维护成本的增加；没有为业务逻辑编写单元测试，建立功能代码的测试网，就可能因为对某一处功能实现的修改引入了潜在的缺陷，导致系统运行的风险增加。纷至沓来的技术债逐渐积累，一旦累积到某个临界点，就会由量变引起质变，在软件系统的规模达到巅峰之时，迅速步入衰亡的老年期，成为“可怕”的遗留系统（legacy system）。这遵循了饲养场的奶牛规则：奶牛逐渐衰老，最终无奶可挤；与此同时，奶牛的饲养成本却在上升。</p>
<p>软件规模的一个显著特征是代码行数（lines of code）。然而，代码行数常常具有欺骗性。如果需求的功能数量与代码行数之间呈现出不成比例的关系，说明该系统的生命体征可能出现了异常，例如，代码行数的庞大其实可能是一种肥胖症，意味着可能出现了大量的重复代码。</p>
<p>我曾经利用Sonar工具对咨询项目的一个模块执行代码静态分析，分析结果如图1-2所示。</p>
<img src="/chapter-1-of-ddde/1-2.png" class="">

<p>图1-2　代码静态分析结果</p>
<p>该模块代码共计40多万行，重复代码竟然占到了惊人的33.9%，超过一半的代码文件混入了重复代码。显然，这里估算的代码行数并没有真实地体现软件规模；相反，重复的代码还额外增加了软件的复杂度。</p>
<p>Neal Ford认为需要通过指标指导设计 ，例如使用面向对象设计质量评估的平台工具iPlasma，通过它生成的指标可以作为评价软件规模的要素，如表1-1所示。</p>
<p>表1-1　质量评估指标</p>
<img src="/chapter-1-of-ddde/t1-1.png" class="">




<p>在面向对象设计的软件项目里，除了代码行数，包、类、方法的数量，继承的层次以及方法的调用数，还有我们常常提及的圈复杂度，都会或多或少地影响整个软件系统的规模。</p>
<h3 id="1-2-2-结构"><a href="#1-2-2-结构" class="headerlink" title="1.2.2　结构"></a>1.2.2　结构</h3><p>你去过迷宫吗？相似而回旋繁复的结构使得封闭狭小的空间被魔法般地扩展为一个无限的空间，变得无穷大，仿佛这空间被安置了一个循环，倘若没有找到正确的退出条件，循环就会无休无止，永远无法退出。许多规模较小却格外复杂的软件系统，就好似这样的一座迷宫。</p>
<p>此时，结构成了决定系统复杂度的一个关键因素。</p>
<p>结构之所以变得复杂，多数情况下还是由系统的质量属性（quality attribute）决定的。例如，我们需要满足高性能、高并发的需求，就需要考虑在系统中引入缓存、并行处理、CDN、异步消息以及支持分区的可伸缩结构；又例如，我们需要支持对海量数据的高效分析，就得考虑这些海量数据该如何分布存储，并如何有效地利用各个节点的内存与CPU资源执行运算。</p>
<p>从系统结构的视角看，单体架构一定比微服务架构更简单，更便于掌控，正如单细胞生物比人体的生理结构要简单。那么，为何还有这么多软件组织开始清算自己的软件资产，花费大量人力物力对现有的单体架构进行重构，走向微服务化？究其主因，还是系统的质量属性。</p>
<p>纵观软件设计的历史，不是分久必合合久必分，而是不断拆分的微型化过程。分解的软件元素不可能单兵作战。怎么协同，怎么通信，就成了系统分解后面临的主要问题。如果没有控制好，这些问题固有的复杂度甚至会在某些场景下超过分解带来的收益。例如，对企业IT系统而言，系统与系统之间的集成往往通过与平台无关的消息通信来完成，由此就会在各个系统乃至模块之间形成复杂的通信网结构。要理清这种通信网结构的脉络，就得弄清楚系统之间消息的传递方式，明确消息格式的定义，即使在系统之间引入企业服务总线（Enterprise Service Bus，ESB），也只能减少点对点的通信量，而不能改变分布式系统固有的复杂度，例如消息通信不可靠，数据不一致等因为分布式通信导致的意外场景。换言之，系统因为结构的繁复增加了复杂度。</p>
<p>软件系统的结构繁复还会增加软件组织的复杂度。系统架构的分解促成了软件构建工作的分工，这种分工虽然使得高效的并行开发成为可能，却也可能因为沟通成本的增加为管理带来挑战。管理一个十人团队和百人团队，其难度显然不可相提并论，对百人团队的管理也不仅仅是细分为10个十人团队这么简单，这其中牵涉到团队的划分依据、团队的协作模式、团队成员组成与角色构成等管理因素。</p>
<p>康威定律（Conway’s law） 就指出：“任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。”Sam Newman认为是需要“适应沟通途径”使得康威定律在软件结构与组织结构中生效。他分析了一种典型的分处异地的分布式团队。整个团队共享单个服务的代码所有权，由于分布式团队的地域和时区界限使得沟通成本变高，因此团队之间只能进行粗粒度的沟通。当协调变化的成本增加后，人们就会想方设法降低协调和沟通的成本。直截了当的做法就是分解代码，分配代码所有权，物理分隔的团队各自负责一部分代码库，从而能够更容易地修改代码，团队之间会有更多关于如何集成两部分代码的粗粒度的沟通。最终，与这种沟通路径匹配形成的粗粒度应用程序编程接口（application programming interface，API）构成了代码库中两部分之间的边界。</p>
<p>注意，与设计方案相匹配的团队结构指的是负责开发的团队组织，而非使用软件产品的客户团队。我们常常遇见分布式的客户团队，例如，一些客户团队的不同的部门位于不同的地理位置，他们的使用场景也不尽相同，甚至用户的角色也不相同，但在对软件系统进行架构设计时，我们却不能按照部门组织、地理位置或用户角色来分解模块（服务），并错以为这遵循了康威定律。</p>
<p>我曾经参与过一款通信产品的改进与维护工作。这是一款为通信运营商提供对宽带网的授权、认证与计费工作的产品，它的终端用户主要由两种角色组成：营业厅的营业员与购买宽带网服务的消费者。最初，设计该产品的架构师就错误地按照这两种不同的角色，将整个软件系统划分为后台管理系统与服务门户两个完全独立的子系统，为营业员与消费者都提供了资费套餐管理、话单查询、客户信息维护等相似的业务。两个子系统产生了大量重复代码，增加了软件系统的复杂度。在我接手该通信产品时，因为数据库性能瓶颈而考虑对话单数据库进行分库分表，发现该方案的调整需要同时修改后台管理系统与服务门户的话单查询功能。</p>
<p>无论设计是优雅还是拙劣，系统结构都可能因为某种设计权衡而变得复杂。唯一的区别在于前者是主动地控制结构的复杂度，而后者带来的复杂度是偶发的，是错误的滋生，是一种技术债，它会随着系统规模的增大产生一种无序设计。《架构之美》中第2章“两个系统的故事：现代软件神话”详细地罗列了无序设计系统的几种警告信号：</p>
<ul>
<li><p>代码没有显而易见的进入系统中的路径；</p>
</li>
<li><p>不存在一致性，不存在风格，也没有能够将不同的部分组织在一起的统一概念；</p>
</li>
<li><p>系统中的控制流让人觉得不舒服，无法预测；</p>
</li>
<li><p>系统中有太多的“坏味道”；</p>
</li>
<li><p>数据很少放在它被使用的地方，经常引入额外的巴洛克式缓存层，试图让数据停留在更方便的地方。</p>
</li>
</ul>
<p>看一个无序设计的软件系统，就好像隔着一层半透明的玻璃观察事物，系统的软件元素都变得模糊不清，充斥着各种技术债。细节层面，代码污浊不堪，违背了“高内聚松耦合”的设计原则，要么许多代码放错了位置，要么出现重复的代码块；架构层面，缺乏清晰的边界，各种通信与调用依赖纠缠在一起，同一问题空间的解决方案各式各样，让人眼花缭乱，仿佛进入了没有规则的无序社会。</p>
<p>分层架构的引入原本是为了维护系统的有序性，而如果团队却不注意维护逻辑分层确定的边界，不按照架构规定的层次分配各个类的职责，就会随着职责的乱入让逻辑分层形成的边界变得越来越模糊。我在对一个项目进行架构评审时，曾看到图1-3所示的三层架构。</p>
<img src="/chapter-1-of-ddde/1-3.png" class="">

<p>图1-3　层次混乱的架构</p>
<p>虽然架构师根据关注点的不同划分了不同的层次，但各个逻辑层没有守住自己的边界：业务逻辑层定义了EditableControlBase、EditablePageBase与PageBase等类，它们都继承自ASP.NET框架的UserControl用户控件类，同时又作为自定义用户控件的父类，提供了控件数据加载、提交等通用职责；继承这些父类的子类属于用户控件，定义在用户展现层，如EditablePageBase类的子类（如DictionaryTypeView、DictionaryView和DictionaryTypeList等）。一旦逻辑层没有守住自己的边界，分层架构模式就失去了规划清晰结构的价值。随着需求的增加，系统结构会变得越来越混乱，最终陷入无序设计的泥沼。</p>
<h2 id="1-3-预测能力"><a href="#1-3-预测能力" class="headerlink" title="1.3　预测能力"></a>1.3　预测能力</h2><p>当我们掌握了事物发展的客观规律时，就具有了一定的对未来的预测能力。例如，我们洞察了万有引力的本质，就能够对观察到的宇宙天体建立模型，相对准确地推测出各个天体在未来一段时间的运行轨迹。然而，宇宙空间变化莫测，或许一个星球“死亡”产生的黑洞的吸噬能力，就可能导致那一片星域产生剧烈的动荡，这种动荡会传递到更远的星空，从而使天体的运行轨迹偏离我们的预测结果。毫无疑问，影响预测能力的关键要素在于变化。对变化的应对不妥，就会导致过度设计或设计不足。</p>
<h3 id="1-3-1-过度设计"><a href="#1-3-1-过度设计" class="headerlink" title="1.3.1　过度设计"></a>1.3.1　过度设计</h3><p>设计软件系统时，变化让我们患得患失，不知道如何把握系统设计的度。若拒绝对变化做出理智的预测，系统的设计会变得僵化，一旦有新的变化发生，修改的成本会非常大；若过于看重变化产生的影响，渴望涵盖一切变化的可能，若预期的变化没有发生，我们之前为变化付出的成本就再也补偿不回来了，这就是所谓的“过度设计”。</p>
<p>我曾经在设计一款教育行业产品时，因为考虑太多未来可能的变化，引入了不必要的抽象来保证产品的可扩展性，使得整个设计方案变得过于复杂。更加不幸的是，我所预知的变化根本不曾发生。该设计方案针对产品的UI引擎（UI engine）模块。作为驱动界面的引擎，它主要负责从界面元数据获取与界面相关的视图属性，并根据这些属性来构造界面，实现界面的可定制。产品展现的视图由诸多视图元素组合而成，这些视图元素的属性通过界面元数据进行定制。为此，我为视图元素定义了抽象的ViewElement接口，作为所有视图元素类型包括SelectView、CheckboxGroupView的抽象类型。</p>
<p>ViewElement决定了视图元素的类型，从而确定呈现的格式；至于真正生成视图呈现代码的职责，则交给了视图元素的解析器。由于我认为视图元素的呈现除需要支持现有的JSP之外，未来可能还要支持HTML、Excel等实现元素，因此在设计解析器时，定义了ViewElementResolver接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewElementResolver</span> </span>&#123;</span><br><span class="line">   <span class="function">String <span class="title">resolve</span><span class="params">(ViewElement element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>ViewElementResolver接口确保了解析功能的可扩展性，为了更好地满足未来功能的变化，我又引入了解析器的工厂接口ViewElementResolverFactory以及实现该接口的抽象工厂类AbstractViewElementResolverFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewElementResolverFactory</span> </span>&#123;</span><br><span class="line">   <span class="function">ViewElementResolver <span class="title">create</span><span class="params">(String viewElementClassName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractViewElementResolverFactory</span> <span class="keyword">implements</span> </span></span><br><span class="line"><span class="class">    <span class="title">ViewElementResolverFactory</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ViewElementResolver <span class="title">create</span><span class="params">(String viewElementClassName)</span> </span>&#123;</span><br><span class="line">      String className = generateResolverClassName(viewElementClassName);</span><br><span class="line">      <span class="comment">//通过反射创建ViewElementResolver对象</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> String <span class="title">generateResolverClassName</span><span class="params">(String viewElementClassName)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getPrefix() + viewElementClassName + <span class="string">&quot;Resolver&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getPrefix</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JspViewElementResolverFactory</span> <span class="keyword">extends</span> <span class="title">AbstractViewElementResolverFactory</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> String <span class="title">getPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Jsp&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>ViewElement接口可以注入ViewElementResolverFactory对象，由它来创建ViewElementResolver，由此完成视图元素的呈现，例如SelectViewElement：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectViewElement</span> <span class="keyword">implements</span> <span class="title">ViewElement</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> ViewElementResolver resolver;</span><br><span class="line">   <span class="keyword">private</span> ViewElementResolverFactory resolverFactory;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewElementResolverFactory</span><span class="params">(ViewElementResolverFactory resolverFactory)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.resolverFactory = resolverFactory;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">Render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      resolverFactory.create(<span class="keyword">this</span>.getClass().getName()).resolve(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>整个UI引擎模块的设计如图1-4所示。</p>
<img src="/chapter-1-of-ddde/1-4.png" class="">

<p>图1-4　UI引擎模块的类图</p>
<p>如此设计看似保证了视图元素呈现的可扩展性，也遵循了单一职责原则，却因为抽象过度而增加了方案的复杂度。扩展式设计是为不可知的未来做投资，一旦未来的变化不符合预期，就会导致过度设计。具有实证主义态度的设计理念是面对不可预测的变化时，应首先保证方案的简单性。当变化真正发生时，可以通过诸如提炼接口（extract interface）的重构手法，满足解析逻辑的扩展。方案中工厂接口与抽象工厂类的引入，根本没有贡献任何解耦与扩展的价值，反而带来了不必要的间接逻辑，让设计变得更加复杂。到产品研发的后期，我所预期的HTML和Excel呈现的需求变化实际并没有发生。</p>
<h3 id="1-3-2-设计不足"><a href="#1-3-2-设计不足" class="headerlink" title="1.3.2　设计不足"></a>1.3.2　设计不足</h3><p>要应对需求变化，终归需要一些设计技巧。很多时候，因为设计人员的技能不足，没有明确识别出未来确认会发生的变化，或者对需求变化发展的方向缺乏前瞻，所以导致整个设计变得过于僵化，修改的成本太高，从而走向了过度设计的另外一个极端，我将这一问题称为“设计不足”。</p>
<p>设计不足的方案只顾眼前，对于一定要发生的变化视而不见，这不仅导致方案缺乏可扩展性，甚至有可能出现技术实现方向的错误。这样的设计不是恰如其分的简单设计，而是对于糟糕质量视而不见的简陋处置，是为了应付进度蒙混过关用的临时花招，表面看来满足了进度要求，但在未来偿还欠下的债务时，需要付出几倍的成本。如果整个软件系统都由这样设计不足的方案构成，那么未来任何一次需求的变更或增加，都可能成为压垮系统的最后一根稻草。</p>
<p>我曾负责一个基于大数据的数据平台的设计与开发，该数据平台需要实时采集来自某行业各个系统各种协议的业务数据，并按照主题区的数据模型标准来治理数据。当时，我对整个行业的数据标准与规范尚不了解，对于数据平台未来的产品规划也缺乏充分认识。迫于进度压力，我选择了采用快速而简洁的硬编码方式实现从原始数据到主题区模型对象的转换，这一设计让我们能够在规定的进度周期满足同时应对多家客户治理数据的要求。</p>
<p>然而，作为一款数据平台产品，在该行业内进行广泛推广时，随着面向的客户越来越多，需要采集数据的上游系统也变得越来越多。此时，回首之前的方案设计，不由后悔不迭：方案的简陋导致了开发质量的低下和生产力的降低。此时的主题区划分已经趋于稳定，虽然需要支持的客户和上游系统越来越多，但要治理的数据所属的主题仍然在已有主题区范围之内，换言之，原始数据的协议是变化的，主题区的范围却相对稳定。通过对主题区模型与数据治理逻辑进行共性与可变性分析[7]，我识别出了原始数据消息的共性特征，建立了抽象的消息模型，又为主题区模型抽象出一套树形结构的核心主题模型，并基于此核心模型建立新的主题区模型。在确保主题区模型不变的情况下，找到数据治理逻辑中不变的转换过程与规则，将不同上游系统遵循不同数据协议而带来的变化转移到一个定义映射关系的样式配置文件中，形成对变化的隔离，实现了一个相对稳定的数据治理方案，如图1-5所示。</p>
<img src="/chapter-1-of-ddde/1-5.png" class="">

<p>图1-5　隔离变化的设计方案</p>
<p>采用新方案之后，如果需要采集一个不超出主题区范围的全新系统，只需定义一个样式映射文件，并付出极少量定制开发的成本，就能以最快的迭代进度满足新的数据治理需求。正因为改进了旧有方案，团队才能够在不断涌入新需求的功能压力下，基本满足产品研发的进度要求。只可惜，之前的数据治理功能已经被多家客户广泛运用到生产环境中，对应的数据交换逻辑也依托于旧的主题区模型，使得整个数据平台产品在近两年的开发周期中一直处于新旧两套主题区模型共存的尴尬局面。由于一部分数据治理和数据交换逻辑要对接两套主题区模型，因此，迫于无奈，也必须实现两套数据治理和数据交换逻辑，无谓地增加了团队的工作量。由于改造旧模型的工作量极为繁重，团队一直未能获得喘息的机会对模型以新汰旧，因此这一尴尬局面还会在一段时间内继续维持下去。这正是设计不足在应对变化时带来的负面影响。</p>
<p>我们无法预知未来，自然就无法预测未来可能发生的变化，这就带来了软件系统的不可预测性。软件设计者不可能对变化听之任之，却又因为它的不可预测性而无可适从。在软件系统不断演化的过程中，面对变化，我们需要尽可能地保证方案的平衡：既要避免因为设计不足使得变化对系统产生根本影响，又要防止因为满足可扩展性让方案变得格外复杂，最后背上过度设计的坏名声。故而，变化之难，难在如何在设计不足与过度设计之间取得平衡。</p>
<p><strong>说明：</strong>本章为《解构领域驱动设计》第一章。若希望购买本书，请点击如下链接：</p>
<p><a href="https://item.jd.com/13378760.html">京东图书</a></p>
<p><a href="http://product.dangdang.com/684576584.html">当当图书</a></p>
<p><a href="https://www.epubit.com/bookDetails?id=UB77d68d84212a6">异步社区</a></p>
]]></content>
      <categories>
        <category>Writing</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读开源框架总结Java类的定义</title>
    <url>/class-definition-of-java-class-learning-from-opensource/</url>
    <content><![CDATA[<p>Java的类是自定义的引用类型，是对<strong>职责相关</strong>的行为与数据的一种封装，用以表现一种业务领域或者技术领域的概念。在不同的场景，类包含的成员可能有所不同，大体可以分为如下五类：</p>
<ul>
<li>数据类：可以视为是持有数据的容器，类的成员只包含了字段，以及与字段有关的get/set方法</li>
<li>实体类：既包含了体现状态的字段，又包含了操作这些状态的方法</li>
<li>服务类：只有方法（行为）没有字段（状态），可以理解为提供内聚职责的服务</li>
<li>函数类：如果定义的公开方法只有唯一一个，可以理解为它封装的其实是一个函数，通常用匿名类或者Lambda表示</li>
<li>工具类：只包含一系列静态方法，通常不支持对该类型的实例化</li>
</ul>
<span id="more"></span>

<h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><p>在Presto框架中定义的<code>ClientSession</code>可以认为是这样一种数据类。除了构造函数外，它只定义了字段与对应的<code>get()</code>方法（实际上，在框架的源代码中，在<code>ClientSession</code>类中还定义了一系列静态工厂方法，但本质上说，<code>ClientSession</code>还是一个数据类），用以持有客户端Session所必须的数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientSession</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URI server;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String source;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String clientInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String catalog;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String schema;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TimeZoneKey timeZone;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Locale locale;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; properties;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; preparedStatements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String transactionId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> debug;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Duration clientRequestTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientSession</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            URI server,</span></span></span><br><span class="line"><span class="params"><span class="function">            String user,</span></span></span><br><span class="line"><span class="params"><span class="function">            String source,</span></span></span><br><span class="line"><span class="params"><span class="function">            String clientInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">            String catalog,</span></span></span><br><span class="line"><span class="params"><span class="function">            String schema,</span></span></span><br><span class="line"><span class="params"><span class="function">            String timeZoneId,</span></span></span><br><span class="line"><span class="params"><span class="function">            Locale locale,</span></span></span><br><span class="line"><span class="params"><span class="function">            Map&lt;String, String&gt; properties,</span></span></span><br><span class="line"><span class="params"><span class="function">            String transactionId,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> debug,</span></span></span><br><span class="line"><span class="params"><span class="function">            Duration clientRequestTimeout)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(server, user, source, clientInfo, catalog, schema, timeZoneId, locale, properties, emptyMap(), transactionId, debug, clientRequestTimeout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientSession</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            URI server,</span></span></span><br><span class="line"><span class="params"><span class="function">            String user,</span></span></span><br><span class="line"><span class="params"><span class="function">            String source,</span></span></span><br><span class="line"><span class="params"><span class="function">            String clientInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">            String catalog,</span></span></span><br><span class="line"><span class="params"><span class="function">            String schema,</span></span></span><br><span class="line"><span class="params"><span class="function">            String timeZoneId,</span></span></span><br><span class="line"><span class="params"><span class="function">            Locale locale,</span></span></span><br><span class="line"><span class="params"><span class="function">            Map&lt;String, String&gt; properties,</span></span></span><br><span class="line"><span class="params"><span class="function">            Map&lt;String, String&gt; preparedStatements,</span></span></span><br><span class="line"><span class="params"><span class="function">            String transactionId,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> debug,</span></span></span><br><span class="line"><span class="params"><span class="function">            Duration clientRequestTimeout)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.server = requireNonNull(server, <span class="string">&quot;server is null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">        <span class="keyword">this</span>.clientInfo = clientInfo;</span><br><span class="line">        <span class="keyword">this</span>.catalog = catalog;</span><br><span class="line">        <span class="keyword">this</span>.schema = schema;</span><br><span class="line">        <span class="keyword">this</span>.locale = locale;</span><br><span class="line">        <span class="keyword">this</span>.timeZone = TimeZoneKey.getTimeZoneKey(timeZoneId);</span><br><span class="line">        <span class="keyword">this</span>.transactionId = transactionId;</span><br><span class="line">        <span class="keyword">this</span>.debug = debug;</span><br><span class="line">        <span class="keyword">this</span>.properties = ImmutableMap.copyOf(requireNonNull(properties, <span class="string">&quot;properties is null&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.preparedStatements = ImmutableMap.copyOf(requireNonNull(preparedStatements, <span class="string">&quot;preparedStatements is null&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.clientRequestTimeout = clientRequestTimeout;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// verify the properties are valid</span></span><br><span class="line">        CharsetEncoder charsetEncoder = US_ASCII.newEncoder();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">            checkArgument(!entry.getKey().isEmpty(), <span class="string">&quot;Session property name is empty&quot;</span>);</span><br><span class="line">            checkArgument(entry.getKey().indexOf(<span class="string">&#x27;=&#x27;</span>) &lt; <span class="number">0</span>, <span class="string">&quot;Session property name must not contain &#x27;=&#x27;: %s&quot;</span>, entry.getKey());</span><br><span class="line">            checkArgument(charsetEncoder.canEncode(entry.getKey()), <span class="string">&quot;Session property name is not US_ASCII: %s&quot;</span>, entry.getKey());</span><br><span class="line">            checkArgument(charsetEncoder.canEncode(entry.getValue()), <span class="string">&quot;Session property value is not US_ASCII: %s&quot;</span>, entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URI <span class="title">getServer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSource</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClientInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCatalog</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> catalog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSchema</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> schema;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TimeZoneKey <span class="title">getTimeZone</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeZone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Locale <span class="title">getLocale</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> locale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getProperties</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getPreparedStatements</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> preparedStatements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTransactionId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> transactionId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebug</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> debug;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Duration <span class="title">getClientRequestTimeout</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientRequestTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toStringHelper(<span class="keyword">this</span>)</span><br><span class="line">                .add(<span class="string">&quot;server&quot;</span>, server)</span><br><span class="line">                .add(<span class="string">&quot;user&quot;</span>, user)</span><br><span class="line">                .add(<span class="string">&quot;clientInfo&quot;</span>, clientInfo)</span><br><span class="line">                .add(<span class="string">&quot;catalog&quot;</span>, catalog)</span><br><span class="line">                .add(<span class="string">&quot;schema&quot;</span>, schema)</span><br><span class="line">                .add(<span class="string">&quot;timeZone&quot;</span>, timeZone)</span><br><span class="line">                .add(<span class="string">&quot;locale&quot;</span>, locale)</span><br><span class="line">                .add(<span class="string">&quot;properties&quot;</span>, properties)</span><br><span class="line">                .add(<span class="string">&quot;transactionId&quot;</span>, transactionId)</span><br><span class="line">                .add(<span class="string">&quot;debug&quot;</span>, debug)</span><br><span class="line">                .toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样包含数据或状态的对象通常会作为参数在方法调用之间传递，体现了诸如配置、视图模型、服务传输数据、协议数据等概念。除此之外，我们应尽量避免定义这样的对象去体现某种业务概念，因为基于<strong>“信息专家”模式</strong>，好的面向对象设计应该是将数据与操作这些数据的行为封装在一起。</p>
<h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><p>这是最为常见的一种类定义，也是符合面向对象设计原则的，前提是定义的类必须是高内聚的，原则上应该满足单一职责原则。例如JDK定义的<code>Vector</code>展现了一种数据结构，因而它持有的字段与方法应该仅仅与队列操作与状态有关：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">protected</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> elementCount;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacityIncrement;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (newSize &gt; elementCount) &#123;</span><br><span class="line">            ensureCapacityHelper(newSize);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize ; i &lt; elementCount ; i++) &#123;</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elementCount = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elementCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elementCount == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o, <span class="number">0</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">firstElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elementData(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                    + <span class="string">&quot; &gt; &quot;</span> + elementCount);</span><br><span class="line">        &#125;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">        elementData[index] = obj;</span><br><span class="line">        elementCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addElement</span><span class="params">(E obj)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        elementData[elementCount++] = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            removeElementAt(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeAllElements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">// Let gc do its work</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elementCount; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        elementCount = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下类的定义则体现了一种业务概念，方法<code>changePriceTo()</code>实际上表现的是一种业务规则，而它要操作的数据就是<code>Product</code>类自身持有的字段<code>sellingPrice</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">extends</span> <span class="title">Entity</span>&lt;<span class="title">Identity</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Option&gt; options;</span><br><span class="line">    <span class="keyword">private</span> Price sellingPrice;</span><br><span class="line">    <span class="keyword">private</span> Price retailPrice;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(Identity id, Price sellingPrice, Price retailPrice)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">        <span class="keyword">this</span>.sellingPrice = sellingPrice;</span><br><span class="line">        <span class="keyword">if</span> (!sellingPriceMatches(retailPrice) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PricesNotInTheSameCurrencyException(<span class="string">&quot;Selling and retail price must be in the same currency&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.retailPrice = retailPrice;</span><br><span class="line">        options = <span class="keyword">new</span> List&lt;Option&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changePriceTo</span><span class="params">(Price newPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!sellingPriceMatches(newPrice)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PricesNotInTheSameCurrencyException(<span class="string">&quot;You cannot change the price of this product to a different currency&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sellingPrice = newPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Price <span class="title">savings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Price savings = retailPrice.minus(sellingPrice);</span><br><span class="line">        <span class="keyword">if</span> (savings.isGreaterThanZero()) </span><br><span class="line">            <span class="keyword">return</span> savings;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Price(0m, sellingPrice.currency);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> bool <span class="title">sellingPriceMatches</span><span class="params">(Price retailPrice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sellingPrice.sameCurrency(retailPrice); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Option option)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.contains(option)) </span><br><span class="line">            options.Add(option);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProductOptionAddedNotUniqueException(string.Format(<span class="string">&quot;This product already has the option &#123;0&#125;&quot;</span>, option.ToString()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> bool <span class="title">contains</span><span class="params">(Option option)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> options.Contains(option); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务类"><a href="#服务类" class="headerlink" title="服务类"></a>服务类</h4><p>只有方法没有状态的类定义是对行为的封装，行为的实现要么是通过操作内部封装的不可变私有数据，要么是通过操作传入的参数对象实现对状态的修改。由于参数传入的状态与服务类自身没有任何关系，因此这样的类通常也被视为无状态的类。以下代码是针对升级激活包的验证服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreActivePackageValidator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">validatePreActivePackage</span><span class="params">(ActiveManifest  activeManifest)</span> </span>&#123;</span><br><span class="line">          validateSamePackageType(activeManifest);</span><br><span class="line">          validateNoTempPackage(activeManifest);</span><br><span class="line">          validateNoPackageRunning(activeManifest);</span><br><span class="line">          validateAllPackagesBeenDownloaded(activeManifest);</span><br><span class="line">          validateNoFatherPackageBakStatus(activeManifest);</span><br><span class="line">          validatePackageNum(activeManifest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateSamePackageType</span><span class="params">(ActiveManifest  activeManifest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> packakeType = activeManifest.getPackageType();</span><br><span class="line">        <span class="keyword">for</span> (UpagrdePackage pkg : activeManifest.getPackages()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (packageType != pkg.getPackageType()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> PackagePreActiveException(<span class="string">&quot;pre active exist different type package&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务类还可以操作外部资源，例如读取文件、访问数据库、与第三方服务通信等。例如airlift框架定义的<code>ConfigurationLoader</code>类，就提供加载配置文件内容的服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationLoader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">loadProperties</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException    </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; result = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        String configFile = System.getProperty(<span class="string">&quot;config&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (configFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.putAll(loadPropertiesFrom(configFile));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.putAll(getSystemProperties());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ImmutableSortedMap.copyOf(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">loadPropertiesFrom</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException    </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(path))) &#123;</span><br><span class="line">            properties.load(reader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fromProperties(properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getSystemProperties</span><span class="params">()</span>    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fromProperties(System.getProperties());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数类"><a href="#函数类" class="headerlink" title="函数类"></a>函数类</h4><p>可以将函数类理解为设计一个类，它仅仅实现了一个接口，且该接口只定义一个方法。使用时，我们会基于<strong>依赖倒置原则（DIP）</strong>从接口的角度使用这个类。为了重用的目的，这个类可以单独被定义，也可能体现为匿名类，或者Java 8中的Lambda表达式。</p>
<h5 id="单独类形式"><a href="#单独类形式" class="headerlink" title="单独类形式"></a>单独类形式</h5><p>例如，在Presto中定义了<code>PagesIndexComparator</code>接口，提供了比较方法以用于支持对页面索引的排序。接口的定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PagesIndexComparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PagesIndex pagesIndex, <span class="keyword">int</span> leftPosition, <span class="keyword">int</span> rightPosition)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Presto定义了该接口的实现类<code>SimplePagesIndexComparator</code>，该类就是一个函数类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePagesIndexComparator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">PagesIndexComparator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Integer&gt; sortChannels;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;SortOrder&gt; sortOrders;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Type&gt; sortTypes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimplePagesIndexComparator</span><span class="params">(List&lt;Type&gt; sortTypes, List&lt;Integer&gt; sortChannels, List&lt;SortOrder&gt; sortOrders)</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sortTypes = ImmutableList.copyOf(requireNonNull(sortTypes, <span class="string">&quot;sortTypes is null&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.sortChannels = ImmutableList.copyOf(requireNonNull(sortChannels, <span class="string">&quot;sortChannels is null&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.sortOrders = ImmutableList.copyOf(requireNonNull(sortOrders, <span class="string">&quot;sortOrders is null&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PagesIndex pagesIndex, <span class="keyword">int</span> leftPosition, <span class="keyword">int</span> rightPosition)</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> leftPageAddress = pagesIndex.getValueAddresses().getLong(leftPosition);</span><br><span class="line">        <span class="keyword">int</span> leftBlockIndex = decodeSliceIndex(leftPageAddress);</span><br><span class="line">        <span class="keyword">int</span> leftBlockPosition = decodePosition(leftPageAddress);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> rightPageAddress = pagesIndex.getValueAddresses().getLong(rightPosition);</span><br><span class="line">        <span class="keyword">int</span> rightBlockIndex = decodeSliceIndex(rightPageAddress);</span><br><span class="line">        <span class="keyword">int</span> rightBlockPosition = decodePosition(rightPageAddress);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sortChannels.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sortChannel = sortChannels.get(i);</span><br><span class="line">            Block leftBlock = pagesIndex.getChannel(sortChannel).get(leftBlockIndex);</span><br><span class="line">            Block rightBlock = pagesIndex.getChannel(sortChannel).get(rightBlockIndex);</span><br><span class="line"></span><br><span class="line">            SortOrder sortOrder = sortOrders.get(i);</span><br><span class="line">            <span class="keyword">int</span> compare = sortOrder.compareBlockValue(sortTypes.get(i), leftBlock, leftBlockPosition, rightBlock, rightBlockPosition);</span><br><span class="line">            <span class="keyword">if</span> (compare != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> compare;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到<code>SimplePagesIndexComparator</code>类的逻辑相对比较复杂，构造函数也需要传入三个参数：<code>List&lt;Type&gt; sortTypes</code>，<code>List&lt;Integer&gt; sortChannels</code>和<code>List&lt;SortOrder&gt; sortOrders</code>。虽然从接口的角度看，其实代表的是compare的语义，但由于逻辑复杂，而且需要传入三个对象帮助对<code>PagesIndex</code>进行比较，因而不可能实现为匿名类或者Lambda表达式。在Presto中，对它的使用为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PagesIndexOrdering</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PagesIndexComparator comparator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PagesIndexOrdering</span><span class="params">(PagesIndexComparator comparator)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = requireNonNull(comparator, <span class="string">&quot;comparator is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PagesIndexComparator <span class="title">getComparator</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> comparator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the index of the median of the three positions.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">median3</span><span class="params">(PagesIndex pagesIndex, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span>    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ab = comparator.compareTo(pagesIndex, a, b);</span><br><span class="line">        <span class="keyword">int</span> ac = comparator.compareTo(pagesIndex, a, c);</span><br><span class="line">        <span class="keyword">int</span> bc = comparator.compareTo(pagesIndex, b, c);</span><br><span class="line">        <span class="keyword">return</span> (ab &lt; <span class="number">0</span> ?</span><br><span class="line">                (bc &lt; <span class="number">0</span> ? b : ac &lt; <span class="number">0</span> ? c : a) :</span><br><span class="line">                (bc &gt; <span class="number">0</span> ? b : ac &gt; <span class="number">0</span> ? c : a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="匿名类形式"><a href="#匿名类形式" class="headerlink" title="匿名类形式"></a>匿名类形式</h5><p>同样在该框架下定义的<code>IntComparator</code>接口，它的实现就完全不同了。首先是该接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntComparator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Compares the given primitive types.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.util.Comparator</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> A positive integer, zero, or a negative integer if the first</span></span><br><span class="line"><span class="comment">    * argument is greater than, equal to, or smaller than, respectively, the</span></span><br><span class="line"><span class="comment">    * second one.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> k1, <span class="keyword">int</span> k2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在针对整型数据提供排序功能时，用到了<code>IntComparator</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IntBigArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, IntComparator comparator)</span>    </span>&#123;</span><br><span class="line">        IntBigArrays.quickSort(array, from, to, comparator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但由于提供整型数据的比较逻辑相对简单，在Presto中并没有定义显式的函数类，而是使用了Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">groupIds.sort(<span class="number">0</span>, groupByHash.getGroupCount(), (leftGroupId, rightGroupId) -&gt;</span><br><span class="line">                Long.compare(groupByHash.getRawHash(leftGroupId), groupByHash.getRawHash(rightGroupId)));</span><br></pre></td></tr></table></figure>

<p>这里的Lambda表达式其实也可以理解为是一个函数类。</p>
<h5 id="函数重用形式"><a href="#函数重用形式" class="headerlink" title="函数重用形式"></a>函数重用形式</h5><p>还有一种特殊的函数类，它的定义形式与后面介绍的工具类非常相似，同样是定义了一组静态方法，但它的目的不是提供工具或辅助功能，而是将其视为函数成为被重用的单元。这时，需要用到Java 8提供的方法引用（method reference）语法。例如我们要对<code>List&lt;Apple&gt;</code>集合进行过滤，过滤条件分别为颜色与重量，这时可以在<code>Apple</code>类中定义两个静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isGreenApple</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;green&quot;</span>.equals(apple.getColor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHeavyApple</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple.getWeight() &gt; <span class="number">150</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法实际上满足函数接口<code>Predicate&lt;Apple&gt;</code>的定义，因此可以在<code>filter</code>方法中传入这两个方法的引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Apple&gt; <span class="title">filter</span><span class="params">(Predicate&lt;Apple&gt; predicate)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Apple&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Apple apple : apples) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate.test(apple)) &#123;</span><br><span class="line">            result.add(apple);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Apple&gt; <span class="title">filterGreenApples</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> filter(Apple::isGreenApple);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Apple&gt; <span class="title">filterHeavyApples</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> filter(Apple::isHeavyApple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时<code>Apple</code>类可以认为是一个函数类，但准确地说法是一系列可以被重用的函数的容器。与工具类不同的是，这些函数并不是被直接调用，本质上讲，其实是作为“高阶函数”被传递给其他方法而被重用。虽然说实例方法也可以采用这种方式而被重用，但静态方法的调用会更加简单。</p>
<h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><p>在许多项目或开源项目中，随处可见工具类的身影。无需实例化的特性使得我们使用工具类的方式时变得非常的便利，也不需要考虑状态的维护。然而越是方便，我们越是要警惕工具类的陷阱——设计出臃肿庞大无所不能的上帝工具类。工具类仍然要遵循高内聚的原则，只有强相关的职责才能放到同一个工具类中。</p>
<p>在定义工具类时，通常有三类命名范式：</p>
<ul>
<li>名词复数形式：工具类其实就是一系列工具方法的容器，当我们要针对某种类型（或对象）提供工具方法时，可以直接将工具类命名为该类型的复数形式，例如操作<code>Collection</code>的工具类可以命名为<code>Collections</code>，操作<code>Object</code>的工具类可以命名为<code>Objects</code>，而与前置条件有关的工具类则被命名为<code>Preconditions</code>。</li>
<li>以Util为后缀：这体现了工具（Utility）的语义，当我们在类名中看到<code>Util</code>后缀时，就可以直观地了解到这是一个工具类。例如<code>ArrayUtil</code>类是针对数组的工具类，<code>DatabaseUtil</code>是针对数据库操作的工具类，<code>UuidUtil</code>是针对Uuid的工具类。</li>
<li>以Helper为后缀：这种命名相对较少，但许多框架也采用这种命名方式来体现“辅助类”的含义。例如在Druid框架中，就定义了<code>JobHelper</code>、<code>GroupByQueryHelper</code>等辅助类。</li>
</ul>
<p>工具类是无需实例化的，因此在定义工具类时，尽可能将其声明为final类，并为其定义私有的构造函数。例如Guava框架提供的<code>Preconditions</code>工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Preconditions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Preconditions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkArgument</span><span class="params">(<span class="keyword">boolean</span> expression)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!expression) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//other util methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>OO</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>函数范式与领域建模</title>
    <url>/fp-and-domain-model/</url>
    <content><![CDATA[<h2 id="函数范式"><a href="#函数范式" class="headerlink" title="函数范式"></a>函数范式</h2><p>REA的Ken Scambler认为函数范式的主要特征为：模块化（Modularity），抽象化（Abstraction）和可组合（Composability）。这三个特征可以帮助我们编写<strong>简单</strong>的程序。</p>
<p>通常，为了降低系统的复杂度，都需要将系统分解为多个功能的组成部分，每个组成部分有着清晰的边界。<strong>模块化</strong>的编码范式需要支持实现者能够轻易地对模块进行替换，这就要求模块具有隔离性，避免在模块之间出现太多的纠缠。函数范式以“函数”为核心，作为模块化的重要组成部分。函数范式要求函数均为没有副作用的纯函数（pure function）。在推断每个函数的功能时，由于函数没有产生副作用，就可以不考虑该函数当前所处的上下文，形成清晰的隔离边界。这种相互隔离的纯函数使得模块化成为可能。</p>
<p>函数的<strong>抽象</strong>能力不言而喻，因为它本质上是一种将输入类型转换为输出类型的转换行为。任何一个函数都可以视为一种转换(transform)，这是对行为的最高抽象，代表了类型（type）之间的某种动作。极端情况下，我们甚至不用考虑函数的名称和类型，只需要关注其数学本质：<code>f(x) = y</code>。其中，x是输入，y是输出，f就是极度抽象的函数。</p>
<p>函数范式领域模型的核心要素为代数数据类型（Algebraic Data Type, ADT）和纯函数。代数数据类型表达领域概念，纯函数表达领域行为。由于二者皆被定义为不变的、原子的，因此在类型的约束规则下可以对它们进行组合。<strong>可组合</strong>的特征使得函数范式建立的领域模型可以由简单到复杂，利用组合子来表现复杂的领域逻辑。</p>
<span id="more"></span>

<h3 id="代数数据类型"><a href="#代数数据类型" class="headerlink" title="代数数据类型"></a>代数数据类型</h3><p>代数数据类型借鉴了代数学中的概念，作为一种函数式数据结构，体现了函数范式的数学意义。通常，代数数据类型不包含任何行为。它利用<strong>和类型（Sum Type）</strong>来展示相同抽象概念的不同组合，使用<strong>积类型（Product Type）</strong>来展示同一个概念不同属性的组合。</p>
<p>和与积是代数中的概念，它们在函数范式中体现了类型的两种组合模式。和就是加，用以表达一种类型是它的所有子类型之和。例如表达时间单位的TimeUnit类型：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">TimeUnit</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Days</span> <span class="keyword">extends</span> <span class="title">TimeUnit</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Hours</span> <span class="keyword">extends</span> <span class="title">TimeUnit</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Minutes</span> <span class="keyword">extends</span> <span class="title">TimeUnit</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Seconds</span> <span class="keyword">extends</span> <span class="title">TimeUnit</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">MilliSeconds</span> <span class="keyword">extends</span> <span class="title">TimeUnit</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">MicroSeconds</span> <span class="keyword">extends</span> <span class="title">TimeUnit</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">NanoSeconds</span> <span class="keyword">extends</span> <span class="title">TimeUnit</span></span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>由于Java并非真正的函数式语言，较难表达一些函数式特性，因此，本节内容的代码使用Scala语言作为示例。</p>
<p>在上述模型中，<code>TimeUnit</code>是对时间单位概念的一个抽象。定义为和类型，说明它的实例只能是以下的任意一种：Days、Hours、Minutes、Seconds、MilliSeconds、MicroSeconds或NanoSeconds。这是一种逻辑或的关系，用加号来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type TimeUnit = Days + Hours + Minutes + Seconds + MilliSeconds + MicroSeconds + NanoSeconds</span><br></pre></td></tr></table></figure>

<p>积类型体现了一个代数数据类型是其属性组合的笛卡尔积，例如一个员工类型：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">number: <span class="type">String</span>, name: <span class="type">String</span>, email: <span class="type">String</span>, onboardingDate: <span class="type">Date</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>它表示Employee类型是<code>(String, String, String, Date)</code>组合的集合，也就是这四种数据类型的笛卡尔积，在类型语言中可以表达为：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Employee</span> </span>= (<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>, <span class="type">Date</span>)</span><br></pre></td></tr></table></figure>

<p>也可以用乘号来表示这个类型的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type Employee = String * String * String * Date</span><br></pre></td></tr></table></figure>

<p>和类型和积类型的这一特点体现了代数数据类型的组合（combinable）特性。代数数据类型的这两种类型并非互斥的，有的代数数据类型既是和类型，又是积类型，例如银行的账户类型：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Currency</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">RMB</span> <span class="keyword">extends</span> <span class="title">Currency</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">USD</span> <span class="keyword">extends</span> <span class="title">Currency</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">EUR</span> <span class="keyword">extends</span> <span class="title">Currency</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Balance</span>(<span class="params">amount: <span class="type">BigDecimal</span>, currency: <span class="type">Currency</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">number</span></span>: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span></span>: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SavingsAccount</span>(<span class="params">number: <span class="type">String</span>, name: <span class="type">String</span>, dateOfOpening: <span class="type">Date</span></span>) <span class="keyword">extends</span> <span class="title">Account</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BilledAccount</span>(<span class="params">number: <span class="type">String</span>, name: <span class="type">String</span>, dateOfOpening: <span class="type">Date</span>, balance: <span class="type">Balance</span></span>) <span class="keyword">extends</span> <span class="title">Account</span></span></span><br></pre></td></tr></table></figure>

<p>代码中的<code>Currency</code>被定义为和类型，<code>Balance</code>为积类型。<code>Account</code>首先是和类型，它的值要么是<code>SavingsAccount</code>，要么是<code>BilledAccount</code>；同时，每个类型的Account又是一个积类型。</p>
<p>代数数据类型与对象范式的抽象数据类型有着本质的区别。前者体现了数学计算的特性，具有<strong>不变性</strong>。使用Scala的<code>case object</code>或<code>case class</code>语法糖会帮助我们创建一个不可变的抽象。当我们创建了如下的账户对象时，它的值就已经确定，不可改变：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> today = <span class="type">Calendar</span>.getInstance.getTime</span><br><span class="line"><span class="keyword">val</span> balance = <span class="type">Balance</span>(<span class="number">10.0</span>, <span class="type">RMB</span>)</span><br><span class="line"><span class="keyword">val</span> account = <span class="type">BilledAccount</span>(<span class="string">&quot;980130111110043&quot;</span>, <span class="string">&quot;Bruce Zhang&quot;</span>, today, balance)</span><br></pre></td></tr></table></figure>

<p>数据的不变性使得代码可以更好地支持并发，可以随意共享值而无需承受对可变状态的担忧。<strong>不可变数据是函数式编程中实践的重要原则之一</strong>，它可以与纯函数更好地结合。</p>
<p>代数数据类型既体现了领域概念的知识，同时还通过和类型和积类型定义了约束规则，从而建立了严格的抽象。例如类型组合<code>(String, String, Date)</code>是一种高度的抽象，但它却丢失了领域知识，因为它缺乏类型标签，如果采用积类型方式进行定义，则在抽象的同时，还约束了各自的类型。和类型在约束上更进了一步，它将变化建模在一个特定数据类型内部，并限制了类型的取值范围。和类型与积类型结合起来，与操作代数数据类型的函数放在一起，然后利用模式匹配来实现表达业务规则的领域行为。</p>
<p>我们以Robert Martin在《敏捷软件开发》一书中给出的薪资管理系统需求为例，利用函数范式的建模方式来说明代数数据类型的优势。需求描述如下：</p>
<blockquote>
<p>公司雇员有三种类型。一种雇员是钟点工，系统会按照雇员记录中每小时报酬字段的值对他们进行支付。他们每天会提交工作时间卡，其中记录了日期以及工作小时数。如果他们每天工作超过8小时，超过部分会按照正常报酬的1.5倍进行支付。支付日期为每周五。月薪制的雇员以月薪进行支付。每个月的最后一个工作日对他们进行支付。在雇员记录中有月薪字段。销售人员会根据他们的销售情况支付一定数量的酬金（Commssion）。他们会提交销售凭条，其中记录了销售的日期和数量。在他们的雇员记录中有一个酬金报酬字段。每隔一周的周五对他们进行支付。 </p>
</blockquote>
<p>我们现在要计算公司雇员的薪资。从需求看，我们需要建立的领域模型是雇员，它是一个<strong>积类型</strong>。注意，需求虽然清晰地勾勒出三种类型的雇员，但实则它们的差异体现在<strong>收入</strong>的类型上，这种差异体现为<strong>和类型</strong>不同的值。于是，可以得到由如下代数数据类型呈现的领域模型：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ADT定义，体现了领域概念</span></span><br><span class="line"><span class="comment">// Amount是一个积类型，Currency则为前面定义的和类型</span></span><br><span class="line">calse <span class="class"><span class="keyword">class</span> <span class="title">Amount</span>(<span class="params">value: <span class="type">BigDecimal</span>, currency: <span class="type">Currency</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 实现了运算符重载，支持Amount的组合运算</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(that: <span class="type">Amount</span>): <span class="type">Amount</span> = &#123;</span><br><span class="line">        require(that.currency == currency)</span><br><span class="line">        <span class="type">Amount</span>(value + that.value, currency)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">*</span></span>(times: <span class="type">BigDecimal</span>): <span class="type">Amount</span> = &#123;</span><br><span class="line">        <span class="type">Amount</span>(value * times, currency)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下类型皆为积类型，分别体现了工作时间卡与销售凭条领域概念</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeCard</span>(<span class="params">startTime: <span class="type">Date</span>, endTimeDate</span>)</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SalesReceipt</span>(<span class="params">date: <span class="type">Date</span>, amount: <span class="type">Amount</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 支付周期是一个隐藏概念，不同类型的雇员支付周期不同</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">PayrollPeriod</span>(<span class="params">startDate: <span class="type">Date</span>, endDate: <span class="type">Date</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Income的抽象表示成和类型与乘积类型的组合</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Income</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">WeeklySalary</span>(<span class="params">feeOfHour: <span class="type">Amount</span>, timeCards: <span class="type">List</span>[<span class="type">TimeCard</span>], payrollPeriod: <span class="type">PayrollPeriod</span></span>) <span class="keyword">extends</span> <span class="title">Income</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MonthlySalary</span>(<span class="params">salary: <span class="type">Amount</span>, payrollPeriod: <span class="type">PayrollPeriod</span></span>) <span class="keyword">extends</span> <span class="title">Income</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Commission</span>(<span class="params">salary: <span class="type">Amount</span>, saleReceipts: <span class="type">List</span>[<span class="type">SalesReceipt</span>], payrollPeriod: <span class="type">PayrollPeriod</span></span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee被定义为积类型，它组合的Income具有不同的抽象</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">number: <span class="type">String</span>, name: <span class="type">String</span>, onboardingDate: <span class="type">Date</span>, income: <span class="type">Income</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>在定义了以上由代数数据类型组成的领域模型之后，即可将其与领域行为结合起来，例如计算每个雇员的收入。由于<code>Income</code>被定义为和类型，它表达的是一种逻辑或的关系，因此它的每个子类型（称为ADT变体）都将成为模式匹配的分支。和类型的组合有着确定的值（类型理论的术语将其称之为inhabitant），例如<code>Income</code>和类型的值为3，则模式匹配的分支就应该是3个，这就使得Scala编译器可以检查模式匹配的穷尽性。如果模式匹配缺少了对和类型的值表示，编译器都会给出警告。倘若和类型增加了一个新的值，编译器也会指出所有需要新增ADT变体来更新模式匹配的地方。针对<code>Income</code>积类型，可以利用模式匹配结合业务规则对它进行解构，代码如下所示：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculateIncome</span></span>(employee: <span class="type">Employee</span>): <span class="type">Amount</span> = employee.income <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">WeeklySalary</span>(fee, timeCards, _) =&gt; weeklyIncomeOf(fee, timeCards)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">MonthlySalary</span>(salary, _) =&gt; salary</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Commision</span>(salary, saleReceipts, _) =&gt; salary + commistionOf(saleReceipts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>calculateIncome()</code>是一个纯函数，它利用模式匹配，针对<code>Employee</code>的特定<code>Income</code>类型计算雇员的不同收入。</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>在函数范式中，往往使用纯函数（pure function）来表现领域行为。所谓“纯函数”，就是指没有副作用（side effects）的函数。《Scala函数式编程》认为常见的副作用包括：</p>
<ul>
<li>修改一个变量</li>
<li>直接修改数据结构</li>
<li>设置一个对象的成员</li>
<li>抛出一个异常或以一个错误终止</li>
<li>打印到终端或读取用户的输入</li>
<li>读取或写入一个文件</li>
<li>在屏幕上绘画</li>
</ul>
<p>例如，读取花名册文件对内容进行解析获得收件人电子邮件列表的函数为：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(rosterPath: <span class="type">String</span>): <span class="type">List</span>[<span class="type">Email</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> lines = readLines(rosterPath)</span><br><span class="line">    lines.filter(containsValidEmail(_)).map(toEmail(_))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中的<code>readLines()</code>函数需要读取一个外部的花名册文件，这是引起副作用的一个原因。该副作用为单元测试带来了影响。要测试<code>parse()</code>函数，就需要为它事先准备好一个花名册文件，增加了测试的复杂度。同时，该副作用使得我们无法根据输入参数推断函数的返回结果，因为读取文件可能出现一些未知的错误，如读取文件错误，又或者有其他人同时在修改该文件，就可能抛出异常或者返回一个不符合预期的邮件列表。</p>
<p>要将<code>parse()</code>定义为纯函数，就需要分离这种副作用，函数的计算结果就不会受到任何内部或外部过程状态改变的影响。一旦去掉副作用，调用函数返回的结果就与直接使用返回结果具有相同效果，二者可以互相替换，这称之为“引用透明（referential transparency）”。引用透明的替换性可以用于验证一个函数是否是纯函数。假设客户端要根据解析获得的电子邮件列表发送邮件，解析的花名册文件路径为<code>roster.txt</code>。假定解析该花名册得到的电子邮件列表为：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="type">Email</span>(<span class="string">&quot;liubei@dddcompany.com&quot;</span>), <span class="type">Email</span>(<span class="string">&quot;guanyu@dddcompany.com&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>如果<code>parse()</code>是一个纯函数，就需要遵循引用透明的原则，则如下函数调用的行为应该完全相同：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用解析方法</span></span><br><span class="line">send(parse(<span class="string">&quot;roster.txt&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用解析结果</span></span><br><span class="line">send(<span class="type">List</span>(<span class="type">Email</span>(<span class="string">&quot;liubei@dddcompany.com&quot;</span>), <span class="type">Email</span>(<span class="string">&quot;guanyu@dddcompany.com&quot;</span>)))</span><br></pre></td></tr></table></figure>

<p>显然并非如此。后者传入的参数是一个电子邮件列表，而前者除了提供了电子邮件列表之外，还读取了花名册文件。函数获得的电子邮件列表不是由花名册文件路径决定的，而是由读取文件的内容决定。读取外部文件的这种副作用使得我们无法根据确定的输入参数推断出确定的计算结果。要将<code>parse()</code>改造为支持引用透明的纯函数，就需要分离副作用，即将产生副作用的读取外部文件功能推向<code>parse()</code>函数外部：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span></span>(content: <span class="type">List</span>[<span class="type">String</span>]): <span class="type">List</span>[<span class="type">Emial</span>] = </span><br><span class="line">    content.filter(containsValidEmail(_)).map(toEmail(_))</span><br></pre></td></tr></table></figure>

<p>现在，以下代码的行为就是完全相同的：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">send(parse(<span class="type">List</span>(<span class="string">&quot;liubei, liubei@dddcompany.com&quot;</span>, <span class="string">&quot;noname&quot;</span>, <span class="string">&quot;guanyu, guanyu@dddcompany.com&quot;</span>)))</span><br><span class="line"></span><br><span class="line">send(<span class="type">List</span>(<span class="type">Email</span>(<span class="string">&quot;liubei@dddcompany.com&quot;</span>), <span class="type">Email</span>(<span class="string">&quot;guanyu@dddcompany.com&quot;</span>)))</span><br></pre></td></tr></table></figure>

<p>这意味着改进后的<code>parse()</code>可以根据输入结果推断出函数的计算结果，这正是引用透明的价值。<strong>保持函数的引用透明，不产生任何副作用，是函数式编程的基本原则。</strong>如果说面向对象设计需要将依赖尽可能向外推，最终采用依赖注入的方式来降低耦合；那么，函数式编程思想就是要利用纯函数来隔离变化与不变，内部由无副作用的纯函数组成，纯函数将副作用向外推，形成由不变的业务内核与可变的副作用外围组成的结构：</p>
<img src="/fp-and-domain-model/01.png" class="">

<p>具有引用透明特征的纯函数更加贴近数学中的函数概念：没有计算，只有转换。转换操作不会修改输入参数的值，只是基于某种规则把输入参数值转换为输出。输入值和输出值都是不变的（immutable），只要给定的输入值相同，总会给出相同的输出结果。例如我们定义<code>add1()</code>函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add1</span></span>(x: <span class="type">Int</span>):<span class="type">Int</span> =&gt; x + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>基于数学函数的转换（transformation）特征，完全可以翻译为如下代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add1</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> =&gt; x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> =&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="number">2</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="number">3</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="number">4</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到的不是对变量x增加1，而是根据x的值进行模式匹配，然后基于业务规则返回确定的值。这就是纯函数的数学意义。</p>
<p>引用透明、无副作用以及数学函数的转换本质，为纯函数提供了模块化的能力，再结合高阶函数的特性，使纯函数具备了强大的组合（combinable）特性，而这正是函数式编程的核心原则。这种组合性如下图所示：</p>
<img src="/fp-and-domain-model/02.png" class="">

<p>图中的<code>andThen</code>是Scala语言提供的组合子，它可以组合两个函数形成一个新的函数。Scala还提供了<code>compose</code>组合子，二者的区别在于组合函数的顺序不同。上图可以表现为如下Scala代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span></span>: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span>(<span class="params">weight: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Pear</span>(<span class="params">weight: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Fruit</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Banana</span>(<span class="params">weight: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Fruit</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> appleToPear: <span class="type">Apple</span> =&gt; <span class="type">Pear</span> = apple =&gt; <span class="type">Pear</span>(apple.weight)</span><br><span class="line"><span class="keyword">val</span> pearToBanana: <span class="type">Pear</span> =&gt; <span class="type">Banana</span> = pear =&gt; <span class="type">Banana</span>(pear.weight)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用组合</span></span><br><span class="line"><span class="keyword">val</span> appleToBanana = appleToPear andThen pearToBanana</span><br></pre></td></tr></table></figure>

<p>组合后得到的函数类型，以及对该函数的调用如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; val appleToBanana = appleToPear andThen pearToBanana</span><br><span class="line">appleToBanana: Apple =&gt; Banana = &lt;function1&gt;</span><br><span class="line"></span><br><span class="line">scala&gt; appleToBanana(Apple(15))</span><br><span class="line">res0: Banana = Banana(15)</span><br></pre></td></tr></table></figure>

<p>除了纯函数的组合性之外，函数式编程中的Monad模式也支持组合。我们可以简单地将一个Monad理解为提供bind功能的容器。在Scala语言中，bind功能就是<code>flatMap</code>函数。可以简单地将<code>flatMap</code>函数理解为是<code>map</code>与<code>flattern</code>的组合。例如，针对如下的编程语言列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; val l = List(&quot;scala&quot;, &quot;java&quot;, &quot;python&quot;, &quot;go&quot;)</span><br><span class="line">l: List[String] = List(scala, java, python, go)</span><br></pre></td></tr></table></figure>

<p>对该列表执行map操作，对列表中的每个元素执行<code>toCharArray()</code>函数，就可以把一个字符串转换为同样是Monad的字符数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; l.map(lang =&gt; lang.toCharArray)</span><br><span class="line">res7: List[Array[Char]] = List(Array(s, c, a, l, a), Array(j, a, v, a), Array(p, y, t, h, o, n), Array(g, o))</span><br></pre></td></tr></table></figure>

<p><code>map</code>函数完成了从<code>List[String]</code>到<code>List[Array[Char]]</code>的转换。对同一个列表执行相同的转换函数，但调用<code>flatMap</code>函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; l.flatMap(lang =&gt; lang.toCharArray)</span><br><span class="line">res6: List[Char] = List(s, c, a, l, a, j, a, v, a, p, y, t, h, o, n, g, o)</span><br></pre></td></tr></table></figure>

<p><code>flatMap</code>函数将字符串转换为字符数组后，还执行了一次拍平操作，完成了<code>List[String]</code>到<code>List[Char]</code>的转换。</p>
<p>然而在Monad的真正实现中，<code>flatMap</code>并非<code>map</code>与<code>flattern</code>的组合，相反，<code>map</code>函数是<code>flatMap</code>基于unit演绎出来的。因此，Monad的核心其实是<code>flatMap</code>函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span>[<span class="type">A</span>](<span class="params">value: <span class="type">A</span></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">unit</span></span>[<span class="type">B</span>] (value : <span class="type">B</span>) = <span class="keyword">new</span> <span class="type">M</span>(value) </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>) : <span class="type">M</span>[<span class="type">B</span>] = flatMap &#123;x =&gt; unit(f(x))&#125; </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](f: <span class="type">A</span> =&gt; <span class="type">M</span>[<span class="type">B</span>]) : <span class="type">M</span>[<span class="type">B</span>] = ... </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><code>flatMap</code>和<code>map</code>以及<code>filter</code>往往可以组合起来，实现更加复杂的针对Monad的操作。一旦操作变得复杂，这种组合操作的可读性就会降低。例如，我们将两个同等大小列表中的元素项相乘，使用<code>flatMap</code>与<code>map</code>的代码为：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ns = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> os = <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> qs = ns.flatMap(n =&gt; os.map(o =&gt; n * o))</span><br></pre></td></tr></table></figure>

<p>这样的代码并不好理解。为了提高代码的可读性，Scala提供了for-comprehaension。它本质上是Monad的语法糖，组合了flatMap、map与filter等函数；但从语法上看，却类似一个for循环，这就使得我们多了一种可读性更强的调用Monad的形式。同样的功能，使用for-comprehaension语法糖就变成了：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> qs = <span class="keyword">for</span> &#123;</span><br><span class="line">    n &lt;- ns</span><br><span class="line">    o &lt;- os</span><br><span class="line">&#125; <span class="keyword">yield</span> n * o</span><br></pre></td></tr></table></figure>

<p>这里演示的for语法糖看起来像是一个嵌套循环，分别从ns和os中取值，然后利用yield生成器将计算得到的积返回为一个列表；实质上，这段代码与使用<code>flatMap</code>和<code>map</code>的代码完全相同。</p>
<p>在使用纯函数表现领域行为时，我们可以让纯函数返回一个Monad容器，再通过for-comprehaension进行组合。这种方式既保证了代码对领域行为知识的体现，又能因为不变性避免状态变更带来的缺陷。同时，结合纯函数的组合子特性，使得代码的表现力更加强大，非常自然地传递了领域知识。例如，针对下订单场景，需要验证订单，并对验证后的订单进行计算。验证订单时，需要验证订单自身的合法性、客户状态以及库存；对订单的计算则包括计算订单的总金额、促销折扣与运费。</p>
<p>在对这样的需求进行领域建模时，我们需要先寻找到表达领域知识的各个原子元素，包括具体的代数数据类型和实现原子功能的纯函数：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 积类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>(<span class="params">id: <span class="type">OrderId</span>, customerId: <span class="type">CustomerId</span>, desc: <span class="type">String</span>, totalPrice: <span class="type">Amount</span>, discount: <span class="type">Amount</span>, shippingFee: <span class="type">Amount</span>, orderItems: <span class="type">List</span>[<span class="type">OrderItem</span>]</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是验证订单的行为，皆为原子的纯函数，并返回scalaz定义的Validation Monad</span></span><br><span class="line"><span class="keyword">val</span> validateOrder : <span class="type">Order</span> =&gt; <span class="type">Validation</span>[<span class="type">Order</span>, <span class="type">Boolean</span>] = order =&gt;</span><br><span class="line">    <span class="keyword">if</span> (order.orderItems isEmpty) <span class="type">Failure</span>(<span class="string">s&quot;Validation failed for order <span class="subst">$order</span>.id&quot;</span>) </span><br><span class="line">    <span class="keyword">else</span> <span class="type">Success</span>(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> checkCustomerStatus: <span class="type">Order</span> =&gt; <span class="type">Validation</span>[<span class="type">Order</span>, <span class="type">Boolean</span>] = order =&gt; </span><br><span class="line">    <span class="type">Success</span>(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> checkInventory: <span class="type">Order</span> =&gt; <span class="type">Validation</span>[<span class="type">Order</span>, <span class="type">Boolean</span>] = order =&gt; </span><br><span class="line">    <span class="type">Success</span>(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下定义了计算订单的行为，皆为原子的纯函数</span></span><br><span class="line"><span class="keyword">val</span> calculateTotalPrice: <span class="type">Order</span> =&gt; <span class="type">Order</span> = order =&gt; </span><br><span class="line">    <span class="keyword">val</span> total = totalPriceOf(order)</span><br><span class="line">    order.copy(totalPrice = total)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> calculateDiscount: <span class="type">Order</span> =&gt; <span class="type">Order</span> = order =&gt; </span><br><span class="line">    order.copy(discount = discountOf(order))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> calculateShippingFee: <span class="type">Order</span> =&gt; <span class="type">Order</span> = order =&gt;</span><br><span class="line">    order.copy(shippingFee = shippingFeeOf(order))</span><br></pre></td></tr></table></figure>

<p>这些纯函数是原子的、分散的、可组合的，接下来就可以利用纯函数与Monad的组合能力，编写满足业务场景需求的实现代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> order = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合验证逻辑</span></span><br><span class="line"><span class="comment">// 注意返回的orderValidated也是一个Validation Monad</span></span><br><span class="line"><span class="keyword">val</span> orderValidated = <span class="keyword">for</span> &#123;</span><br><span class="line">    _ &lt;- validateOrder(order)</span><br><span class="line">    _ &lt;- checkCustomerStatus(order)</span><br><span class="line">    c &lt;- checkInventory(order)</span><br><span class="line">&#125; <span class="keyword">yield</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (orderValidated.isSuccess) &#123;</span><br><span class="line">    <span class="comment">// 组合计算逻辑，返回了一个组合后的函数</span></span><br><span class="line">    <span class="keyword">val</span> calculate = calculateTotalPrice andThen calculateDiscount andThen calculateShippingFee</span><br><span class="line">    <span class="comment">// 返回具有订单总价、折扣与运费的订单对象</span></span><br><span class="line">    <span class="comment">// 在计算订单的过程中，订单对象是不变的</span></span><br><span class="line">    <span class="keyword">val</span> calculatedOrder = calculate(order)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数范式与领域模型"><a href="#函数范式与领域模型" class="headerlink" title="函数范式与领域模型"></a>函数范式与领域模型</h3><p>遵循函数范式建立领域模型时，代数数据类型与纯函数是主要的建模元素。代数数据类型中的和类型与积类型可以表达领域概念，纯函数则用于表达领域行为。它们都被定义为不变的原子类型，然后再将这些原子的类型与操作组合起来，满足复杂业务逻辑的需要。这是函数式编程中面向组合子（combinator）的建模方法，它与面向对象的建模方法存在思想上的不同。</p>
<p>面向对象的建模方法是一种<strong>归纳法</strong>，通过分析和归纳需求，找到问题域并逐级分解问题，然后通过对象来表达领域逻辑，并以职责的角度分析这些领域逻辑，按照角色把职责分配给各自的对象，通过对象之间的协作实现复杂的领域行为。面向组合子的建模方法则是一种<strong>演绎法</strong>，通过在领域需求中寻找和定义最基本的原子操作，然后根据基本的组合规则将这些原子类型与原子函数组合起来。</p>
<p>因此，函数范式对领域建模的影响是全方位的，它与对象范式看待世界的角度迥然不同。对象范式是在定义一个完整的世界，然后以上帝的身份去规划各自行使职责的对象；函数范式是在组合一个完整的世界，它就像古代哲学家一般，看透了物质的本原而识别出不可再分的原子微粒，然后再按照期望的方式组合这些微粒来创造世界。故而，采用函数范式进行领域建模，关键是组合子包括组合规则的设计，既要简单，又要完整，还需要保证每个组合子的正交性，如此才能对其进行组合，互不冗余，互不干涉。这些组合子，就是前面介绍的代数数据类型和纯函数。</p>
<p>通过前面给出的案例，我们发现函数范式的领域模型颠覆了面向对象思想中“贫血模型是坏的”这一观点。事实上，函数范式的贫血模型不同于结构范式和对象范式的贫血模型。结构范式是将过程与数据分离，这些过程实现的是一个完整的业务场景，由于缺乏完整的封装性，因而无法控制对过程与数据的修改对其他调用者带来的影响。对象范式要求将数据与行为封装在一起，就是为了解决这一问题。函数范式虽然建立的是贫血模型，但它的模块化、抽象化与可组合特征降低了变化带来的影响。在组合这些组合子时，通过引入高内聚松耦合的模块对这些功能进行分组，就能避免细粒度的组合子过于散乱，形成更加清晰的代码层次。</p>
<p>Debasish Ghosh总结了函数范式的基本原则，用以建立更好的领域模型：    </p>
<ul>
<li>利用函数组合的力量，用小函数组装成一个大函数，获得更好的组合性。</li>
<li>纯粹，领域模型的很多部分都由引用透明的表达式组成。</li>
<li>通过方程式推导，可以很容易地推导和验证领域行为。</li>
</ul>
<p>不止如此，根据代数数据类型的不变性以及对模式匹配的支持，它还天生适合表达领域事件。例如地址变更事件，就可以用一个积类型来表示：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">AddressChanged</span>(<span class="params">eventId: <span class="type">EventId</span>, customerId: <span class="type">CustomerId</span>, oldAddress: <span class="type">Address</span>, newAddress: <span class="type">Address</span>, occurred: <span class="type">Time</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>我们还可以用和类型对事件进行抽象，这样就可以在处理事件时运用模式匹配：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">trait</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eventId</span></span>: <span class="type">EventId</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">occurred</span></span>: <span class="type">Time</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">AddressChanged</span>(<span class="params">eventId: <span class="type">EventId</span>, customerId: <span class="type">CustomerId</span>, oldAddress: <span class="type">Address</span>, newAddress: <span class="type">Address</span>, occurred: <span class="type">Time</span></span>) <span class="keyword">extends</span> <span class="title">Event</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountOpened</span>(<span class="params">eventId: <span class="type">EventId</span>, <span class="type">Account</span>: <span class="type">Account</span>, occurred: <span class="type">Time</span></span>) <span class="keyword">extends</span> <span class="title">Event</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(event: <span class="type">Event</span>) = event <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ac: <span class="type">AddressChanged</span> =&gt; ...</span><br><span class="line">    <span class="keyword">case</span> ao: <span class="type">AccountOpened</span> =&gt; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数范式中的代数数据类型仍然可以用来表示实体和值对象，但它们都是不变的，二者的区别主要在于是否需要定义唯一标识符。聚合的概念仍然存在，如果使用Scala语言，往往会为聚合定义满足角色特征的trait，这样就可以使得聚合的实现通过混入多个trait来完成代数数据类型的组合。由于资源库（Repository）会与外部资源进行协作，意味着它会产生副作用，因此遵循函数式编程思想，往往会将其推向纯函数的外部。在函数式语言中，可以利用柯里化（Currying，又译作咖喱化）或者Reader Monad来推迟对资源库具体实现的注入。</p>
<p>主流的领域驱动设计往往以对象范式作为建模范式，利用函数范式建立的领域模型多多少少显得有点“另类”，因此我将其称之为非主流的领域驱动设计。这里所谓的“非主流”，仅仅是从建模范式的普及性角度来考虑的，并不能说明二者的优劣与高下之分。事实上，函数范式可以很好地与事件驱动架构结合在一起，这是一种<strong>以领域事件作为模型驱动设计的驱动力</strong>思想。针对事件进行建模，则任何业务流程皆可用状态机来表达。状态的迁移，就是命令（command）或者决策（decision）对事件的触发。我们还可以利用事件风暴（Event Storming）帮助我们识别这些事件，而事件的不变性特征又可以很好地与函数式编程结合起来。</p>
<p>如果采用命令查询职责分离（CQRS）模式，那么在命令端，将由命令与事件组成一系列异步的非阻塞消息流。这种对消息的认识，恰好可以与响应式编程（Reactive Programming）结合起来。诸如ReactiveX这样的响应式编程框架在参考了迭代器模式与观察者模式的基础上，结合了函数式编程思想，以事件处理的形式实现了异步非阻塞处理，在满足系统架构灵活性与伸缩性的同时，提高了事件处理的响应能力。</p>
<p>显然，围绕着不变的事件为中心，包括响应式编程、事件风暴、事件溯源与命令查询职责分离模式都可以与函数范式有效地结合起来，形成一种事件模型驱动设计(Event Model Driven Design, EDDD)方法。与事件驱动架构不同，事件模型驱动设计可以算是领域驱动设计的一种分支。作为一种设计方法学，它的实践与模式同样涵盖了战略设计与战术设计等多个层次，且可以与领域驱动设计的模式如限界上下文、领域事件、领域服务等结合起来。在金融、通信等少数领域，已经开始了对这种建立在函数范式基础之上的领域驱动设计的尝试，与它们相关的知识可以写成厚厚的一本大书，在这里就不再赘述了。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
        <tag>Scala</tag>
        <tag>FP</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动设计对软件复杂度的应对</title>
    <url>/handling-complex-by-ddd/</url>
    <content><![CDATA[<img src="/handling-complex-by-ddd/cover.jpeg" class="">
<p>不管是因为规模与结构制造的理解力障碍，还是因为变化带来的预测能力问题，最终的决定因素还是因为<strong>需求</strong>。Eric Evans认为“很多应用程序最主要的复杂性并不在技术上，而是来自领域本身、用户的活动或业务”。因而，领域驱动设计关注的焦点在于<strong>领域和领域逻辑</strong>，因为软件系统的本质其实是给客户（用户）提供具有业务价值的领域功能。</p>
<span id="more"></span>

<h1 id="需求引起的软件复杂度"><a href="#需求引起的软件复杂度" class="headerlink" title="需求引起的软件复杂度"></a>需求引起的软件复杂度</h1><p>需求分为业务需求与质量属性需求，因而需求引起的复杂度可以分为两个方面：<strong>技术复杂度</strong>与<strong>业务复杂度</strong>。</p>
<p><strong>技术复杂度来自需求的质量属性</strong>，诸如安全、高性能、高并发、高可用性等需求，为软件设计带来了极大的挑战。让人难受的是这些因素彼此之间又可能互相矛盾互相影响。例如，系统安全性要求对访问进行控制，无论是增加防火墙，还是对传递的消息进行加密，又或者对访问请求进行认证和授权，都需要为整个系统架构添加额外的间接层。这不可避免会对访问的低延迟产生影响，拖慢了系统的整体性能。又例如为了满足系统的高并发访问，我们需要对应用服务进行物理分解，通过横向增加更多的机器来分散访问负载；同时，我们还可以将一个同步的访问请求拆分为多级步骤的异步请求，再通过引入消息中间件对这些请求进行整合和分散处理。这种分离一方面增加了系统架构的复杂性，另一方面也因为引入了更多的资源，使得系统的高可用面临挑战，并增加了维护数据一致性的难度。</p>
<p><strong>业务复杂度对应了客户的业务需求</strong>，因而这种复杂度往往会随着需求规模的增大而增加。由于需求不可能做到完全独立，一旦规模扩大到一定程度，不仅产生了功能数量的增加，还会因为功能互相之间的依赖与影响使得这种复杂度产生叠加，进而影响到整个系统的质量属性，例如系统的可维护性与可扩展性。在考虑系统的业务需求时，还会因为沟通不畅、客户需求不清晰等多种局外因素带来需求的变更和修改。如果不能很好地控制这种变更，就可能因为多次修改导致业务逻辑纠缠不清，系统可能开始慢慢腐烂，变得不可维护，最终形成一种如Brian Foote和Joseph Yoder所说的“大泥球”系统。</p>
<p>以电商系统的促销规则为例。针对不同类型的顾客与产品，商家会提供不同的促销力度；促销的形式多种多样，包括赠送积分、红包、优惠券、礼品；促销的周期需要支持定制，既可以是特定的日期，例如双十一促销，也可以是节假日的固定促销模式。如果我们在设计时没有充分考虑促销规则的复杂度，并处理好促销规则与商品、顾客、卖家与支付乃至于物流、仓储之间的关系，开发过程就会变得踉踉跄跄，举步维艰。</p>
<p><strong>技术复杂度与业务复杂度并非完全独立，二者混合在一起产生的化合作用更让系统的复杂度变得不可预期，难以掌控。</strong>同时，技术的变化维度与业务的变化维度并不相同，产生变化的原因也不一致，倘若未能很好地界定二者之间的关系，系统架构缺乏清晰边界，会变得难以梳理。复杂度一旦增加，团队规模也将随之扩大，再揉以严峻的交付周期、人员流动等诸多因素，就好似将各种不稳定的易燃易爆气体混合在一个不可逃逸的密闭容器中一般，随时都可能爆炸：</p>
<img src="/handling-complex-by-ddd/01.png" class="">

<p>随着业务需求的增加与变化，以及对质量属性的高标准要求，自然也引起了软件系统规模的增大与结构的繁杂，至于变化，则是软件开发绕不开的话题。因此，当我们面对一个相对复杂的软件系统时，通常面临的问题在于：</p>
<ul>
<li>问题域过于庞大而复杂，使得从问题域中寻求解决方案的挑战增加。该问题与软件系统的<strong>规模</strong>有关。</li>
<li>开发人员将业务逻辑的复杂度与技术实现的复杂度混淆在一起。该问题与软件系统的<strong>结构</strong>有关。</li>
<li>随着需求的增长和变化，无法控制业务复杂度和技术复杂度。该问题与软件系统的<strong>变化</strong>有关。</li>
</ul>
<p>针对这三个问题，领域驱动设计都给出了自己的应对措施。</p>
<h1 id="领域驱动设计的应对措施"><a href="#领域驱动设计的应对措施" class="headerlink" title="领域驱动设计的应对措施"></a>领域驱动设计的应对措施</h1><h2 id="隔离业务复杂度与技术复杂度"><a href="#隔离业务复杂度与技术复杂度" class="headerlink" title="隔离业务复杂度与技术复杂度"></a>隔离业务复杂度与技术复杂度</h2><p>要避免业务逻辑的复杂度与技术实现的复杂度混淆在一起，<strong>首要任务就是确定业务逻辑与技术实现的边界，从而隔离各自的复杂度。</strong>这种隔离也是题中应有之义，毕竟技术与业务的关注点完全不同。例如在电商的领域逻辑中，订单业务关注的业务规则包括验证订单有效性，计算订单总额，提交和审核订单的流程等；技术关注点则从实现层面保障这些业务能够正确地完成，包括确保分布式系统之间的数据一致性，确保服务之间通信的正确性等。</p>
<p>业务逻辑并不关心技术是如何实现的。无论采用何种技术，只要业务需求不变，业务规则就不会变化。换言之，<strong>理想状态下，我们应该保证业务规则与技术实现是正交的</strong>。</p>
<p>领域驱动设计通过<strong>分层架构</strong>与<strong>六边形架构</strong>确保业务逻辑与技术实现的隔离。</p>
<h3 id="分层架构的关注点分离"><a href="#分层架构的关注点分离" class="headerlink" title="分层架构的关注点分离"></a>分层架构的关注点分离</h3><p>分层架构遵循了“关注点分离”原则，将属于业务逻辑的关注点放到领域层（Domain Layer）中，而将支撑业务逻辑的技术实现放到基础设施层（Infrastructure Layer）中。同时，领域驱动设计又颇具创见的引入了应用层（Application Layer）。应用层扮演了双重角色。一方面它作为业务逻辑的外观（Facade），暴露了能够体现业务用例的应用服务接口；另一方面它又是业务逻辑与技术实现的粘合剂，实现二者之间的协作。</p>
<p>下图展现的就是一个典型的领域驱动设计分层架构。蓝色区域的内容与业务逻辑有关，灰色区域的内容与技术实现有关，二者泾渭分明，然后汇合在应用层。应用层确定了业务逻辑与技术实现的边界，通过直接依赖或者依赖注入（DI，Dependency Injection）的方式将二者结合起来：</p>
<img src="/handling-complex-by-ddd/02.jpg" class="">

<h3 id="六边形架构的内外分离"><a href="#六边形架构的内外分离" class="headerlink" title="六边形架构的内外分离"></a>六边形架构的内外分离</h3><p>由Cockburn提出的六边形架构则以“内外分离”的方式，更加清晰地勾勒出业务逻辑与技术实现的边界，且将业务逻辑放在了架构的核心位置。这种架构模式改变了我们观察系统架构的视角：</p>
<img src="/handling-complex-by-ddd/03.jpg" class="">

<p>体现业务逻辑的应用层与领域层处于六边形架构的内核，并通过内部的六边形边界与基础设施的模块隔离开。当我们在进行软件开发时，只要恪守架构上的六边形边界，就不会让技术实现的复杂度污染到业务逻辑，保证了领域的整洁。边界还隔离了变化产生的影响。如果我们在领域层或应用层抽象了技术实现的接口，再通过依赖注入将控制的方向倒转，业务内核就会变得更加的稳定，不会因为技术选型或其他决策的变化而导致领域代码的修改。</p>
<h3 id="案例：隔离数据库与缓存的访问"><a href="#案例：隔离数据库与缓存的访问" class="headerlink" title="案例：隔离数据库与缓存的访问"></a>案例：隔离数据库与缓存的访问</h3><p>领域驱动设计建议我们在领域层建立资源库（Repository）的抽象，它的实现则被放在基础设施层，然后采用依赖注入在运行时为业务逻辑注入具体的资源库实现。那么，对于处于内核之外的Repositories模块而言，即使选择从MyBatis迁移到Sprint Data，领域代码都不会受到牵连：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> practiceddd.ecommerce.ordercontext.application;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderAppService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="keyword">private</span> PlaceOrderService placeOrder;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">placeOrder</span><span class="params">(Identity buyerId, List&lt;OrderItem&gt; items, ShippingAddress shipping, BillingAddress billing)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            palceOrder.execute(buyerId, items, shipping, billing);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OrderRepositoryException | InvalidOrderException | Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            logger.error(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> practiceddd.ecommerce.ordercontext.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Order&gt; <span class="title">forBuyerId</span><span class="params">(Identity buyerId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlaceOrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Repository</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="keyword">private</span> OrderValidator orderValidator;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Identity buyerId, List&lt;OrderItem&gt; items, ShippingAddress shipping, BillingAddress billing)</span> </span>&#123;</span><br><span class="line">        Order order = Order.create(buyerId, items, shipping, billing);</span><br><span class="line">        <span class="keyword">if</span> (orderValidator.isValid(order)) &#123;</span><br><span class="line">            orderRepository.add(order);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOrderException(String.format(<span class="string">&quot;the order which placed by buyer with %s is invalid.&quot;</span>, buyerId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> practiceddd.ecommerce.ordercontext.infrastructure.db;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMybatisRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepository</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderSprintDataRepository</span> <span class="keyword">implements</span> <span class="title">OrderRepository</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对缓存的处理可以如法炮制，但它与资源库稍有不同之处。资源库作为访问领域模型对象的入口，其本身提供的增删改查功能，在抽象层面上是对领域资源的访问。因此在领域驱动设计中，我们通常将资源库的抽象归属到领域层。对缓存的访问则不相同，它的逻辑就是对key和value的操作，与具体的领域无关。倘若要为缓存的访问方法定义抽象接口，在分层的归属上应该属于应用层，至于实现则属于技术范畴，应该放在基础设施层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> practiceddd.ecommerce.ordercontext.application;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderAppService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Repository</span></span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="keyword">private</span> CacheClient&lt;List&lt;Order&gt;&gt; cacheClient;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Order&gt; <span class="title">findBy</span><span class="params">(Identity buyerId)</span> </span>&#123;</span><br><span class="line">        Optional&lt;List&lt;Order&gt;&gt; cachedOrders = cacheClient.get(buyerId.value());</span><br><span class="line">        <span class="keyword">if</span> (cachedOrders.isPresent()) &#123;</span><br><span class="line">            <span class="keyword">return</span> orders.get();</span><br><span class="line">        &#125; </span><br><span class="line">        List&lt;Order&gt; orders = orderRepository.forBuyerId(buyerId);</span><br><span class="line">        <span class="keyword">if</span> (!orders.isEmpty()) &#123;</span><br><span class="line">            cacheClient.put(buyerId.value(), orders);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> orders;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> practiceddd.ecommerce.ordercontext.application.cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheClient</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Optional&lt;T&gt; <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, T value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> practiceddd.ecommerce.ordercontext.infrastructure.cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheClient</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CacheClient</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>


<h2 id="限界上下文的分而治之"><a href="#限界上下文的分而治之" class="headerlink" title="限界上下文的分而治之"></a>限界上下文的分而治之</h2><p>在前面分析缓存访问接口的归属时，我们将接口放在了系统的应用层。从层次的职责来看，这样的设计是合理的，但它却使得系统的应用层变得更加臃肿，职责也变得不够单一了。这是分层架构与六边形架构的局限所在，因为这两种架构模式仅仅体现了一个软件系统的逻辑划分。倘若我们将一个软件系统视为一个纵横交错的魔方，前述的逻辑划分仅仅是一种水平方向的划分。至于垂直方向的划分，则是面向垂直业务的切割。这种方式更利于控制软件系统的规模，将一个庞大的软件系统划分为松散耦合的多个小系统的组合。</p>
<p>针对前述案例，我们可以将缓存视为一个独立的子系统。它同样拥有自己的业务逻辑和技术实现，因而也可以为其建立属于缓存领域的分层架构。在架构的宏观视角，这个缓存子系统与订单子系统处于同一个抽象层次，这一概念在领域驱动设计中，被称之为限界上下文（Bounded Context）。</p>
<p>针对庞大而复杂的问题域，限界上下文采用了“分而治之”的思想对问题域进行了分解，有效地控制了问题域的规模，进而控制了整个系统的规模。一旦规模减小，无论业务复杂度还是技术复杂度，都会得到显著的降低，在对领域进行分析以及建模时，也能变得更容易。如果说分层架构与六边形架构确保了业务逻辑与技术实现的隔离，则限界上下文对整个系统进行了划分，将一个大系统拆分为一个个小系统后，我们再利用分层架构与六边形架构思想对其进行逻辑分层，设计会变得更易于把控，系统的架构也会变得更加的清晰。</p>
<h3 id="案例：限界上下文帮助架构的演进"><a href="#案例：限界上下文帮助架构的演进" class="headerlink" title="案例：限界上下文帮助架构的演进"></a>案例：限界上下文帮助架构的演进</h3><p>国际报税系统是为跨国公司的驻外出差雇员（系统中被称之为Assignee）提供方便一体化的税收信息填报平台。客户是一家会计师事务所，该事务所的专员（Admin）通过该平台可以收集雇员提交的报税信息，然后对这些信息进行税务评审。如果Admin评审出信息有问题，则返回给Assignee重新修改和填报。一旦信息确认无误，则进行税收分析和计算，并获得最终的税务报告提交给当地政府以及雇员本人。</p>
<p>系统主要涉及的功能包括：</p>
<ul>
<li>驻外出差雇员的薪酬与福利</li>
<li>税收计划与合规评审</li>
<li>对税收评审的分配管理</li>
<li>税收策略设计与评审</li>
<li>对驻外出差雇员的税收合规评审</li>
<li>全球的Visa服务</li>
</ul>
<p>主要涉及的用户角色包括：</p>
<ul>
<li>Assignee：驻外出差雇员</li>
<li>Admin：税务专员</li>
<li>Client：出差雇员的雇主</li>
</ul>
<p>在早期的架构设计时，架构师并没有对整个系统的问题域进行拆分，而是基于用户角色对系统进行了简单粗暴的划分，分为两个相对独立的子系统：Frond End与Office End。这两个子系统单独部署，分别面向Assignee与Admin。系统之间的集成则通过消息和Web Service进行通信。两个子系统的开发分属不同的团队，Frond End由美国的团队负责开发与维护，而Office End则由印度的团队负责。整个架构如下图所示：</p>
<img src="/handling-complex-by-ddd/04.jpg" class="">

<p>采用这种架构面临如下问题：</p>
<ul>
<li>庞大的代码库：整个Front End和Office End都没有做物理分解，随着需求的增多，代码库变得格外庞大</li>
<li>分散的逻辑：系统分解的边界是不合理的，没有按照业务分解，而是按照用户的角色进行分解，导致大量相似的逻辑分散在两个不同的子系统中</li>
<li>重复的数据：两个子系统中存在业务重叠，因而也导致了部分数据的重复</li>
<li>复杂的集成：Front End与Office End因为某些相关的业务需要彼此通信，这种集成关系是双向的，且由两个不同的团队开发，导致集成的接口混乱，消息协议多样化</li>
<li>知识未形成共享：两个团队完全独立开发，没有掌握端对端的整体流程，团队之间没有形成知识的共享</li>
<li>无法应对需求变化： 新增需求包括对国际旅游、Visa的支持，现有系统的架构无法很好地支持这些变化</li>
</ul>
<p>采用领域驱动设计，我们将架构的主要关注点放在了“领域”，与客户进行了充分的需求沟通和交流。通过分析已有系统的问题域，结合客户提出的新需求，对整个问题域进行了梳理，并利用限界上下文对问题域进行了分解，获得了如下限界上下文：</p>
<ul>
<li>Account Management：管理用户的身份与配置信息</li>
<li>Calendar Management：管理用户的日程与旅行足迹</li>
</ul>
<p>之后，客户希望能改进需求，做到全球范围内的工作指派与管理，目的在于提高公司的运营效率。通过对领域的分析，我们又识别出两个限界上下文。在原有的系统架构中，这两个限界上下文同时处于Front End与Office End之中，属于重复开发的业务逻辑：</p>
<ul>
<li>Work Record Management：实现工作的分配与任务的跟踪</li>
<li>File Sharing：目的是实现客户与会计师事务所之间的文件交换</li>
</ul>
<p>随着我们对领域知识的逐渐深入理解与分析，又随之识别出如下限界上下文：</p>
<ul>
<li>Consent：管理合法的遵守法规的状态</li>
<li>Notification：管理系统与客户之间的交流</li>
<li>Questionnaire：对问卷调查的数据收集</li>
</ul>
<p>这个领域分析的过程实际上就是通过对领域的分析，引入限界上下文对问题域进行分解，通过降低规模的方式降低问题域的复杂度；同时，通过为模型确定清晰的边界，使得系统的结构变得更加的清晰，保证了领域逻辑的一致性。一旦确定了清晰的领域模型，就能够帮助我们更加容易地发现系统的可重用点与可扩展点，并遵循“高内聚松耦合”原则对系统职责进行合理分配，再辅以分层架构划分逻辑边界，如下图所示：</p>
<img src="/handling-complex-by-ddd/05.jpg" class="">

<p>我们将识别出来的限界上下文定义为微服务，并对外公开REST服务接口。UI Applications是一个薄薄的展现层，它会调用后端的RESTful服务，也使得服务在保证接口不变的前提下能够单独演化。每个服务都是独立的，可以单独部署，因而可以针对服务建立单独的代码库和对应的特性团队（Feature Team）。服务的重用性和可扩展性也有了更好的保障，服务与UI之间的集成变得更简单，整个架构更加清晰了。</p>
<h2 id="领域模型对领域知识的抽象"><a href="#领域模型对领域知识的抽象" class="headerlink" title="领域模型对领域知识的抽象"></a>领域模型对领域知识的抽象</h2><p>领域模型是对业务需求的一种<strong>抽象</strong>，表达了领域概念、领域规则以及领域概念之间的关系。一个好的领域模型是对统一语言的可视化表示，通过它可以减少需求沟通可能出现的歧义；通过提炼领域知识，并运用抽象的领域模型去表达，就可以达到对领域逻辑的化繁为简。模型是封装，实现了对业务细节的隐藏；模型是抽象，提取了领域知识的共同特征，保留了面对变化时能够良好扩展的可能性。</p>
<h3 id="案例：项目管理系统的领域模型"><a href="#案例：项目管理系统的领域模型" class="headerlink" title="案例：项目管理系统的领域模型"></a>案例：项目管理系统的领域模型</h3><p>我们开发的项目管理系统需要支持多种软件项目管理流程，例如瀑布、RUP、XP或者Scrum。这些项目管理流程是迥然不同的，如果需要各自提供不同的解决方案，就会使得系统的模型变得非常复杂，也可能引入许多不必要的重复。通过领域建模，我们可以对项目管理领域的知识进行抽象，寻找具有共同特征的领域概念。这就需要分析各种项目管理流程的主要特征与表现，才能从中提炼出领域模型。</p>
<p>瀑布式软件开发由需求、分析、设计、编码、测试、验收六个阶段构成，每个阶段都由不同的活动构成，这些活动可能是设计或开发任务，也可能是召开评审会。流程如下图所示：</p>
<img src="/handling-complex-by-ddd/06.jpg" class="">

<p>RUP清晰地划分了四个阶段：先启阶段、细化阶段、构造阶段与交付阶段。每个阶段可以包含一到多个迭代，每个迭代有不同的工作，例如业务建模、分析设计、配置与变更管理等。RUP的流程如下图所示：</p>
<img src="/handling-complex-by-ddd/07.jpg" class="">

<p>XP作为一种敏捷方法，采用了迭代的增量式开发，提倡为客户交付具有业务价值的可运行软件。在执行交付计划之前，XP要求团队对系统的架构做一次预研（Architectual Spike，又被译为架构穿刺）。当架构的初始方案确定后，就可以进入每次小版本的交付。每个小版本交付又被划分为多个周期相同的迭代。在迭代过程中，要求执行一些必须的活动，如编写用户故事、故事点估算、验收测试等。XP的流程如下图所示：</p>
<img src="/handling-complex-by-ddd/08.jpg" class="">

<p>Scrum同样是迭代的增量开发过程。项目在开始之初，需要在准备阶段确定系统愿景、梳理业务用例、确定产品待办项（product backlog）、制定发布计划以及组建团队。一旦在确定了产品待办项以及发布计划之后，就进入sprint迭代阶段。sprint迭代过程是一个固定时长的项目过程，在这个过程中，整个团队需要召开计划会议、每日站会、评审会议和回顾会议。Scrum的流程如下图所示：</p>
<img src="/handling-complex-by-ddd/09.jpg" class="">

<p>不同的项目管理流程具有不同的业务概念。例如瀑布式开发分为了六个阶段，但却没有发布和迭代的概念。RUP没有发布的概念，而Scrum又为迭代引入了sprint的概念。</p>
<p>不同的项目管理流程具有不同的业务规则。例如RUP的四个阶段会包含多个迭代周期，每个迭代周期都需要完成对应的工作，只是不同的工作在不同阶段所占的比重不同。XP需要在进入发布阶段之前，进行架构预研，而在每次小版本发布之前，都需要进行验收测试和客户验收。Scrum的sprint是一个基本固定的流程，每个迭代召开的四会（计划会议、评审会议、回顾会议与每日站会）都有明确的目标。</p>
<p>领域建模就是要从这些纷繁复杂的领域逻辑中寻找到能够表示项目管理领域的概念，并利用面向对象建模范式或其他范式对概念进行抽象，并确定它们之间的关系。经过对这些项目管理流程的分析，我们虽然发现在业务概念和规则上确有不同之处，但由于它们都归属于软件开发领域，我们自然也能寻找到某些共同特征的蛛丝马迹。</p>
<p>首先，从项目管理系统的角度看，无论针对何种项目管理流程，我们的主题需求是不变的，就是要为这些管理流程制定软件开发计划（Plan）。不同之处在于，计划可以由多个阶段（Phase）组成，也可以由多个发布（Release）组成。一些项目管理流程没有发布的概念，我们可以认为是<strong>一个发布</strong>。那么，到底是发布包含了多个阶段，还是阶段包含了多个发布呢？我们发现在XP中，明显地划分了两个阶段：Architecture Spike与Release Planning，而发布只属于Release Planning阶段。因而从概念内涵上，我们可以认为是阶段（Phase）包含了发布（Release）。每个发布又包含了一到多个迭代（Iteration），至于Scrum的sprint概念其实可以看做是迭代的一种特例。每个迭代可以开展多种不同的活动（Activity），这些活动可以是整个团队参与的会议，也可以是部分成员或特定角色执行的实践。对于计划而言，我们还需要跟踪任务（Task）。与活动不同，任务具有明确的计划起止时间、实际起止时间、工作量、优先级与承担人。</p>
<p>于是，我们提炼出如下的统一领域模型：</p>
<img src="/handling-complex-by-ddd/10.jpg" class="">

<p>为了项目管理者更加方便地制定项目计划，产品经理提出了计划模板功能。当管理者选择对应的项目管理生命周期类型后，系统会自动创建满足其规则的初始计划。基于该需求，我们更新了之前的领域模型：</p>
<img src="/handling-complex-by-ddd/11.jpg" class="">

<p>在增加的领域模型中，LifeCycleSpecification是一个隐含的概念，遵循领域驱动设计提出的规格（Specification）模式，封装了项目开发生命周期的约束规则。</p>
<p>领域模型以可视化的方式清晰地表达了业务含义，我们可以根据这个模型来指导后面的程序设计与编码实现。当增加新的需求或者需求发生变化时，我们能够敏锐地捕捉到现有模型的不匹配之处，并对其进行更新。领域模型传递了知识，可以作为交流的载体，符合人们的心智模型，有利于让开发人员从纷繁复杂的业务中解脱出来。这是领域驱动设计对于前述第三个问题——控制业务复杂度的解答。</p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Architecture</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Spring Cloud的微服务落地</title>
    <url>/micro-service-based-on-spring-cloud/</url>
    <content><![CDATA[<img src="/micro-service-based-on-spring-cloud/logo.jpeg" class="">
<p>微服务架构模式的核心在于如何识别服务的边界，设计出合理的微服务。但如果要将微服务架构运用到生产项目上，并且能够发挥该架构模式的重要作用，则需要微服务框架的支持。</p>
<span id="more"></span>

<p>在Java生态圈，目前使用较多的微服务框架就是集成了包括Netfilix OSS以及Spring的Spring Cloud。它包括：</p>
<ul>
<li>Spring Cloud Config：配置管理工具，支持使用Git存储配置内容，可以实现应用配置的外部化存储，支持客户端配置信息刷新、加密/解密配置内容等。</li>
<li>Spring Cloud Netflix：对Netflix OSS进行了整合。其中又包括：<ul>
<li>Eureka：服务治理组件，包含服务注册中心、服务注册与发现。</li>
<li>Hystrix：容器管理组件，实现断路器模式，倘若依赖的服务出现延迟或故障，则提供强大的容错功能。</li>
<li>Ribbon：客户端负载均衡的服务调用组件。</li>
<li>Feign：基于Ribbon和Hystrix的声明式服务调用组件。</li>
<li>Zuul：网关组件，提供智能路由、访问过滤等功能。</li>
<li>Archaius：外部化配置组件。</li>
</ul>
</li>
<li>Spring Cloud Bus：事件、消息总线。</li>
<li>Spring Cloud Cluster：针对ZooKeeper、Redis、Hazelcast、Consul的选举算法和通用状态模式的实现。</li>
<li>Spring Cloud Cloudfoundry：与Pivotal Cloudfoundry的整合支持。</li>
<li>Spring Cloud Consul：服务发现与配置管理工具。</li>
<li>Spring Cloud Stream：通过Redis、Rabbit或者Kafka实现的消息驱动的微服务。</li>
<li>Spirng Cloud AWS：简化和整合Amazon Web Service。</li>
<li>Spring Cloud Security：安全工具包，提供Zuul代理中对OAuth2客户端请求的中继器。</li>
<li>Spring Cloud Sleuth：Spring Cloud应用的分布式跟踪实现，可以整合Zipkin。</li>
<li>Spring Cloud ZooKeeper：基于ZooKeeper的服务发现与配置管理组件。</li>
<li>Spring Cloud Starters：Spring Cloud的基础组件，是基于Spring Boot风格项目的基础依赖模块。</li>
<li>Spring Cloud CLI：用于在Groovy中快速创建Spring Cloud应用的Spring Boot CLI插件。</li>
</ul>
<h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><p>当一个系统的微服务数量越来越多的时候，我们就需要对服务进行治理，提供统一的服务注册中心，然后在其框架下提供发现服务的功能。这样就避免了对多个微服务的配置，以及微服务之间以及与客户端之间的耦合。</p>
<p>Spring Cloud Eureka是对Netflix Eureka的包装，用以实现服务注册与发现。Eureka服务端即服务注册中心，支持高可用配置。它依托于强一致性提供良好的服务实例可用性，并支持集群模式部署。Eureka客户端则负责处理服务的注册与发现。客户端服务通过annotation与参数配置的方式，嵌入在客户端应用程序代码中。在运行应用程序时，Eureka客户端向注册中心注册自身提供的服务，并周期性地发送心跳更新它的服务租约。</p>
<h4 id="搭建服务注册中心"><a href="#搭建服务注册中心" class="headerlink" title="搭建服务注册中心"></a>搭建服务注册中心</h4><p>服务注册中心是一个独立部署的服务（你可以认为它也是一个微服务），所以需要单独为它创建一个项目，并在pom.xml中添加Eureka的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建Spring Boot Application：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注册服务提供者"><a href="#注册服务提供者" class="headerlink" title="注册服务提供者"></a>注册服务提供者</h4><p>要让自己编写的微服务能够注册到Eureka服务器中，需要在服务的Spring Boot Application中添加<code>@EnableDiscoveryClient</code>注解，如此才能让Eureka服务器发现该服务。当然，pom.xml文件中也需要添加相关依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时，我们还需要为服务命名，并指定地址。这些信息都可以在application.properties配置文件中配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.application.name=demo-service</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka/</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>Spring更推荐使用yml文件来维护系统的配置，yml文件可以体现出配置节的层次关系，表现力比单纯的key-value形式更好。如果结合使用后面讲到的Spring Cloud Config，则客户端的配置文件必须命名为bootstrap.properties或者bootstrap.yml。与上述配置相同的yml文件配置为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo-service</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span> </span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:1111/eureka/</span></span><br></pre></td></tr></table></figure>

<h4 id="服务发现与消费"><a href="#服务发现与消费" class="headerlink" title="服务发现与消费"></a>服务发现与消费</h4><p>在微服务架构下，许多微服务可能会扮演双重身份。一方面它是服务的提供者，另一方面它又可能是服务的消费者。注册在Eureka Server中的微服务可能会被别的服务消费。此时，就相当于在服务中创建另一个服务的客户端，并通过RestTemplate发起对服务的调用。为了更好地提高性能，可以在服务的客户端引入Ribbon，作为客户端负载均衡。</p>
<p>现在假定我们要为demo-service创建一个服务消费者demo-consumer。该消费者自身也是一个Spring Boot微服务，同时也能够被Eureka服务器注册。这时，就需要在该服务的pom.xml中添加eureka与ribbon的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在主应用类<code>ConosumerApplication</code>中注入<code>RestTemplate</code>，并引入<code>@LoadBalanced</code>注解开启客户端负载均衡：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设消费demo-service的客户端代码写在demo-consumer服务的其中一个Controller中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/demo-consumer&quot;, method = RequestMethod.Get)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://demo-service/demo&quot;</span>, String.class).getBody(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>RestTemplate</code>就可以发起对demo-service的消费调用。</p>
<h4 id="声明式服务调用"><a href="#声明式服务调用" class="headerlink" title="声明式服务调用"></a>声明式服务调用</h4><p>通过Ribbon和Hystrix可以实现对微服务的调用以及容错保护，但Spring Cloud还提供了另一种更简单的声明式服务调用方式，即Spring Cloud Feign。Feign实际上就是对Ribbon与Hystrix的进一步封装。通过Feign，我们只需创建一个接口并用annotation的方式配置，就可以完成对服务供应方的接口（REST API）绑定。</p>
<p>假设我们有三个服务：</p>
<ul>
<li>Notification Service</li>
<li>Account Service</li>
<li>Statistics Service</li>
</ul>
<p>服务之间的依赖关系如下图所示：</p>
<img src="/micro-service-based-on-spring-cloud/ms-01.png" class="">

<p>要使用Feign来完成声明式的服务调用，需要在作为调用者的服务中创建Client。Client通过Eureka Server调用注册的对应服务，这样可以解除服务之间的耦合。结构如下图所示：</p>
<img src="/micro-service-based-on-spring-cloud/ms-02.png" class="">

<p>为了使用Feign，需要对应微服务的pom.xml文件中添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时，还需要在被消费的微服务Application中添加<code>@EnableFeignClients</code>注解。例如在Statistics服务的应用程序类中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(StatisticsApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于Account服务需要调用Statistics服务，因此需要在Account服务项目中增加对应的client接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;statistics-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatisticsServiceClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(method = RequestMethod.PUT, value = &quot;/statistics/&#123;accountName&#125;&quot;, consumes = MediaType.APPLICATION_JSON_UTF8_VALUE)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateStatistics</span><span class="params">(<span class="meta">@PathVariable(&quot;accountName&quot;)</span> String accountName, Account account)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StatisticsServiceClient接口的<code>updateStatistics()</code>方法会调用URI为<code>/statistics/&#123;accountName&#125;</code>的REST服务，且HTTP动词为put。这个服务其实对应就是Statistics Service中StatisticsController类中的<code>saveStatistics()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatisticsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StatisticsService statisticsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/&#123;accountName&#125;&quot;, method = RequestMethod.PUT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveStatistics</span><span class="params">(<span class="meta">@PathVariable</span> String accountName, <span class="meta">@Valid</span> <span class="meta">@RequestBody</span> Account account)</span> </span>&#123;</span><br><span class="line">        statisticsService.save(accountName, account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Account服务中，如果要调用Statistics服务，都应该通过StatisticsServiceClient接口进行调用。例如，Account服务中的AccountServiceImpl要调用<code>updateStatistics()</code>方法，就可以在该类的实现中通过<code>@autowired</code>注入StatisticsServiceClient接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StatisticsServiceClient statisticsClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveChanges</span><span class="params">(String name, Account update)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        statisticsClient.updateStatistics(name, account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notification服务对Account服务的调用如法炮制。</p>
<h3 id="服务容错保护"><a href="#服务容错保护" class="headerlink" title="服务容错保护"></a>服务容错保护</h3><p>在微服务架构中，微服务之间可能存在依赖关系，例如Notification Service会调用Account Service，Account Service调用Statistics Service。真实产品中，微服务之间的调用会更加寻常。倘若上游服务出现了故障，就可能会因为依赖关系而导致故障的蔓延，最终导致整个系统的瘫痪。</p>
<p>Spring Cloud Hystrix通过实现断路器（Circuit Breaker）模式以及线程隔离等功能，实现服务的容错保护。</p>
<p>仍然参考前面的例子。现在系统的微服务包括：</p>
<ul>
<li>上游服务：demo-service</li>
<li>下游服务：demo-consumer</li>
<li>Eureka服务器：eureka-server</li>
</ul>
<p>假设上游服务可能会出现故障，为保证系统的健壮性，需要在下游服务中加入容错包含功能。首先需要在demo-consumer服务中添加对hystrix的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在demo-consumer的应用程序类中加入<code>@EnableCircuitBreaker</code>开启断路器功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>Spring Cloud提供了<code>@SpringCloudApplication</code>注解简化如上代码。该注解事实上已经包含了前面所述的三个注解。<code>@SpringCloudApplication</code>注解的定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringCloudApplication &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，需要引入一个新的服务类来封装hystrix提供的断路器保护功能，主要是定义当故障发生时需要执行的回调逻辑，即代码中指定的fallbackMethod：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;consumerFallback&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForEntity(<span class="string">&quot;http://demo-service/demo&quot;</span>, String.class).getBody(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">consumerFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ConsumerService consumerService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/demo-consumer&quot;, method = RequestMethod.Get)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> consumerService.consume(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务监控"><a href="#服务监控" class="headerlink" title="服务监控"></a>服务监控</h3><p>微服务架构将服务的粒度分解的足够细，这使得它在保证服务足够灵活、足够独立的优势下，也带来了管理和监控上的挑战，服务与服务之间的依赖也变得越来越复杂。因此，对服务健康度和运行指标的监控就变得非常重要。</p>
<p>Hystrix提供了Dashboard用以监控Hystrix的各项指标信息。为了监控整个系统的微服务，我们需要为Hystrix Dashboard建立一个Spring Boot微服务。在该服务项目的pom文件中，添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务的Application类需要添加<code>@EnableHystrixDashboard</code>，以启用Hystrix Dashboard功能。同时，可能需要根据实际情况修改application.properties配置文件，例如选择可用的端口号等。</p>
<p>如果要实现对集群的监控，则需要加入Turbine。</p>
<h3 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h3><p>理论上，客户端可以直接向每个微服务直接发送请求。但是这种方式是存在挑战和限制的，调用者需要知道所有端点的地址，分别对每一段信息执行http请求，然后将结果合并到客户端。</p>
<p>一般而言，针对微服务架构模式的系统，采用的都是<strong>前后端分离</strong>的架构。为了明显地隔离开前端与后端的边界，我们通常可以专门为前端的消费者定义更加粗粒度的Open Service。这些Open Service是对外的RESTful API服务，可以通过F5、Nginx等网络设备或工具软件实现对各个微服务的路由与负载均衡，并公开给外部的客户端调用（注意，内部微服务之间的调用并不需要通过Open Service）。这种对外公开的Open Service通常又被称为边缘服务（edge service）。</p>
<p>如果这些Open Service需要我们自己去开发实现并进行服务的运维，在系统规模不断增大的情况下，会变得越来越困难。例如，当增加了新的微服务又或者IP地址发生变动时，都需要运维人员手工维护这些路由规则与服务实例列表。又例如针对所有垂直分隔的微服务，不可避免存在重用的横切关注点，例如用户身份认证、授权或签名校验等机制。我们不能在所有微服务中都去添加这些相同的功能，因为这会造成横切关注点的冗余。</p>
<p>解决的办法是引入API网关（API Gateway）。它是系统的单个入口点，用于通过将请求路由到适当的后端服务或者通过调用多个后端服务并聚合结果来处理请求。此外，它还可以用于认证、insights、压力测试、金丝雀测试（canary testing）、服务迁移、静态响应处理和主动变换管理。Spring Cloud为API网关提供的解决方案就是Spring Cloud Zuul，它是对Netflix Zuul的包装。</p>
<h4 id="路由规则与服务实例维护"><a href="#路由规则与服务实例维护" class="headerlink" title="路由规则与服务实例维护"></a>路由规则与服务实例维护</h4><p>Zuul解决路由规则与服务实例维护的方法是通过Spring Cloud Eureka。API Gateway自身就是一个Spring Boot服务，该服务自身被注册为Eureka服务治理下的应用，同时它会从Eureka中获得所有其他微服务的实例信息。这样的设计符合DRY原则，因为Eureka已经维护了一套服务实例信息，Zuul直接重用了这些信息，无需人工介入。</p>
<p>对于路由规则，Zuul默认会将服务名作为ContextPath创建路由映射，基本上这种路由映射机制就可以满足微服务架构的路由需求。倘若需要一些特殊的配置，Zuul也允许我们自定义路由规则，可以通过在API网关的Application类中创建PatternServiceRouteMapper来定义自己的规则。</p>
<h4 id="横切关注点"><a href="#横切关注点" class="headerlink" title="横切关注点"></a>横切关注点</h4><p>诸如授权认证、签名校验等业务逻辑本身与微服务应用所要处理的业务逻辑没有直接关系，我们将这些可能横跨多个微服务的功能称为“横切关注点”。这些横切关注点往往会作为“装饰”功能在服务方法的前后被调用。Spring Cloud Zuul提供了一套<strong>过滤器机制</strong>，允许开发者创建各种过滤器，并指定哪些规则的请求需要执行哪个过滤器。</p>
<p>自定义的过滤器继承自ZuulFilter类。例如我们要求客户端发过来的请求在路由之前需要先验证请求中是否包含accessToken参数，如果有就进行路由，否则就拒绝，并返回401 Unauthorized错误，则可以定义AccessFilter类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(AccessFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = ctx.getRequest();</span><br><span class="line">        </span><br><span class="line">        log.info(<span class="string">&quot;send &#123;&#125; request to &#123;&#125;&quot;</span>, request.getMethod(), request.getRequestURL().toString());</span><br><span class="line"></span><br><span class="line">        Object accessToken = request.getParameter(<span class="string">&quot;accessToken&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (accessToken == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;access token is empty&quot;</span>);</span><br><span class="line">            ctx.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            ctx.setResponseStatusCode(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;access token ok&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要让该自定义过滤器生效，还需要在Zuul服务的Application中创建具体的Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicatonBuilder(ZuulApplication.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccessFilter <span class="title">accessFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AccessFilter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Zuul一共提供了四种过滤器：</p>
<ul>
<li>pre filter</li>
<li>routing filter</li>
<li>post filter</li>
<li>error filter</li>
</ul>
<p>下图来自官网，它展现了客户端请求到达Zuul API网关的生命周期与过滤过程：</p>
<img src="/micro-service-based-on-spring-cloud/ms-03.png" class="">

<p>通过starter添加Zuul的依赖时，自身包含了spring-cloud-starter-hystrix与spring-cloud-starter-ribbon模块的依赖，因此Zuul自身就拥有线程隔离与断路器的服务容错功能，以及客户端负载均衡。但是，倘若我们使用path与url的映射关系来配置路由规则，则路由转发的请求并不会采用HystrixCommand来包装，因而这类路由是没有服务容错与客户端负载均衡作用的。所以在使用Zuul时，应尽量使用path和serviceId的组合对路由进行配置。</p>
<h3 id="分布式配置中心"><a href="#分布式配置中心" class="headerlink" title="分布式配置中心"></a>分布式配置中心</h3><p>为什么要引入一个分布式配置中心？一个微服务就需要至少一个配置文件，怎么管理分散在各个微服务中的配置文件呢？如果微服务采用的是不同的技术栈，如何来统一微服务的配置呢？微服务是部署在不同的节点中，显然我们无法在单机中实现对分布式节点的配置管理。这就是引入Spring Cloud Config的目的。</p>
<p>Spring Cloud Config提供了服务端和客户端支持。服务端是一个独立的微服务，同样可以注册到Eureka服务器中。每个需要使用分布式配置中心的微服务都是Spring Cloud Config的客户端。Spring Cloud Config默认实现基于Git仓库，既可以进行版本管理，还可以通过本地Git库起到缓存作用。Spring Cloud Config不限于基于Spring Cloud开发的系统，而是可以用于任何语言开发的程序，并支持自定义实现。</p>
<h4 id="配置中心服务端"><a href="#配置中心服务端" class="headerlink" title="配置中心服务端"></a>配置中心服务端</h4><p>Spring Cloud Config Server作为配置中心服务端，提供如下功能：</p>
<ul>
<li>拉取配置时更新git仓库副本，保证是最新结果</li>
<li>支持数据结构丰富，yml, json, properties等</li>
<li>配合Eureke可实现服务发现，配合cloud bus可实现配置推送更新</li>
<li>配置存储基于git仓库，可进行版本管理</li>
<li>简单可靠，有丰富的配套方案</li>
</ul>
<p>建立一个Config服务，需要添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务的Application类需要添加<code>@EnableConfigServer</code>注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置服务的基本信息和Git仓库的信息放在application.yml文件中：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">            <span class="attr">uri:</span> <span class="string">http://localhost/workspace/springcloud-demo</span></span><br><span class="line">            <span class="attr">username:</span> <span class="string">user</span></span><br><span class="line">            <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$&#123;CONFIG_SERVICE_PASSWORD&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="Git库与配置服务"><a href="#Git库与配置服务" class="headerlink" title="Git库与配置服务"></a>Git库与配置服务</h4><p>在Config服务中配置了Git服务器以及Git库的信息后，我们就可以在git库中提交配置文件。存储在git库中配置文件的名字以及分支名（默认为master分支）会组成访问Config服务的URI。假设有一个服务为Notification服务，则它在配置中心服务端的配置文件为notification-dev.yml，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">devMode:</span>  <span class="literal">true</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">application:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">notification</span></span><br><span class="line">    <span class="attr">jdbc:</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">3306</span></span><br><span class="line">        <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">demo</span></span><br></pre></td></tr></table></figure>

<h4 id="配置中心客户端"><a href="#配置中心客户端" class="headerlink" title="配置中心客户端"></a>配置中心客户端</h4><p>需要读取配置中心服务端信息的微服务都是配置中心的客户端，为了能够读取配置服务端的信息，这些微服务需要：</p>
<ul>
<li>在pom中添加对spring-cloud-starter-config的依赖</li>
<li>在bootstrap.properties或者bootstrap.yml中配置获取配置的config-server位置</li>
</ul>
<p>例如，Account服务的配置是由Spring Cloud Config进行管理的。在它的资源目录下，提供了bootstrap.yml配置文件，内容如下所示：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">account-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://config:8888</span></span><br><span class="line">      <span class="attr">fail-fast:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">$&#123;CONFIG_SERVICE_PASSWORD&#125;</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">user</span></span><br></pre></td></tr></table></figure>

<p>注意，该配置文件除了配置了该Account服务应用的name之外，主要是支持该应用获得配置服务端的信息。微服务自身的配置信息则统一放到配置中心服务端的文件中，并由Git库进行管理。例如，Account服务的详细配置在配置中心服务端的account-dev.yml文件中：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">oauth2:</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">      <span class="attr">clientId:</span> <span class="string">account-service</span></span><br><span class="line">      <span class="attr">clientSecret:</span> <span class="string">$&#123;ACCOUNT_SERVICE_PASSWORD&#125;</span></span><br><span class="line">      <span class="attr">accessTokenUri:</span> <span class="string">http://auth-service:5000/uaa/oauth/token</span></span><br><span class="line">      <span class="attr">grant-type:</span> <span class="string">client_credentials</span></span><br><span class="line">      <span class="attr">scope:</span> <span class="string">server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">account-mongodb</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">user</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">$&#123;MONGODB_PASSWORD&#125;</span></span><br><span class="line">      <span class="attr">database:</span> <span class="string">piggymetrics</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">27017</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">context-path:</span> <span class="string">/accounts</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6000</span></span><br></pre></td></tr></table></figure>

<p>Spring Cloud Config通过Git实现分布式的配置管理。当配置中心服务端的配置信息发生变更时，各个作为配置客户端的微服务会向Git库提交pull更新，获得最新的配置信息。</p>
<p>当然，Spring Cloud Config还可以使用SVN库进行配置管理，也支持简单的本地文件系统的存储方式。此时需要将<code>spring.profiles.active</code>设置为native，并设置搜索配置文件的路径。如果不配置路径，默认在<code>src/main/resources</code>目录下搜索。如下配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">native:</span></span><br><span class="line">          <span class="attr">search-locations:</span> <span class="string">classpath:/shared</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">native</span></span><br></pre></td></tr></table></figure>

<p>搜索路径放在classpath下的shared目录下，那么在代码中，目录就是<code>resources/shared</code>。如果使用本地文件系统管理配置文件，则无法支持分布式配置管理以及版本管理，因此在生产系统下，还是推荐使用Git库的方式。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在实施微服务时，我们可以将微服务视为两个不同的边界。一个是与前端UI的通信，称为Open Service（Edge Service），通过引入API Gateway来实现与前端UI的通信。另一个是在边界内业务微服务之间的通信，通过Feign实现微服务之间的协作。所有的微服务都会通过Eureka来完成微服务的注册与发现。一个典型的基于Spring Cloud的微服务架构如下所示：</p>
<img src="/micro-service-based-on-spring-cloud/ms-04.jpg" class="">

<p>微服务的集成可以通过Feign+Ribbon以RESTful方式实现通信，也可以基于RPC方式（可以结合Protocol Buffer）完成服务之间的通信，甚至可以通过发布事件与订阅事件的机制。事件机制可以使微服务之间更加松散耦合。这时，我们可以引入RabbitMQ或Kafka来做到服务与服务之间的解耦。事件机制是异步和非阻塞的，在某些业务场景下，它的性能会更加的好。Spring Cloud也提供了相关的组件Spring Cloud Stream来支持这种事件机制。</p>
<p>对于微服务之间的协作，到底选择Feign这种REST方式、事件机制或者RPC方式，取决于业务场景是否需要同步方式，还是异步方式；是高性能高并发，还是普通方式；是要求彻底解耦，还是做到一般的松散耦合。我们需要针对实际情况作出实际的判断，作出正确的选择。没有谁坏谁好之分，而是看谁更加的适合。</p>
<p><strong>备注：</strong>本文部分内容来自<a href="https://github.com/sqshq/PiggyMetrics">PiggyMetrics</a>，并参考了微服务与Spring Cloud相关文档。</p>
]]></content>
      <categories>
        <category>Architecture</category>
      </categories>
      <tags>
        <tag>Architecture</tag>
        <tag>Micro Service</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>重构加重写保证版本功能的空中加油</title>
    <url>/rewrite-and-refactoring-policy/</url>
    <content><![CDATA[<img src="/rewrite-and-refactoring-policy/cover.jpg" class="">

<p>在一个产品长期的研发过程中，必须时刻对代码保持警惕，一旦发现代码有腐烂的迹象，就需要考虑及时重构，剔除代码的坏味道，让代码焕然一新。然而，在进度的逼迫下，我们承受了及时交付功能的压力，团队成员对糟糕代码的敏感度又不够高，在这二者的夹击之下，稍有疏忽，整个代码库就有可能变得积重难返。</p>
<p>多数时候，我们疲于应对各种需求。一方面，我们发布的版本正在支撑着客户的生产应用；另一方面，我们还需要不断地开发新功能，以满足客户不断提出的新需求或者需求变更。同时，我们对产品有着雄心勃勃的计划，希望它能够在不断的演化下变得更加强大。我们清醒地感知到，若任由代码如此发展下去，代码腐烂的结果会进而导致架构的腐烂。就像一架正在执行飞行任务的航空器，明知到缺少足够的燃料，需要返回基地加油，却又不得不继续飞行，否则无法按时到达目的地。这时，我们就需要针对代码库进行“空中加油”。</p>
<p>理想的方式是对现有的代码库进行小步重构，然而众多阻力让我们没有信心驾驭重构。这些阻力包括：</p>
<ul>
<li>随着功能的增加，代码库开始变得庞大</li>
<li>代码的腐烂情况较为严重，需要在结构上做重大调整</li>
<li>团队成员欠缺对大型代码库的重构能力</li>
<li>单元测试与集成测试的测试覆盖率太低</li>
<li>重构与新功能开发同时进行，破坏原有功能的风险太大</li>
</ul>
<p>显然，想要通过重构实现空中加油，谈何容易！但为了避免未来架构的腐化，对现有代码库进行手术又势在必行。因此，基于当前代码库现状、产品需求与团队成员能力，我确定了<strong>“重构+重写”的改造策略</strong>，美其名曰“空中加油”。</p>
<span id="more"></span>

<h3 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h3><p>要解决的代码问题很多，这里仅以其中一个关键部分作为示例。在我们的产品中，ElasticSearch作为存储主题区数据的数据库，但作为产品，我们还需要应对不同客户的需求，例如针对数据规模相对较小的客户，亦有可能使用关系型数据库，例如Oracle来存储主题区数据。因此在对主题区的数据进行建模时，我们并没有利用ElasticSearch的存储特性，形成主题区业务模型与数据模型的一一对应。主题区业务模型是一个树模型，但在持久化到数据库中时，却是将业务模型拍平，形成关系数据库的表结构。</p>
<p>在确定持久化架构时，一开始我就确定了两个职责的分离，并以gateway和repository作为承担不同职责的对象。gateway负责访问主题区数据库，完成对数据的CRUD操作，而repository则借鉴了DDD的资源库概念，体现的是业务角度的资源存取。</p>
<p>我犯下的一个错误是没有及时进行代码走查，在确定了此架构原则后，由于进度压力与开发能力的问题，团队成员在开发时并没有体会到这种职责分离的本质，不断地编写代码，而实现却与当初确定的原则渐行渐远。等到我发现时，问题已经变得较为严重了：</p>
<ul>
<li>部分Repository没有守住边界，为了满足自己的业务，越俎代庖做了gateway应该做的事情</li>
<li>repository没有按照业务去定义，出现了许多从命名上大同小异的repository，每个开发人员似乎只熟悉或相信自己定义的repository</li>
<li>有时候为了重用，建立了许多不必要的抽象，继承层次变得混乱</li>
</ul>
<p>而这一切在引入两层主题区（为了实现多数据源处理等功能，我们引入了前置主题区和细节主题区）之后，就变得更加严重了。两个不同的主题区数据结构几乎一致，但访问的ElasticSearch集群以及index和type却又不同。有的开发人员为了方便，例如他要开发的功能仅需要前置主题区，就定义了一个前置主题区专用的repository，从而引入各种混淆的repository。随着需求的演化，最早定义在<code>ElasticSearchGateway</code>中的基本方法已经不能满足需求，于是又不断增加。但这些方法的操作目标大同小异，就出现了许多混淆不清的方法定义，例如查询单条数据、查询多条数据、按照条件查询、查询时执行聚合与排序以及按照范围进行查询，使得gateway的接口方法变得越来越乱，并被各个repository依赖。</p>
<h3 id="需求与版本演化"><a href="#需求与版本演化" class="headerlink" title="需求与版本演化"></a>需求与版本演化</h3><p>在2018年12月底，经过不断的测试和bug修复，我们按照客户的进度要求交付了一个相对完整的版本，满足了客户的需求，并已部署到生产环境中投入使用。在投入使用之后，客户的需求又源源不断继续涌来，使得我们发布的版本始终不能保证稳定。按照产品的规划，我们还需要实现一些重要的功能特性，并可能在未来支持更多的客户。不同客户的数据协议、数据源支撑都不相同，这意味着许多相同的功能需要为不同的客户提供各自专有的实现。</p>
<p>然而，代码的重构又变得刻不容缓。一方面我们要开发新功能，另一方面又需要对原有代码进行重构，而这些变更的发布又需要按照计划部署到生产环境。如前所述，由于众多阻力，重构的风险太大。该怎么办？我们当然可以创建版本分支，例如为当前运行的版本建立一个release分支，然后在master上进行重构和新功能开发。问题在于，重构与新功能发布的频率并不一致，后者甚至可能要求每周发布。如果新功能开发和重构都工作在master上，在发布新功能到生产环境时，我们担心重构会引入未知的bug，破坏已经交付的稳定功能。如果新功能在分支的release版本下开发，又因为重构的影响巨大，导致代码无法及时合并，或者修复代码冲突的代价太大。</p>
<h3 id="重构加重写的策略"><a href="#重构加重写的策略" class="headerlink" title="重构加重写的策略"></a>重构加重写的策略</h3><p>为了解决这一问题，我们决定仍然将master同时作为开发与重构的版本分支，之前的release版本则作为特殊情况下的后备版本。针对代码的改造，我们则采用重构+重写的策略。</p>
<p>当我们要重构一个类时，尤其是要重构该类的方法时，往往需要事先确定待重构的方法究竟有多少调用依赖。一旦该方法被多个类调用时，重构接口就成了一件非常棘手的工作。即使保留接口不变，仅仅是重构方法内部的实现，也需要慎之又慎，毕竟不同的调用者可能对这个方法实现会有不同的需求，如果代码编写不够清晰，极有可能在重构时不小心破坏功能，引入Bug。</p>
<p>这种判断依赖的方式是由内自外的方式，而我们的策略则反其道而行之，先“守”住外部的调用点不变，然后以重写的方式去替换这个调用。在重写的时候，我们会站在调用者的角度，逐步地完成重写，以求小步地完成替换。每替换一小块功能，都编写测试去覆盖所有分支，同时采用手动测试的方式，在类生产环境下运行，以确保这次小范围的替换没有引入问题。</p>
<p>整个重构加重写的过程如下所示：</p>
<ol>
<li>从外部调用者发现它依赖的类</li>
<li>创建新的类，然后仅将当前外部调用者需要调用的方法原封不动地搬移到新类中</li>
<li>在调用者内部的调用点，将旧类替换为新类，并保证功能正确</li>
<li>编写对应的测试覆盖该功能，然后对新类进行重构，运行测试保证重构没有引入错误</li>
<li>若新类的内部亦依赖了有待重构的旧有实现，则将新类视为当前的外部调用者，重复第1步</li>
<li>以此类推，直到旧有的类没有别的依赖，则安全删除旧有类</li>
</ol>
<h3 id="案例：重构AircraftRepository和ElasticSearchGateway"><a href="#案例：重构AircraftRepository和ElasticSearchGateway" class="headerlink" title="案例：重构AircraftRepository和ElasticSearchGateway"></a>案例：重构AircraftRepository和ElasticSearchGateway</h3><p>以我们现在的项目为例。ElasticSearchGateway本是需要重构的目标，但它的依赖非常多，如下图所示，一共有50处依赖：</p>
<img src="/rewrite-and-refactoring-policy/01.jpg" class="">

<p>它的其中一个方法<code>queryByCondition()</code>有32处依赖，如下图所示：</p>
<img src="/rewrite-and-refactoring-policy/02.jpg" class="">

<p>该方法是我们需要修改的目标。现在，我们反其道而行之，在外部定位一个面向某个业务发起调用的类，如针对航空器位置业务的一个类<code>AircraftProcessor</code>，它的调用关系如下所示：</p>
<img src="/rewrite-and-refactoring-policy/03.png" class="">

<p>图中标记为灰色的类，就是我本希望重构的类，然而根据前面的分析，它们都有多处调用者，要进行重构，就可能牵一发动全身，要做到改变现有代码的结构而不破坏其功能，就好比做一台精密的脑颅手术一般，难度非常大。为此，我们选择的做法是定义一个新的<code>AircraftRepository</code>类，并站在调用者<code>AircraftLocationPreFilter</code>的角度，将它需要的方法原封不动地拷贝到新类中，并在调用者内部以新类替换对旧类的调用。如果已有自动化测试覆盖这一路径，则运行测试，看这一替换是否影响了原有的功能实现。如果没有自动化测试，则需要编写新的测试去覆盖它。可以考虑编写单元测试和集成测试。</p>
<p>针对新类中的实现，可以在不改变其功能实现的前提下，对其进行重构。这个重构包括调整原有的方法接口，也包括对内部实现进行代码质量改进。由于新类只有这一个依赖点，重构产生的影响就会被限制到一个很小的范围。</p>
<p>例如调用者<code>AircraftLocationPreFilter</code>调用了<code>queryDistinctOrgStationBy()</code>方法，它的定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;FlightPath.Track&gt; queryDistinctOrgStationBy(String craftNo, String scopeField, String gt, String lt, String aggField, String sortField) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><code>AircraftLocationPreFilter</code>对该方法的调用如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;FlightPath.Track&gt; getPeriodTimeTracks(String craftNo, Date startTime, Date endTime) &#123;</span><br><span class="line">    <span class="keyword">return</span> aircraftRepository.queryDistinctOrgStationBy(</span><br><span class="line">            craftNo, UPDATE_TIME_FIELD,</span><br><span class="line">            DateUtil.transformTime(startTime, DateUtil.YYYY_MM_DD_T_HH_MM_SS),</span><br><span class="line">            DateUtil.transformTime(endTime, DateUtil.YYYY_MM_DD_T_HH_MM_SS),</span><br><span class="line">            ORG_STATION_AGG_FIELD, ORIGINAL_TIMESTAMP_SORT_FIELD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的定义存在问题。一方面它的方法名未能清晰表达查询航空器路径的意图，另一方面，方法签名暴露了太多不必要的字段，例如方法的第2、5、6三个参数就应该封装到<code>AircraftRepository</code>中，而对第3、4两个参数的转换逻辑也不应该暴露出来。现在可以对新<code>AircraftRepository</code>的方法自由地进行重构，例如通过“修改方法签名”的重构手法，将方法签名修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;FlightPath.Track&gt; queryTracksBy(String craftNo, Date startTime, Date endTime) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>方法签名的修改会直接影响对该方法的调用，调用代码修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;FlightPath.Track&gt; getPeriodTimeTracks(String craftNo, Date startTime, Date endTime) &#123;</span><br><span class="line">    <span class="keyword">return</span> aircraftRepository.queryTracksBy(craftNo, startTime, endTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，针对<code>AircraftProcessor</code>与<code>AircraftLocationPreFilter</code>进行自动化与手动测试，保证修改的代码分支没有受到任何影响。</p>
<p>重写、替换、然后重构，这就是主要的三个步骤，如下图所示：</p>
<img src="/rewrite-and-refactoring-policy/04.png" class="">

<p>黄色的<code>AircraftRepository</code>是新建的类，它的代码仅为调用者<code>AircraftLocationPreFilter</code>提供服务，因此重构它的代码并没有太大压力。<strong>注意</strong>，这里的一个要点是<strong>仅拷贝<code>AircraftLocationPreFilter</code>需要调用的旧AircraftRepository方法，而非原封不动地将整个旧<code>AircraftRepository</code>拷贝到新类中</strong>，因此新类的代码数量以及依赖点都非常的少。我们能够清晰地知道这个改动影响到了哪些代码分支，就通过测试去保护这些分支，使得这一步骤是充满信心的，保证不会引入新的Bug。一旦确认了新类的方法没有任何问题，就可以找到原方法的其他依赖者，采用同样的方式进行替换。在此过程中，旧<code>AircraftRepository</code>不受任何影响，仍然保留着原貌。除非随着替换过程的推进，这个旧类的所有调用者都转向了新类，它才正式退出历史舞台。</p>
<p>新<code>AircraftRepository</code>类的方法与实现虽然进行了重构，但它对<code>ElasticSearchGateway</code>的依赖仍然未变。现在可以如法炮制，针对<code>AircraftRepository</code>对<code>ElasticSearchGateway</code>的调用，做相似的重构加重写，如下图所示：</p>
<img src="/rewrite-and-refactoring-policy/05.png" class="">

<p><code>AircraftRepository</code>仅用到了旧<code>ElasticSearchGateway</code>的一个<code>queryByScopeAndTerm()方法</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AircraftRepository</span>...</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">List</span>&lt;<span class="title">AircraftLocation</span>&gt; <span class="title">queryLocations</span>(<span class="title">String</span> <span class="title">craftNo</span>, <span class="title">String</span> <span class="title">scopeField</span>, <span class="title">String</span> <span class="title">min</span>, <span class="title">String</span> <span class="title">max</span>)...</span></span><br><span class="line"><span class="class">    <span class="title">List</span>&lt;<span class="title">SearchConsequence</span>&gt; <span class="title">consequences</span> </span>= gateway</span><br><span class="line">                .queryByScopeAndTerm(condition, ORG_STATION_AGG_FIELD, ORIGINAL_TIMESTAMP_SORT_FIELD, scopeField, min, max, AIRCRAFT_LOCATION_TABLE);</span><br></pre></td></tr></table></figure>

<p>为之创建的新<code>ElasticSearchGateway</code>也就只包含<code>queryByScopeAndTerm</code>方法。当新<code>ElasticSearchGateway</code>替换了旧类后，重复之前的步骤，再次针对<code>AircraftProcessor</code>与<code>AircraftLocationPreFilter</code>进行自动化与手动测试，保证修改的代码分支没有受到任何影响。同理，新类的代码数量和依赖点都非常少，再对新类进行重构就变得更加简单。我们认为旧类的<code>queryByScopeAndTerm()</code>方法既无法清晰地表达意图，也不利于应对各种查询产生的变化。这时，我们引入了Builder模式，修改原有接口为DSL风格的接口。在新的<code>AircraftRepository</code>类中，保持了原来的调用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;AircraftLocation&gt; <span class="title">queryLocations</span><span class="params">(String craftNo, String scopeField, String min, String max)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; condition = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    condition.put(CRAFT_NO_FIELD, craftNo);</span><br><span class="line">    QueryResult queryResult = gateway.queryByScopeAndTerm(condition, ORG_STATION_AGG_FIELD, ORIGINAL_TIMESTAMP_SORT_FIELD, scopeField, min, max, AIRCRAFT_LOCATION_TABLE);</span><br><span class="line">    <span class="keyword">return</span> queryResult.all(AircraftLocation.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构了新<code>ElasticSearchGateway</code>的<code>queryByScopeAndTerm()</code>方法之后，调用代码变成了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;AircraftLocation&gt; <span class="title">queryLocations</span><span class="params">(String craftNo, String scopeField, String min, String max)</span> </span>&#123;</span><br><span class="line">    QueryResult queryResult = gateway.query()</span><br><span class="line">            .from(AIRCRAFT_LOCATION_TABLE)</span><br><span class="line">            .and(CRAFT_NO_FIELD, craftNo)</span><br><span class="line">            .range(scopeField, min, max)</span><br><span class="line">            .aggregateBy(ORG_STATION_AGG_FIELD)</span><br><span class="line">            .orderBy(ORIGINAL_TIMESTAMP_SORT_FIELD)</span><br><span class="line">            .run();</span><br><span class="line">    <span class="keyword">return</span> queryResult.all(AircraftLocation.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这样的重构加重写方式，我们新引入的类既在设计上通过重构得到了改进，还能借助这种小步前行的逐步替换方式，确保新实现在业务场景中得到了验证，规避了引入新bug的风险。一旦新接口得到了质量保证，就可以逐渐地替换旧有实现，直到旧有的repository与gateway类不再有任何依赖时，就可以将它们删除，换来更加整洁的代码了。</p>
<h3 id="抽象分支"><a href="#抽象分支" class="headerlink" title="抽象分支"></a>抽象分支</h3><p>事实上，这种重构加重写方式与“<a href="https://martinfowler.com/bliki/BranchByAbstraction.html">抽象分支（Branch By Abstraction）</a>”实践不谋而合。在Martin Fowler讨论抽象分支的文章中，他详细地讲述了这个过程。他将我们要替换的类或者模块称之为Flawed Supplier，抽象分支的做法是先为Flawed Supplier建立一层抽象层，并将客户端的调用代码指向该抽象层，同时为其创建单元测试：</p>
<img src="/rewrite-and-refactoring-policy/06.png" class="">

<p>接下来提供一个新的supplier，它同样实现了这个抽象层。一旦这个新的supplier实现完毕，就可以逐步修改客户端代码，转而使用这个新的supplier。最后，在验证了功能没有问题，也没有任何客户端代码还需要旧有supplier后，就可以去掉它：</p>
<img src="/rewrite-and-refactoring-policy/07.png" class="">

<p>重构加重写策略中新增的类就是这个新Supplier。但我并没有引入一个额外的抽象层，也未创建一个全新的Supplier，而是采用拷贝的方式直接重用代码，以避免引入不必要的bug。可以认为新增的类其实是要替换类的子集，保留了相同的接口和实现，从而避免多余的实现与依赖，使得重构可以更好地进行。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>重构加重写的策略虽然慢，但每一步前进的步伐都非常稳健，充分利用了代码量与依赖点少的新类来降低重构的难度。每完成一个新类的重构，我们都需要测试去验证。如果之前没有测试保障，则要求为新实现编写测试去覆盖，相当于在这个修改过程中慢慢地偿还了过去欠下的技术债务。由于旧类没有受到任何影响，即使重构或重写失败，我们还能够安全地返航。</p>
<p>在这个过程中，会有很长一段时间存在<strong>新旧共存</strong>的状态。在执行重构的过程中，如果别的团队成员正在开发的新功能需要调用被重构的接口，由于重构还没有完成或未通过全面的测试，则允许该新功能继续调用旧有的类，保证了新功能的开发不受影响。倘若替换已经完成，旧类不再有存在价值时，则需要及时果断地将其删除，新开发的功能也要立即转为对新类的调用。由于新类的功能已经得到了保证，不必担心调用它会引入错误。</p>
<p>执行重构加重写的过程需要小步前行，并及时提交新增或重构的代码，同时提高自动化测试的覆盖率。所有工作都在一个版本上进行，并保证重构加重写的功能都是正确可用的，保证该工作版本随时处于可上线的状态。</p>
<p>在进行重构加重写时，还允许灵活调整人力资源。倘若需求变更或新需求开发的优先级高，交付压力大，就可以只安排少数人员专注于重构加重写，其他人员全力以赴新功能的开发，甚至在压力太大的情况下，停止进行重构加重写。反之，若开发压力较小，又可以匀出更多的人来进行重构加重写，尽快还清技术债。显然，这种策略使得我们进可攻退可守，理想状态下，甚至能够在一直保证不败的前提下，拥有随时发起进攻的选择权。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Refactoring</tag>
        <tag>Clean Code</tag>
        <tag>Legacy</tag>
      </tags>
  </entry>
  <entry>
    <title>自治对象才是好对象</title>
    <url>/self-governance-of-oo/</url>
    <content><![CDATA[<img src="/self-governance-of-oo/2019-5-7.jpeg" class="">

<p>当我们将对象的行为看作职责时，就赋予了对象的生命与意识，使得我们能够以拟人的方式对待对象。一个聪明的对象是对象<strong>自己</strong>知道应该履行哪些职责，拒绝履行哪些职责，以及该如何与其他对象协作共同履行职责。这时的对象绝不是一个愚笨的数据提供者，它学会了如何根据自己拥有的数据来判断请求的响应方式、行为的执行方式，这就是所谓的对象的“<strong>自治</strong>”。</p>
<span id="more"></span>

<p>我在《领域驱动战略设计实践》中提及了限界上下文的自治特性，事实上，从更小的粒度来看，对象仍然需要具备自治的这四个特性，即：</p>
<ul>
<li>最小完备</li>
<li>自我履行</li>
<li>稳定空间</li>
<li>独立进化</li>
</ul>
<h3 id="最小完备"><a href="#最小完备" class="headerlink" title="最小完备"></a>最小完备</h3><p>如何来理解对象的“最小完备”？John Kern谈到对象的设计时，提到：“不要试着把对象在现实世界中可以想象得到的行为都实现到设计中去。相反，只需要让对象能够合适于应用系统即可。对象能做的、所知的最好是一点不多一点不少。”因此，对象的最小完备取决于该对象具备的知识，恰如其分地履行职责。不放弃该自己履行的职责，也不越权对别人的行为指手画脚。</p>
<p>例如，我们需要设计一个Web服务器，它提供了一个对象<code>HttpProcessor</code>，能够接收由<code>HttpConnector</code>发送来的Socket请求，并在处理请求后返回响应消息。请求和响应被定义为<code>HttpRequest</code>和<code>HttpResponse</code>类。请求的处理过程中需要对Socket消息进行解析，这个解析职责应该分配给哪个对象呢？</p>
<p>如果我们将解析职责完全交给<code>HttpProcessor</code>来完成，那么<code>HttpRequest</code>和<code>HttpResponse</code>将沦为两个仅提供数据的“哑对象”，这就违背了自治原则，没有满足对象职责的完备性。如果我们将对请求和响应的解析工作完全放到各自的<code>HttpRequest</code>与<code>HttpResponse</code>对象中，似乎又超出了这两个对象的能力范围。仔细分析解析过程，解析Socket消息获得请求头和请求体，实际上等同于是创建<code>HttpRequest</code>对象，这个职责显然不应该交给<code>HttpRequest</code>。然而，在解析请求时，还涉及一些系统开销大的字符串操作或其他操作，这些请求参数并不是Servlet所必须要的。也就是说，服务端的<code>HttpProcessor</code>在接收到请求后，并没有必要处理全部的请求参数，因为它的职责是快速响应请求，不应该将时间浪费在大量目前并不需要的请求消息上。这时，就可以将这些不曾解析的消息直接赋给<code>HttpRequest</code>与<code>HttpResponse</code>。由于二者都拥有了这些信息，就可以提供解析它们的职责：</p>
<img src="/self-governance-of-oo/oo-auto01.png" class="">

<p>遵循最小完备原则，使得<code>HttpProcessor</code>、<code>HttpRequest</code>与<code>HttpResponse</code>三者之间的权责变得更加清晰。此外，这一设计方式还有利于改善性能。由于解析开销较大的字符串操作并未由<code>HttpProcessor</code>承担，而是将这些数据流塞给了<code>HttpRequest</code>与<code>HttpResponse</code>，使得<code>HttpProcessor</code>的process()操作可以快速完成。当请求者真正需要相关请求信息时，就可以调用<code>HttpRequest</code>与<code>HttpResponse</code>对象的<code>parse()</code>方法。</p>
<h3 id="自我履行"><a href="#自我履行" class="headerlink" title="自我履行"></a>自我履行</h3><p>所谓“自我履行”就是对象利用自己的属性完成自己的任务，不需要假手他人。这也是“信息专家模式”的体现，即信息的持有者即为操作该信息的专家。只有专业的事情交给专业的对象去做，对象的世界才能做到各司其职、各尽其责。Martin Fowler提到的“特性依恋（Feature Envy）”坏味道就违背了对象的自我履行原则，只是二者的立场不同。特性依恋是指在一个对象的行为中，总是使用别的对象的数据和特性，就好像是羡慕别人拥有的好东西似的。自我履行指的是我守住自己的一亩三分地，该自己操作的数据绝不轻易交给别人。</p>
<p>例如在一个报表系统中，需要根据客户的Web请求参数作为条件动态生成报表。这些请求参数根据其数据结构的不同划分为三种：</p>
<ul>
<li>单一参数（SimpleParameter）：代表key和value的一对一关系</li>
<li>元素项参数（ItemParameter）：一个参数包含多个元素项，每个元素项又包含key和value的一对一关系</li>
<li>表参数（TableParameter）：参数的结构形成一张表，包含行头、列头和数据单元格</li>
</ul>
<p>这些参数都实现了<code>Parameter</code>接口，该接口的定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Parameter</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleParameter</span> <span class="keyword">implements</span> <span class="title">Parameter</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemParameter</span> <span class="keyword">implements</span> <span class="title">Parameter</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableParameter</span> <span class="keyword">implements</span> <span class="title">Parameter</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在报表的元数据中已经配置了各种参数，包括它们的类型信息。服务端在接收到Web请求时，通过<code>ParameterGraph</code>加载配置文件，并利用反射创建各自的参数对象。此时，<code>ParameterGraph</code>拥有的参数都没有值，需要通过<code>ParameterController</code>从<code>ServletHttpRequest</code>获得参数值对各个参数进行填充。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillParameters</span><span class="params">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (para <span class="keyword">instanceof</span> SimpleParameter) &#123;</span><br><span class="line">                SimpleParameter simplePara = (SimpleParameter) para;</span><br><span class="line">                String[] values = request.getParameterValues(simplePara.getName());</span><br><span class="line">                simplePara.setValue(values);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (para <span class="keyword">instanceof</span> ItemParameter) &#123;</span><br><span class="line">                    ItemParameter itemPara = (ItemParameter) para;</span><br><span class="line">                    <span class="keyword">for</span> (Item item : itemPara.getItems()) &#123;</span><br><span class="line">                        String[] values = request.getParameterValues(item.getName());</span><br><span class="line">                        item.setValues(values);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    TableParameter tablePara = (TableParameter) para;</span><br><span class="line">                    String[] rows =</span><br><span class="line">                            request.getParameterValues(tablePara.getRowName());</span><br><span class="line">                    String[] columns =</span><br><span class="line">                            request.getParameterValues(tablePara.getColumnName());</span><br><span class="line">                    String[] dataCells =</span><br><span class="line">                            request.getParameterValues(tablePara.getDataCellName());</span><br><span class="line">                    <span class="keyword">int</span> columnSize = columns.length;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows.length; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns.length; j++) &#123;</span><br><span class="line">                            TableParameterElement element = <span class="keyword">new</span> TableParameterElement();</span><br><span class="line">                            element.setRow(rows[i]);</span><br><span class="line">                            element.setColumn(columns[j]);</span><br><span class="line">                            element.setDataCell(dataCells[columnSize * i + j]);</span><br><span class="line">                            tablePara.addElement(element);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，这三种参数对象没有能够做到自我履行，它们把自己的数据“屈辱”地交给了<code>ParameterController</code>，却没有想到其实自己才是拥有填充请求数据能力的对象，毕竟只有它们才最清楚各自参数的数据结构。如果让这些参数对象都变为能够自我履行的自治对象，Do it myself，情况就完全不同了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleParameter</span> <span class="keyword">implements</span> <span class="title">Parameter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(ServletHttpRequest request)</span> </span>&#123;</span><br><span class="line">        String[] values = request.getParameterValues(<span class="keyword">this</span>.getName());</span><br><span class="line">        <span class="keyword">this</span>.setValue(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemParameter</span> <span class="keyword">implements</span> <span class="title">Parameter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(ServletHttpRequest request)</span> </span>&#123;</span><br><span class="line">        ItemParameter itemPara = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (Item item : itemPara.getItems()) &#123;</span><br><span class="line">            String[] values = request.getParameterValues(item.getName());</span><br><span class="line">            item.setValues(values);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TableParameter的实现略去</span></span><br></pre></td></tr></table></figure>

<p>当参数自身履行了填充参数的职责时，<code>ParameterController</code>履行的职责就变得简单了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillParameters</span><span class="params">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (para <span class="keyword">instanceof</span> SimpleParameter) &#123;</span><br><span class="line">                ((SimpleParameter) para).fill(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (para <span class="keyword">instanceof</span> ItemParameter) &#123;</span><br><span class="line">                    ((ItemParameter) para).fill(request);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ((TableParameter) para).fill(request);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，我们发现各种参数由于数据结构结构的不同，导致填充行为的差异，但从抽象层面看，都是将一个<code>ServletHttpRequest</code>填充到<code>Parameter</code>中。如果将<code>fill()</code>方法提升到<code>Parameter</code>接口中，哪里还需要分支语句进行类型判断与类型转换呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillParameters</span><span class="params">(ServletHttpRequest request, ParameterGraph parameterGraph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Parameter para : parameterGraph.getParmaeters()) &#123;</span><br><span class="line">            para.fill(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个对象能够自我履行时，就可以让调用者仅仅需要关注对象能够做什么（what to do），而不需要操心其实现细节（how to do），从而将实现细节隐藏起来。当我们让各种参数对象都履行填充职责时，<code>ParameterController</code>就可以只关注抽象的Parameter提供的公开接口，而无需考虑实现，对象之间的协作就变得更加松散耦合，对象的<strong>多态</strong>能力才能得到充分地体现。</p>
<h3 id="稳定空间"><a href="#稳定空间" class="headerlink" title="稳定空间"></a>稳定空间</h3><p>一个自治的对象具有<strong>稳定空间</strong>，使其具备抵抗外部变化的能力。要做到这一点，就需要处理好外部对象与自治对象之间的依赖关系。方法就是遵循“高内聚松耦合”原则来划分对象的边界。这就好比两个行政区，各自拥有一个居民区和一家公司。居民区A的一部分人要跨行政区到公司B上班，同理，居民区B的一部分人也要跨行政区到公司A上班：</p>
<img src="/self-governance-of-oo/oo-auto02.png" class="">

<p>这样的两个行政区是紧耦合的，因为居民区与公司之间的关系没有做到高内聚，只是一种松散随意的划分。现在我们按照居民区与公司之间的关系，对居民区的人重新调整，就得到了两个完全隔离的行政区：</p>
<img src="/self-governance-of-oo/oo-auto03.png" class="">

<p>在这个例子中，调整后的系统并没有改变任何本质性的事情。所有的人都还在原来的公司上班，没有人失业；没有人流离失所，只是改变了居住地。但仅仅由于居民居住区域的改变，两个行政区的依赖关系就大为减弱。事实上，对于这个理想模型，两个行政区之间已经没有任何关系，它们之间桥梁完全可以拆除。这就是“高内聚松耦合”原则的体现，通过将关联程度更高的元素控制在一个单位内部，就可以达到降低单位间关联的目的。</p>
<p>要实现自治对象的稳定空间，还需要识别变化点，对变化的职责进行分离和封装。实际上，许多设计模式都可以说是“分离和封装变化”原则的体现。例如，当我们发现一个对象包含的职责既有不变的部分，又有可变的部分，只是就可以将可变的部分分离出去，将其抽象为一个接口，再以委派的形式传入到原对象，如下图所示：</p>
<img src="/self-governance-of-oo/oo-auto04.png" class="">

<p>此时抽象出来的接口<code>IChangable</code>其实就是策略模式（Strategy Pattern）或者命令模式（Command Pattern）的体现。例如Java线程的实现机制是不变的，但运行在线程中的业务却随时可变，将这部分可变的业务部分分离出来，并抽象为<code>Runnable</code>接口，再以构造函数参数的方式传入到<code>Thread</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> ... </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">        init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模板方法模式（Template Method Pattern）同样分离了不变与变，只是分离变化的方向是向上提取为抽象类的抽象方法而已：</p>
<img src="/self-governance-of-oo/oo-auto05.png" class="">

<p>例如授权认证功能的主体是对认证信息token进行处理完成认证。如果通过认证，则返回认证结果，认证无法通过，就会抛出<code>AuthenticationException</code>异常。整个认证功能的执行步骤是不变的，但对token的处理需要根据认证机制的不同提供不同实现，甚至允许用户自定义认证机制，就需要对这部分可变的内容进行抽象。<code>AbstractAuthenticationManager</code>是一个抽象类，定义了<code>authenticate()</code>模板方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAuthenticationManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authRequest)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Authentication authResult = doAuthentication(authRequest);</span><br><span class="line">            copyDetails(authRequest, authResult);</span><br><span class="line">            <span class="keyword">return</span> authResult;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            e.setAuthentication(authRequest);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">copyDetails</span><span class="params">(Authentication source, Authentication dest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((dest <span class="keyword">instanceof</span> AbstractAuthenticationToken) &amp;&amp; (dest.getDetails() == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            AbstractAuthenticationToken token = (AbstractAuthenticationToken) dest;</span><br><span class="line">            token.setDetails(source.getDetails());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Authentication <span class="title">doAuthentication</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该模板方法调用的<code>doAuthentication()</code>是一个受保护的抽象方法，没有任何实现。这就是可变的部分，交由子类完成实现。例如<code>ProviderManager</code>子类就实现了<code>doAuthentication()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderManager</span> <span class="keyword">extends</span> <span class="title">AbstractAuthenticationManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">doAuthentication</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        Class toTest = authentication.getClass();</span><br><span class="line">        AuthenticationException lastException = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (AuthenticationProvider provider : providers) &#123;             </span><br><span class="line">            <span class="keyword">if</span> (provider.supports(toTest)) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Authentication attempt using &quot;</span> + provider.getClass().getName());</span><br><span class="line">                Authentication result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = provider.authenticate(authentication);</span><br><span class="line">                    sessionController.checkAuthenticationAllowed(result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (AuthenticationException ae) &#123;</span><br><span class="line">                    lastException = ae;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sessionController.registerSuccessfulAuthentication(result);</span><br><span class="line">                    applicationEventPublisher.publishEvent(<span class="keyword">new</span> AuthenticationSuccessEvent(result));</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">throw</span> lastException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个对象存在两个可能变化的职责，则违背了“单一职责原则”，即“引起变化的原因只能有一个”。分离这两个可变的职责，且分别进行抽象，然后再形成这两个抽象职责的组合，就是桥接模式（Bridge Pattern）的体现：</p>
<img src="/self-governance-of-oo/oo-auto06.png" class="">

<p>例如在实现数据权限控制时，需要根据解析配置内容获得数据权限规则，然后再根据解析后的规则对数据进行过滤。需要支持多种解析规则，同时也需要支持多种过滤规则，这时就不能将这两个可变的职责放到同一个类或者接口中，如下定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataRuleParser</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;DataRule&gt; <span class="title">parseRules</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T List&lt;T&gt; <span class="title">filterData</span><span class="params">(List&lt;T&gt; srcData)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分离规则解析与数据过滤职责，定义到两个独立的接口中。在数据权限控制功能中，过滤数据才是实现数据权限的目标，因此应以数据过滤职责为主，在实现类中，将规则解析器作为参数传入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataFilter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">filterData</span><span class="params">(List&lt;T&gt; srcData)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataRuleParser</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;DataRule&gt; <span class="title">parseRules</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GradeDataFilter</span>&lt;<span class="title">Grade</span>&gt; <span class="keyword">implements</span> <span class="title">DataFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataRuleParser ruleParser;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GradeDataFilter</span><span class="params">(DataRuleParser ruleParser)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ruleParser = ruleParser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Grade&gt; <span class="title">filterData</span><span class="params">(List&lt;Grade&gt; sourceData)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (sourcData == <span class="keyword">null</span> || sourceData.isEmpty() &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Grade&gt; gradeResult = <span class="keyword">new</span> ArrayList&lt;&gt;(sourceData.size());</span><br><span class="line">        <span class="keyword">for</span> (Grade grade : sourceData) &#123;</span><br><span class="line">            <span class="keyword">for</span> (DataRule rule : ruleParser.parseRules()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rule.matches(grade) &#123;</span><br><span class="line">                    gradeResult.add(grade);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> gradeResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GradeDataFilter</code>是过滤规则的一种，至于在过滤数据时，究竟选择什么解析模式，则取决于通过构造函数参数传入的<code>DataRuleParser</code>接口的具体实现类型。无论解析规则怎么变，只要不修改接口定义，就不会影响到<code>GradeDataFilter</code>的实现。</p>
<h3 id="独立进化"><a href="#独立进化" class="headerlink" title="独立进化"></a>独立进化</h3><p>稳定空间针对的是外部变化对自治对象产生的影响，<strong>独立进化</strong>关注的则是自治对象自身变化对外部产生的影响。二者是开放封闭原则（Open-closed Principle）的两面：若能对扩展开放，当变化发生时，自治对象就不会受到变化的影响，因为可以通过抽象进行扩展或替换；若能做到对修改封闭，只要对外公开的接口没有变化，封装在内部的实现怎么变化，都不会影响到它的调用者。这就将一个自治对象分为了内外两个世界，合理的封装是包裹在自治对象上的一层保护膜，对外公开的接口是自治对象与外部世界协作的唯一通道。注意，这里的“接口”并非语法意义上的interface，而是指代一种“交互”，可以是类型或方法的定义，即一切暴露在外面的信息，如下图所示：</p>
<img src="/self-governance-of-oo/oo-auto07.png" class="">

<p>要做到独立进化，就是要保证自治对象的接口不变，这样才不会影响外部的调用者；做好了这一层保护，位于内核部分的内部信息就可以随意调整了。</p>
<p>要如何才能做到对内核的保护呢？其一是<strong>保证接口的稳定性</strong>，即避免对公开方法的参数和返回值的修改。例如我们定义一个连接FTP服务器的接口。倘若采用如下形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FtpConnector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(String ftpHost, <span class="keyword">int</span> port, String userName, String password)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>倘若在未来，连接功能需要增加一个新属性：服务器主路径homePath，则<code>connect()</code>方法就需要修改，或者新增加一个重载的方法。为了保证接口的稳定性，应尽量将一组内聚的参数封装为对象，只要对象类型没有变化，即使增加了新的属性和行为，也不会影响到已有的消费者。例如通过引入<code>FtpServer</code>类对ftp地址、端口、用户名和密码这几个内聚的概念进行了封装，则接口就可以定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FtpServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stirng host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FtpConnector</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(FtpServer ftpServer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果修改了<code>FtpServer</code>的定义，增加了一个新的属性，<code>connect(ftpServer)</code>接口的定义并不需要做任何调整。</p>
<p><strong>数据结构和数据类型也需要进行合理的封装。</strong>这里要认识到在重复性上调用与实现的区别。遵循DRY（Don’t Repeat Yourself）原则，任何功能的实现应该只有一份，但对该功能的调用却会出现多份。这也正是在定义一个类时，为何需要为字段提供访问方法的原因。如果公有类暴露了它的数据字段，要想在将来改变字段的访问方式就非常困难，因为该字段的调用方法已经遍布各处，修改成本非常大。</p>
<p>工厂方法实则也体现了这一区别，即创建的实现逻辑只有一份，但创建对象的调用代码却可能分布在多处。假设没有工厂方法对创建逻辑进行封装，若创建对象的逻辑非常复杂，就会导致创建对象的调用代码出现大量重复；若创建对象的逻辑发生变化，由于重复出现调用代码的缘故，就需要修改多处。例如Java JDK中的<code>EnumSet</code>类，就通过工厂方法封装了<code>EnumSet</code>的创建逻辑。因为要考虑到创建对象的性能，JDK通过判断底层枚举类型的大小，来决定返回<code>RegularEnumSet</code>或<code>JumboEnumSet</code>实例，二者都是<code>EnumSet</code>的子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; ... </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Enum&lt;E&gt;&gt; <span class="function">EnumSet&lt;E&gt; <span class="title">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span> </span>&#123;</span><br><span class="line">        Enum&lt;?&gt;[] universe = getUniverse(elementType);</span><br><span class="line">        <span class="keyword">if</span> (universe == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(elementType + <span class="string">&quot; not an enum&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (universe.length &lt;= <span class="number">64</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RegularEnumSet&lt;&gt;(elementType, universe);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JumboEnumSet&lt;&gt;(elementType, universe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegularEnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span>&gt; </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JumboEnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span>&gt; </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>《Effective Java》在讲解这个案例时，认为：“这两个实现类的存在对于客户端来说是不可见的。如果<code>RegularEnumSet</code>不能再给小的枚举类型提供性能优势，就可能从未来的发现版本中删除，不会造成不良的影响。同样地，如果事实证明对性能有好处，也可能在未来的发行版本中添加第三甚至第四个<code>EnumSet</code>实现。客户端永远不知道也不关心他们从工厂方法中得到的对象的类；他们只关心它是<code>EnumSet</code>的某个子类即可。”显然，工厂方法的封装就使得调用者不再受到创建逻辑变化的影响，从这个角度来讲，<code>EnumSet</code>就是可以独立进化的。</p>
<p>倘若数据的类型在未来可能发生变化，也可以引入封装进行内外隔离，使得数据类型也可以独立进化。例如在一个BI产品中，诸如DataSource、DataSet、Field、Report、Dashboard、View等元数据都有其唯一标识。这些元数据信息存储在MySQL中，唯一标识采用数据库的自增长ID，则定义其为<code>Int</code>类型。在实现时，我们利用了Scala语言的特性，通过<code>type</code>关键字定义唯一标识，如：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Types</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">ID</span> </span>= <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要使用唯一标识的地方，我们使用了<code>ID</code>而非<code>Int</code>类型，例如操作数据集的方法：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DataSets</span> <span class="keyword">extends</span> <span class="title">JsonWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dataSet</span></span>(dataSetId: <span class="type">ID</span>): <span class="type">Option</span>[<span class="type">DataSet</span>] = <span class="type">DataSet</span>.find(dataSetId)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">directoryIds</span></span>(dataSetId: <span class="type">ID</span>)(<span class="keyword">implicit</span> session: <span class="type">DBSession</span>): <span class="type">List</span>[<span class="type">ID</span>] = &#123;</span><br><span class="line">         <span class="type">Directories</span>.directoryIds(dataSetId, <span class="type">DirectoryType</span>.<span class="type">DataSet</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不只是DataSet的唯一标识，DataSource、Report、Dashboard等的唯一标识皆使用了<code>ID</code>类型。在最初看来，这一设计不过是封装原则的体现，并未刻意考虑对未来变化的隔离。然而不曾想到，后来客户希望产品能够支持元数据迁移的功能。由于之前的设计使用了数据库的自增长标识，这就意味着该标识仅仅在当前数据库中能够保持其唯一性，一旦元数据迁移到了另外一个环境，就可能引起唯一标识的冲突。为了避免这一冲突，我们决定将所有元数据的唯一标识类型修改为<code>UUID</code>类型，并在数据表中定义为<code>varchar(36)</code>类型。由于我们事先定义了<code>ID</code>类型，有效地隔离了变化，仅需要修改数据库脚本，并重新生成了采用<code>UUID</code>为唯一标识的元数据模型对象，而大量的调用代码完全不受影响。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Design</tag>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>茶水间的技术问答</title>
    <url>/technical-discussion-in-tea-room/</url>
    <content><![CDATA[<p>公司的茶水间装修得如家一般温馨，咖啡机时刻飘出咖啡的浓香。员工们常常在此休息聊天，既可以选择坐在高脚凳上依着吧台闲谈阔论，也可以舒服的躺坐在旁边的沙发上闭目养神。晨会之后的半小时，以及午餐前后是这里最喧嚣的时候，此时的茶水间却颇为安宁，大家都在工位上专心工作。</p>
<p>两人来到茶水间，蔡了问道：“老规矩，还是拿铁，对吧？”马丁花点点头，蔡了殷勤地给他接了一杯浓浓的拿铁，然后又给自己接了一杯卡布奇诺，两人坐在沙发上继续讨论之前的话题。</p>
<span id="more"></span>

<p>“蔡了，你见过摆放在餐厅里的饮料机吗？就是能够提供可乐、汽水、橙汁等各种饮料的机器。”</p>
<img src="/technical-discussion-in-tea-room/01.jpg" class="">

<p>“当然见过啊。小时候和爸爸妈妈去餐厅，最喜欢的就是这样的饮料机了，各种饮料尽情畅饮，关键还不收钱。”</p>
<p>“难怪你这么抠门，原来小时候就是个小财迷啊！”马丁花取笑道，看到蔡了有要暴走的迹象，赶紧把话题绕回来：“结合简单工厂模式来看，你觉得饮料机和我们公司的咖啡机有什么区别呢？”</p>
<img src="/technical-discussion-in-tea-room/02.jpg" class="">

<p>说回正题，蔡了马上收回无关的情绪，开始认真地思索起来。“如果我们将饮料和咖啡当做我们要创建的产品，饮料机的每个出口只能创建一种特定的饮料，咖啡机则不同，无论你选择什么类型的咖啡，都从一个出口流出来。所以——”蔡了似乎想到了什么，陷入了沉思。</p>
<p>马丁花坐在沙发上，翘着二郎腿，悠闲地品着咖啡，耐心地等着。</p>
<p>“啊，我想到了！是抽象和多态，对吧，大叔？”说罢，兴奋地拍了拍马丁花的肩膀，差点没让他手中的拿铁泼洒出来。蔡了连连道歉，一边说着对不起，一边拉过放在茶水间的白板，眉飞色舞地讲着：“咖啡机利用了抽象和多态，例如我们定义一个<code>Coffee</code>抽象类，对于喝咖啡的人来说，无论是什么类型的咖啡，其实都是喝咖啡，也就是这样的行为——”蔡了在白板上写下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">coffee.drink();</span><br></pre></td></tr></table></figure>

<p>“显然，coffee的类型是可变的，具体是什么类型在于你选择了什么咖啡！饮料机就不同了，选择了什么饮料，就只能到对应的出口接取饮料。从简单工厂的创建方式来看，饮料机返回的是具体的饮料类型，而咖啡机返回的是抽象的咖啡类型，例如——”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Coffee coffee = CaffeeMachine.make(CoffeeType.Latte);</span><br><span class="line"></span><br><span class="line">Cola cola = SodaFountain.makeCola();</span><br><span class="line">OrangeJuice juice = SodaFountain.makeOrangeJuice();</span><br></pre></td></tr></table></figure>

<p>看到蔡了这么快时间就get到了重点，马丁花不由轻声鼓鼓掌，表示认可和赞赏，接过蔡了的话说道：“从调用代码来看，<code>CoffeeMachine</code>通过多态应对咖啡类型的变化，而<code>SodaFountain</code>则通过多个方法定义满足饮料类型的变化。从调用的简便性和可读性来看，<code>SodaFountain</code>的接口设计其实更合理，但它主要的问题是在返回饮料对象时，没有创建抽象的饮料类，使得返回的产品被绑定死了。这也是饮料机设计上的最大问题。”</p>
<p>“不对啊！大叔，”蔡了打断马丁花，说道：“你不是说多态有利于接口的扩展吗？怎么现在又说是<code>SodaFountain</code>的接口设计更合理呢？”</p>
<p>“你没听清楚我说的前提吗？从简便性和可读性的角度看，<code>SodaFountain</code>的接口设计当然更合理！调用者根据方法名称就知道它究竟生成了什么样的饮料，你也不需要传递方法参数。要知道，<strong>任何设计决策必有其设计前提，你必须在收益和成本中做出取舍和权衡！</strong>”马丁花郑重其事地说道，那神情，仿佛是在传授什么不传之秘！“所以，你说的也没错，从可扩展性角度看，<code>CoffeeMachine</code>的接口显然更稳定，不会因为增加咖啡类型而修改接口的定义。这实际上就是开放封闭原则（Open-Closed Principle）的体现，通过封装隐藏实现细节，即使修改了内部实现，也不会影响到接口的调用者，这也就是开放封闭原则所讲的——<strong>对修改是封闭的</strong>。”</p>
<p>“<a href="http://zhangyi.xyz/simple-factory-is-not-simple/">之前我们讲到<code>Collections</code>类定义的<code>unmodifiableCollection()</code>方法</a>也遵循这一原则，它返回的是抽象的<code>Collection&lt;T&gt;</code>类型！”马丁花补充道。</p>
<p>“可是——”蔡了的思维转动起来，发现自己越想越糊涂，不由问道：“虽说<code>CoffeeMachine</code>的接口方法返回的是一个抽象的<code>Coffee</code>类，但在它的方法实现里，实际上还是躲不掉需要写<code>if-else</code>分支语句，一旦增加了新的咖啡类型，还是要修改<code>make(COffeeType)</code>方法啊！？”</p>
<p>“不错！”马丁花同意蔡了的判断，说道：“Uncle Bob说过，在一个软件系统中针对一种业务逻辑，如果只有一处分支语句是可以接受的。简单方法的这一设计至少保证了接口的稳定性，避免调用者受到变化的影响。当然，如果你想要追求极致，希望不用改任何一行代码就能很好地支持咖啡类型的增加，就可以像<a href="http://zhangyi.xyz/simple-factory-is-not-simple/">之前我们提到的<code>Composer</code>的设计</a>，通过反射结合惯例优于配置的原则，根据传入的咖啡类型组装不同的咖啡类，创建<code>Coffee</code>对象。”马丁花继续补充道：“采用这一方式，只要新增加的咖啡类型遵循规定的类名定义原则（即所谓的惯例），只需新定义一个类，不需要修改任何已有代码，符合开放封闭原则所讲的——<strong>对扩展是开放的</strong>，也就是——”马丁花在白板上写到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开放封闭原则：对扩展是开放的，对修改是封闭的</span><br><span class="line"></span><br><span class="line">通过惯例优于配置与反射创建对象 --&gt; 对扩展是开放的  --&gt; 抽象</span><br><span class="line">返回抽象类型，保证接口稳定 --&gt; 对修改是封闭的  --&gt; 封装</span><br></pre></td></tr></table></figure>

<p>“嗯，明白了。这也算是开放封闭原则的活学活用吧！没想到一个简单工厂模式都蕴含了这么多设计道理！”蔡了饱餐了一顿精神食粮，但似乎还有些意犹未尽，“大叔啊，讲了半天，咖啡都快喝完了，怎么还没讲到其他工厂模式呢？”</p>
<p>“原来你还惦记着这个的啊！我还以为你忘了。”马丁花扬了扬手里空空如也的咖啡杯，颐指气使地指挥着蔡了：“去，再给我来杯拿铁，让我细细给你道来！”</p>
<p>“好咧！”蔡了接过杯子，求学的愿望盖过了对老马高高在上态度的不满，像个使唤丫头似的赶紧给他斟上一杯满满的咖啡。</p>
<p>马丁花接过咖啡，神清气闲地坐在沙发上，一幅得道高人开始布道的样子，开启了循循善诱的讲学模式：“通过之前的讨论，我们确定了咖啡机的简单工厂模式，也分析了它的优劣，对吧？”蔡了点点头，态度像小学生一般恭敬而乖巧。马丁花继续讲道：“假定咖啡机的每个按钮都调用了这个工厂方法，选项不同，传入的参数也不同。由于咖啡类型众多，每次都要选咖啡类型就显得比较麻烦，一不小心，还会选错。现在假设，我们开了一家咖啡店，买了一排这种款式的咖啡机来应对源源不断涌来的点单需求。考虑到顾客点黑咖啡、拿铁与摩卡的频率是最高的，为了提高效率，我希望这款咖啡机能够允许我事先设定一种固定的咖啡类型，如此就不用每次费神选择咖啡类型，也不担心选错咖啡类型了。你想想看，该怎么修改设计呢？”</p>
<p>蔡了想了想，小心地问道：“你的意思是——设定好这种固定的咖啡类型后，就不用选择咖啡类型，每次都按相同的按钮来冲咖啡，对吗？”</p>
<p>“不错！”</p>
<p>蔡了捧着手里的咖啡，开始思考解决方案。平素总是鬼灵精怪的她在陷入沉思时，蓦然展现出她安静娴雅的一面来。一绺秀发滑落下来，在她如月一般皎洁的脸庞前飘过，不知为什么，马丁花突然想到了“你若安好便是晴天”的民国才女林徽因。</p>
<p>“哇，我想到了！大叔！”蔡了欢欣雀跃地叫起来，完全忘记了这里是办公室的茶水间。看她一幅冒失的样子，之前沉思的静女图就好似被撕成碎片丢到了波光粼粼的湖面，马丁花苦笑着摇摇头，心里不由自嘲自己真是老眼昏花了。</p>
<p>蔡了压根儿没有察觉到马大叔的失态，兴奋地讲到：“我想到冲咖啡的按钮对应的是工厂方法<code>make()</code>，既然不需要选择咖啡类型，这个工厂方法就不需要传入<code>CoffeeType</code>参数。可是，没有参数又无法决定冲泡的咖啡类型，所以就需要转移到设定固定咖啡类型的按钮处，它决定了咖啡机到底该冲泡哪种咖啡。一旦确定了，<code>make()</code>方法冲泡出来的咖啡就不会发生变化了。如果将咖啡当做产品，那么决定咖啡机该冲泡哪种咖啡，就应该交给工厂。”蔡了擦去之前白板上的内容，在上面写道：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">产品：咖啡，抽象类型是Coffee</span><br><span class="line">工厂：咖啡机，抽象类型是CoffeeMachine</span><br><span class="line"></span><br><span class="line">冲泡拿铁：</span><br><span class="line">CoffeeMachine lateeMachine = new LateeCoffeeMachine();</span><br><span class="line">Coffee coffee = lateeMachine.make();</span><br></pre></td></tr></table></figure>


<p>看了蔡了写的内容，马丁花忍不住提醒她：“要注意，我买的咖啡机可只有一种款式哦，如果<code>CaffeeMachine</code>是一个抽象类型，就意味着我可能要买各种各样的咖啡机。”</p>
<p>“对哦！”蔡了恍然大悟，自言自语道：“看来咖啡机不能作为工厂，那该怎么办呢？”</p>
<p>“笨蛋！咖啡机不能作为工厂，难道你不能为咖啡机引入一个工厂吗？”马丁花喝道！</p>
<p>真是醍醐灌顶，赶紧擦去错误的内容，重新写到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">产品：咖啡，抽象类型是Coffee</span><br><span class="line">工厂：咖啡制造者，抽象类型是CoffeeMaker</span><br><span class="line"></span><br><span class="line">冲泡拿铁：</span><br><span class="line">CoffeeMaker coffeeMaker = new LateeCoffeeMaker();</span><br><span class="line">Coffee coffee = coffeeMaker.make();</span><br></pre></td></tr></table></figure>

<p>“你再想想，此时的咖啡机该做什么呢？”马丁花提醒道。</p>
<p>“咖啡机是用户操作的对象，按照<strong>最小知识法则</strong>，操作咖啡机的人其实并不知道制造咖啡的工厂对象，但它需要支持用户能够设定一种固定的咖啡类型。所以……”任督二脉被打通了，蔡了的思路也变得清晰无比，立马在白板上写下了如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeMachine</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CoffeeMaker coffeeMaker;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchTo</span><span class="params">(CoffeeType coffeeType)</span> </span>&#123;</span><br><span class="line">        coffeeMaker = createMaker(coffeeType);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        coffeeMaker.make();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> CoffeeMaker <span class="title">createMaker</span><span class="params">(CoffeeType coffeeType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coffeeType.isLatte()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LatteCoffeeMaker();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (coffeeType.isMocha()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MochaCoffeeMaker();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BlackCoffeeMaker();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Class CoffeeMaker &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Coffee <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatteCoffeeMaker</span> <span class="keyword">extends</span> <span class="title">CoffeeMaker</span> ...</span></span><br></pre></td></tr></table></figure>

<p>“是这样吗？”写完后，蔡了得意地问向马丁花！</p>
<p>“不错不错，你还真是冰雪聪明啊！”即使严苛的马丁花也不得不发出赞叹。</p>
<p>“那当然！你不看看我是谁！！！”</p>
<p>“既然你这么厉害，那有没有注意到，在你写的<code>createMaker()</code>方法中仍然出现了烦人的<code>if-else</code>语句，那它的设计和简单工厂方法到底有什么区别呢？”马丁花不放过任何打压她的机会，免得她得志便“猖狂”。</p>
<p>“确实呢……除非用反射，不然都逃不掉分支语句的干扰啊！”蔡了懊恼地说道，然后又认真地对比二者，得出结论道：“虽然它们都是分支语句，但创建的对象却不相同，一个是创建产品，即<code>Coffee</code>，另一个是创建工厂，即<code>CoffeeMaker</code>。除此之外，似乎并无不同！当然，二者运用的模式不同，前者为简单工厂模式，后者就是工厂方法模式，对吧，马大叔？”</p>
<p>“说得都对，不过你没有get到关键的点。它们最大的区别，<strong>在于产品类型变化频率的不同，而频率的不同，使得变化带来的影响亦不相同。</strong>如果待创建产品的类型总在变化，就适合运用简单工厂模式；如果产品类型在确定后几乎不会变化，同时产品对象又会被频繁创建，就适合运用工厂方法模式。你比较咖啡机的不同业务场景，是不是这样的差异？”</p>
<p>“好像是这么回事呢。之前的咖啡机，虽然只有一个冲泡咖啡的出口，但随时可以根据需要选择不同的咖啡类型；而咖啡店的一排咖啡机，在设定了固定的咖啡类型后，通常不会轻易改变，也就不需要临时选择咖啡类型了。”蔡了似乎明白了之间的差异。</p>
<p>“是的。当然，我们要注意，引入工厂模式的<code>CaffeeMachine</code>并非不允许变更咖啡类型，反而它提供了变化的扩展点，通过引入工厂的继承体系来封装<code>Coffee</code>创建的变化。你看——”马丁花一边讲着，一边在白板上写着：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A调用者</span></span><br><span class="line">Coffee coffee = <span class="keyword">new</span> LatteCoffee();     <span class="comment">// 构造函数</span></span><br><span class="line">Coffee coffee = CoffeeMachine.make(CoffeeType.Latte);     <span class="comment">// 工厂方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// B调用者</span></span><br><span class="line">Coffee coffee = <span class="keyword">new</span> LatteCoffee();     <span class="comment">// 构造函数</span></span><br><span class="line">Coffee coffee = CoffeeMachine.make(CoffeeType.Latte);     <span class="comment">// 工厂方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C调用者</span></span><br><span class="line">Coffee coffee = <span class="keyword">new</span> LatteCoffee();     <span class="comment">// 构造函数</span></span><br><span class="line">Coffee coffee = CoffeeMachine.make(CoffeeType.Latte);     <span class="comment">// 工厂方法</span></span><br></pre></td></tr></table></figure>

<p>“假设有A、B、C三个调用者，他们都需要冲泡拿铁咖啡，不管是使用构造函数，还是调用工厂方法，都存在创建逻辑蔓延的问题，一旦这三个调用者都想要换成摩卡咖啡时，就需要修改三个地方。而引入工厂方法模式呢？情况就完全不同了——”马丁花继续在白板的另一侧写道：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局调用</span></span><br><span class="line"><span class="comment">// 要修改咖啡类型，只需要改这一个地方</span></span><br><span class="line">coffeeMachine.switchTo(<span class="keyword">new</span> LatteCoffeeMaker());  </span><br><span class="line"></span><br><span class="line"><span class="comment">// A调用者</span></span><br><span class="line">Coffee coffee = coffeeMachine.make();</span><br><span class="line"></span><br><span class="line"><span class="comment">// B调用者</span></span><br><span class="line">Coffee coffee = coffeeMachine.make();</span><br><span class="line"></span><br><span class="line"><span class="comment">// C调用者</span></span><br><span class="line">Coffee coffee = coffeeMachine.make();</span><br></pre></td></tr></table></figure>


<p>“这样对比一看，真的就秒懂了！太感谢大叔了！”因为又增加了一个技能点，收获满满，蔡了不停地给马丁花握拳作揖，再一看大叔手中的咖啡又要喝完了，赶忙殷勤地跑去给大叔冲咖啡，大叔赶紧说道：“都喝了两杯拿铁了，给我换一杯摩卡吧！哎……今天喝了这么多咖啡，晚上估计又睡不着了，还好是小杯啊！“忽然，马丁花想起了什么，一拍脑袋，赶紧说道：”说起来还忘记给你讲什么是抽象工厂模式了”。</p>
<p>马丁花一边接过蔡了冲泡好的咖啡，继续讲道：“其实很简单。如果说工厂方法模式的工厂方法只有一个，抽象工厂模式就是有多个工厂方法，它们各自创建的产品组合起来就形成了一个产品族（Product Family）。我们还是以咖啡机为例，假设我们要冲泡的咖啡除了类别的不同，还要根据咖啡杯大小分为超大杯（Venti）、大杯（Grande）和中杯（Tall），如果我们要求：咖啡杯尺寸不能作为工厂方法的参数，也就调整了咖啡的继承体系——例如：”马丁花在白板上画出调整后的<code>Coffee</code>类继承图：</p>
<img src="/technical-discussion-in-tea-room/coffee.png" class="">


<p>“现在，要创建这样的<code>Coffee</code>，就需要用到抽象工厂模式了。蔡了，你可以在白板上根据咖啡机的例子画一个类图作为对比。”</p>
<p>“好的。”蔡了答应道，很快就在白板上画出了两个类图：</p>
<img src="/technical-discussion-in-tea-room/factory-method.png" class="">
<img src="/technical-discussion-in-tea-room/abstract-factory.png" class="">

<p>“不错，看来你已经彻底理解这几个工厂模式罗！注意，这些工厂模式都有各自的适用场景，并不能直接说哪一个模式好，哪一个模式差，用得恰当，就是最好！”这几句话说得蔡了连连点头，毕竟这才是真正的经验之谈啊！</p>
<p>正说话间，两人听到后面有人嚷道：“蔡了，又在骚扰马大叔了！”回头一看，说话人原来是团队的成大思。</p>
<p>“什么骚扰啊？”蔡了的俏脸微微泛红，也不知是气的还是羞的，义正言辞地说道：“我这叫不耻下问！懂吗？你没看我正在虚心请教大叔吗？”</p>
<p>“呃……”马丁花听了此言，忍不住手一抖，杯里的摩卡都溅了出来，无语地看着愤怒的蔡了。成大思也满头黑线，笑着说道：“蔡了，你的语文是体育老师教的吗？”</p>
]]></content>
      <categories>
        <category>蔡了成长记</category>
      </categories>
      <tags>
        <tag>Design, OO</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解简单设计</title>
    <url>/understand-simple-design/</url>
    <content><![CDATA[<img src="/understand-simple-design/12-13.jpeg" class="">

<p>Kent Beck提出的简单设计原则，内容为：</p>
<ul>
<li>通过所有测试（Passes its tests）</li>
<li>尽可能消除重复 (Minimizes duplication)</li>
<li>尽可能清晰表达 (Maximizes clarity)</li>
<li>更少代码元素 (Has fewer elements)</li>
<li>以上四个原则的重要程度依次降低。</li>
</ul>
<p>通过所有测试原则意味着我们开发的功能满足客户的需求，这是简单设计的底线原则。该原则同时隐含地告知与客户或领域专家（需求分析师）充分沟通的重要性。</p>
<p>尽可能消除重复原则是对代码质量提出的要求，并通过测试驱动开发的重构环节来完成。注意此原则提到的是Minimizes（尽可能消除），而非No duplication（无重复），因为追求极致的重用存在设计与编码的代价。</p>
<p>尽可能清晰表达原则要求代码要简洁而清晰地传递领域知识，在领域驱动设计的语境下，就是要遵循统一语言，提高代码的可读性，满足业务人员与开发人员的交流目的。针对核心领域，甚至可以考虑引入领域特定语言（Domain Specific Language，DSL）来表现领域逻辑。</p>
<p>在满足这三个原则的基础上，更少代码元素原则告诫我们遏制过度设计的贪心，做到设计的恰如其分，即在满足客户需求的基础上，只要代码已经做到了最少重复与清晰表达，就不要再进一步拆分或提取类、方法和变量。</p>
<p>这四个原则是依次递进的，功能正确，减少重复，代码可读是简单设计的根本要求。一旦满足这些要求，就不能创建更多的代码元素去迎合未来可能并不存在的变化，避免过度设计。</p>
<span id="more"></span>

<h3 id="简单设计的量化标准"><a href="#简单设计的量化标准" class="headerlink" title="简单设计的量化标准"></a>简单设计的量化标准</h3><p>在满足需求的基本前提下，简单设计其实为代码的重构给出了三个量化标准：重复性、可读性与简单性。重复性是一个客观的标准，可读性则出于主观的判断，故而应优先考虑尽可能消除代码的重复，然后在此基础上保证代码清晰地表达设计者的意图，提高可读性。只要达到了重用和可读，就应该到此为止，不要画蛇添足地增加额外的代码元素，如变量、函数、类甚至模块，保证实现方案的简单。</p>
<p>第四个原则是“奥卡姆剃刀”的体现，更加文雅的翻译表达即“如无必要，勿增实体”。人民大学的哲学教授周濂在解释奥卡姆剃刀时，如是说道：</p>
<blockquote>
<p>作为一个极端的唯名论者，奥卡姆的威廉（William of Occam，1280——1349）主张个别的事物是真实的存在，除此之外没有必要再设立普遍的共相，美的东西就是美的，不需要再废话多说什么美的东西之所以为美是由于美，最后这个美，完全可以用奥卡姆的剃刀一割了之。</p>
</blockquote>
<p>这个所谓“普遍的共相”就是一种抽象。在软件开发中，那些不必要的抽象反而会产生多余的概念，实际会干扰代码阅读者的判断，增加代码的复杂度。因此，简单设计强调恰如其分的设计，若实现的功能通过了所有测试，就意味着满足了客户的需求，这时，只需要尽可能消除重复，清晰表达了设计者意图，就不可再增加额外的软件元素。若存在多余实体，当用奥卡姆的剃刀一割了之。</p>
<h3 id="FitNesse实例"><a href="#FitNesse实例" class="headerlink" title="FitNesse实例"></a>FitNesse实例</h3><p>让我们通过重构一段FitNesse代码来阐释简单设计原则。这段代码案例来自Robert Martin的著作《代码整洁之道》。Robert Martin在书中给出了对源代码的三个重构版本，这三个版本的演化恰好可以帮助我们理解简单设计原则。</p>
<p>重构前的代码初始版本是定义在<code>HtmlUtil</code>类中的一个长函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">testableHtml</span><span class="params">(PageData pageData, <span class="keyword">boolean</span> includeSuiteSetup)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        WikiPage wikiPage = pageData.getWikiPage();</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">if</span> (pageData.hasAttribute(<span class="string">&quot;Test&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (includeSuiteSetup) &#123;</span><br><span class="line">                WikiPage suiteSetupPage = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);</span><br><span class="line">                <span class="keyword">if</span> (suiteSetupPage != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    WikiPagePath pagePath = wikiPage.getPageCrawler().getFullPath(suiteSetupPage);</span><br><span class="line">                    String pagePathName = PathParser.render(pagePath);</span><br><span class="line">                    buffer.append(<span class="string">&quot;\n!include -setup .&quot;</span>)</span><br><span class="line">                          .append(pagePathName)</span><br><span class="line">                          .append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            WikiPage setupPage = PageCrawlerImpl.getInheritedPage(<span class="string">&quot;SetUp&quot;</span>, wikiPage);</span><br><span class="line">            <span class="keyword">if</span> (setupPage != <span class="keyword">null</span>) &#123;</span><br><span class="line">                WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setupPage);</span><br><span class="line">                String setupPathName = PathParser.render(setupPath);</span><br><span class="line">                buffer.append(<span class="string">&quot;\n!include -setup .&quot;</span>)</span><br><span class="line">                      .append(setupPathName)</span><br><span class="line">                      .append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.append(pageData.getContent());</span><br><span class="line">        <span class="keyword">if</span> (pageData.hasAttribute(<span class="string">&quot;Test&quot;</span>)) &#123;</span><br><span class="line">            WikiPage teardownPage = PageCrawlerImpl.getInheritedPage(<span class="string">&quot;TearDown&quot;</span>, wikiPage);</span><br><span class="line">            <span class="keyword">if</span> (teardownPage != <span class="keyword">null</span>) &#123;</span><br><span class="line">                WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardownPage);</span><br><span class="line">                String tearDownPathName = PathParser.render(tearDownPath);</span><br><span class="line">                buffer.append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">                      .append(<span class="string">&quot;!include -teardown .&quot;</span>)</span><br><span class="line">                      .append(tearDownPathName)</span><br><span class="line">                      .append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (includeSuiteSetup) &#123;</span><br><span class="line">                WikiPage suiteTeardownPage = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_TEARDOWN_NAME, wikiPage);</span><br><span class="line">                <span class="keyword">if</span> (suiteTeardownPage != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    WikiPagePath pagePath = wikiPage.getPageCrawler().getFullPath(suiteTeardownPage);</span><br><span class="line">                    String pagePathName = PathParser.render(pagePath);</span><br><span class="line">                    buffer.append(<span class="string">&quot;\n!include -teardown .&quot;</span>)</span><br><span class="line">                          .append(pagePathName)</span><br><span class="line">                          .append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pageData.setContent(buffer.toString());</span><br><span class="line">        <span class="keyword">return</span> pageData.getHtml();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>假定这一个函数已经通过了测试，按照简单设计的评判步骤，我们需要检查代码是否存在重复。显然，在上述代码的6<del>13行、15</del>22行、26<del>34行以及36</del>43行四个地方都发现了重复或相似的代码。这些代码的执行步骤像一套模板：</p>
<ul>
<li>获取Page</li>
<li>若Page不为null，则获取路径</li>
<li>解析路径名称</li>
<li>添加到输出结果中</li>
</ul>
<p>这套模板的差异部分可以通过参数差异化完成，故而可以提取方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">includePage</span><span class="params">(WikiPage wikiPage, StringBuffer buffer, String pageName, String sectionName)</span> </span>&#123;</span><br><span class="line">        WikiPage suiteSetupPage = PageCrawlerImpl.getInheritedPage(pageName, wikiPage);</span><br><span class="line">        <span class="keyword">if</span> (suiteSetupPage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WikiPagePath pagePath = wikiPage.getPageCrawler().getFullPath(suiteSetupPage);</span><br><span class="line">            String pagePathName = PathParser.render(pagePath);</span><br><span class="line">            buildIncludeDirective(buffer, sectionName, pagePathName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildIncludeDirective</span><span class="params">(StringBuffer buffer, String sectionName, String pagePathName)</span> </span>&#123;</span><br><span class="line">        buffer.append(<span class="string">&quot;\n!include &quot;</span>)</span><br><span class="line">                .append(sectionName)</span><br><span class="line">                .append(<span class="string">&quot; .&quot;</span>)</span><br><span class="line">                .append(pagePathName)</span><br><span class="line">                .append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在提取了<code>includePage()</code>方法后，就可以消除四段几乎完全相似的重复代码。重构后的长函数为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">testableHtml</span><span class="params">(PageData pageData, <span class="keyword">boolean</span> includeSuiteSetup)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        WikiPage wikiPage = pageData.getWikiPage();</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pageData.hasAttribute(<span class="string">&quot;Test&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (includeSuiteSetup) &#123;</span><br><span class="line">                includePage(wikiPage, buffer, SuiteResponder.SUITE_SETUP_NAME, <span class="string">&quot;-setup&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            includePage(wikiPage, buffer, <span class="string">&quot;SetUp&quot;</span>, <span class="string">&quot;-setup&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer.append(pageData.getContent());</span><br><span class="line">        <span class="keyword">if</span> (pageData.hasAttribute(<span class="string">&quot;Test&quot;</span>)) &#123;</span><br><span class="line">            includePage(wikiPage, buffer, <span class="string">&quot;TearDown&quot;</span>, <span class="string">&quot;-teardown&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (includeSuiteSetup) &#123;</span><br><span class="line">                includePage(wikiPage, buffer, SuiteResponder.SUITE_TEARDOWN_NAME, <span class="string">&quot;-teardown&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pageData.setContent(buffer.toString());</span><br><span class="line">        <span class="keyword">return</span> pageData.getHtml();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从重复性角度看，以上代码已经去掉了重复。当然，也可以将<code>pageData.hasAttribute(&quot;Test&quot;)</code>视为重复，因为该表达式在第5行和第12行都出现过，表达式用到的常量<code>&quot;Test&quot;</code>也是重复。不过，你若认为这是从代码可读性角度对其重构，也未尝不可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isTestPage</span><span class="params">(PageData pageData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pageData.hasAttribute(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>若遵循信息专家模式，<code>isTestPage()</code>方法应该分配给<code>PageData</code>类，通过移动方法，转移到<code>PageData</code>类后，将其改变为实例方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class PageData</span></span><br><span class="line"><span class="function">    <span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTestPage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasAttribute(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>重构后的<code>testableHtml()</code>方法的可读性仍有不足之处，例如方法的名称，<code>buffer</code>变量名都没有清晰表达设计意图，对Test和Suite的判断增加了条件分支，给代码阅读制造了障碍。由于<code>includePage()</code>方法是一个通用方法，未能清晰表达其意图，且传递的参数同样干扰了阅读，应该将各个调用分别封装为表达业务含义的方法，例如定义为<code>includeSetupPage()</code>。当页面并非测试页面时，<code>pageData</code>的内容无需重新设置，可以直接通过<code>getHtml()</code>方法返回。因此，添加页面内容的第11行代码还可以放到<code>isTestPage()</code>分支中，让逻辑变得更加紧凑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">renderPage</span><span class="params">(PageData pageData, <span class="keyword">boolean</span> includeSuiteSetup)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pageData.isTestPage()) &#123;</span><br><span class="line">            WikiPage testPage = pageData.getWikiPage();</span><br><span class="line">            StringBuffer newPageContent = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">            includeSuiteSetupPage(testPage, newPageContent, includeSuiteSetup);</span><br><span class="line">            includeSetupPage(testPage, newPageContent);</span><br><span class="line">            includePageContent(testPage, newPageContent);</span><br><span class="line">            includeTeardownPage(testPage, newPageContent);</span><br><span class="line">            includeSuiteTeardownPage(testPage, newPageContent, includeSuiteSetup);</span><br><span class="line"></span><br><span class="line">            pageData.setContent(buffer.toString());</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> pageData.getHtml();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>无论是避免重复，还是清晰表达意图，这个版本的代码都要远胜于最初的版本。Robert Martin在《代码整洁之道》中也给出了他重构的第一个版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">renderPageWithSetupsAndTeardowns</span><span class="params">(PageData pageData, <span class="keyword">boolean</span> isSuite)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isTestPage = pageData.hasAttribute(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (isTestPage) &#123;</span><br><span class="line">            WikiPage testPage = pageData.getWikiPage();</span><br><span class="line">            StringBuffer newPageContent = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            includeSetupPages(testPage, newPageContent, isSuite);</span><br><span class="line">            newPageContent.append(pageData.getContent());</span><br><span class="line">            includeTeardownPages(testPage, newPageContent, isSuite);</span><br><span class="line">            pageData.setContent(newPageContent.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pageData.getHtml();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对比我的版本和Robert Martin的版本，我认为Robert Martin的当前版本仍有以下不足之处：</p>
<ul>
<li>方法名称过长，暴露了实现细节</li>
<li><code>isTestPage</code>变量不如<code>isTestPage()</code>方法的封装性好</li>
<li>方法体缺少分段，不同的意图混淆在了一起</li>
</ul>
<p>最关键的不足之处在于第7行代码。对比第7行和第6、8两行代码，虽然都是一行代码，但其表达的意图却有风马牛不相及的违和感。这是因为第7行代码实际暴露了将页面内容追加到<code>newPageContent</code>的实现细节，第6行和第8行代码却隐藏了这一实现细节。这三行代码没有处于同一个抽象层次，违背了“单一抽象层次原则（SLAP）”。</p>
<p>Robert Martin在这个版本基础上，继续精进，给出了重构后的第二个版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">renderPageWithSetupsAndTeardowns</span><span class="params">(PageData pageData, <span class="keyword">boolean</span> isSuite)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isTestPage(pageData))</span><br><span class="line">            includeSetupAndTeardownPages(pageData, isSuite);</span><br><span class="line">        <span class="keyword">return</span> pageData.getHtml();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该版本的方法仍然定义在<code>HtmlUtil</code>工具类中。对比Robert Martin的两个重构版本，后一版本的主方法变得更加简单了，方法体只有短短的三行代码。虽然方法变得更简短，但提取出来的<code>includeSetupAndTeardownPages()</code>方法却增加了不必要的抽象层次。</p>
<p><strong>封装需要有度，引入太多的层次反而会干扰阅读。</strong>尤其是方法，Java或大多数语言都不提供“方法嵌套方法”的层次结构（Scala支持这一语法特性）。如果为一个方法的不同业务层次提取了太多方法，在逻辑上，它存在递进的嵌套关系，在物理上，却是一个扁平的结构。阅读这样的代码会造成不停的跳转，不够直接。正如Grady Booch所述：“整洁的代码从不隐藏设计者的意图，充满了<strong>干净利落</strong>的抽象和<strong>直截了当</strong>的控制语句。”干净利落，直截了当，可以破除对过度细粒度方法的迷信！与其封装一个用超长名称才能表达其意图的<code>includeSetupAndTeardownPages()</code>方法，不如直接“敞开”相同层次的代码细节，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">includeSuiteSetupPage(testPage, newPageContent, includeSuiteSetup);</span><br><span class="line">includeSetupPage(testPage, newPageContent);</span><br><span class="line">includePageContent(testPage, newPageContent);</span><br><span class="line">includeTeardownPage(testPage, newPageContent);</span><br><span class="line">includeSuiteTeardownPage(testPage, newPageContent, includeSuiteSetup);</span><br></pre></td></tr></table></figure>

<p>这五行代码不正是直截了当地表达了包含的页面结构吗？因此，我觉得Robert Martin提取出来的<code>includeSetupAndTeardownPages()</code>方法违背了简单设计的第四条原则，即增加了不必要的软件元素。事实上，如果一个方法的名称包含了and，就说明该方法可能违背了“一个方法只做一件事情”的基本原则。</p>
<p>我并不反对定义细粒度方法，相反我很欣赏合理的细粒度方法，如前提取的<code>includePageContent()</code>方法。一个庞大的方法往往缺少内聚性，不利于重用，但什么才是方法的合适粒度呢？不同的公司有着不同的方法行限制，有的是200行，有的是50行，有的甚至约束到5行。最关键的不是限制代码行，而在于一个方法只能做一件事。</p>
<p>若发现一个主方法过长，可通过提取方法使它变短。当提取方法的逻辑层次嵌套太多，彼此的职责又高内聚时，就需要考虑将这个主方法和提取出来的方法一起委派到一个专门的类。此外，通过<code>includeSetupPage()</code>等方法传递的共同参数，也说明了这些方法相较于其他方法而言，要更加内聚。</p>
<p>由此可知，<code>testableHtml()</code>方法的逻辑提供了一个相对独立的职责，不应该将其实现逻辑放在<code>HtmlUtil</code>工具类，而应按照其意图独立为一个类<code>TestPageIncluder</code>。一旦提取为类，还可以将方法共同传递的参数转换为这个新类的字段，从而减少方法之间传递的参数。重构后的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPageIncluder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PageData pageData;</span><br><span class="line">    <span class="keyword">private</span> WikiPage testPage;</span><br><span class="line">    <span class="keyword">private</span> StringBuffer newPageContent;</span><br><span class="line">    <span class="keyword">private</span> PageCrawler pageCrawler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestPageIncluder</span><span class="params">(PageData pageData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pageData = pageData;</span><br><span class="line">        testPage = pageData.getWikiPage();</span><br><span class="line">        pageCrawler = testPage.getPageCrawler();</span><br><span class="line">        newPageContent = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">render</span><span class="params">(PageData pageData)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> render(pageData, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">render</span><span class="params">(PageData pageData, <span class="keyword">boolean</span> isSuite)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TestPageIncluder(pageData).renderPage(isSuite);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">renderPage</span><span class="params">(<span class="keyword">boolean</span> isSuite)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pageData.isTestPage()) &#123;</span><br><span class="line">            includeSetupPages(isSuite);</span><br><span class="line">            includePageContent();</span><br><span class="line">            includeTeardownPages(isSuite);</span><br><span class="line">            updatePageContent();            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pageData.getHtml();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">includeSetupPages</span><span class="params">(<span class="keyword">boolean</span> isSuite)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSuite) &#123;</span><br><span class="line">            includeSuitesSetupPage();</span><br><span class="line">        &#125;</span><br><span class="line">        includeSetupPage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">includeSuitesSetupPage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        includePage(SuiteResponder.SUITE_SETUP_NAME, <span class="string">&quot;-setup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">includeSetupPage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        includePage(<span class="string">&quot;SetUp&quot;</span>, <span class="string">&quot;-setup&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">includeTeardownPages</span><span class="params">(<span class="keyword">boolean</span> isSuite)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSuite) &#123;</span><br><span class="line">            includeSuitesTeardownPage();</span><br><span class="line">        &#125;</span><br><span class="line">        includeTeardownPage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">includeSuitesTeardownPage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        includePage(SuiteResponder.SUITE_TEARDOWN_NAME, <span class="string">&quot;-teardown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">includeTeardownPage</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        includePage(<span class="string">&quot;TearDown&quot;</span>, <span class="string">&quot;-teardown&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateContent</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        pageData.setContent(newPageContent.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">includePage</span><span class="params">(String pageName, String sectionName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        WikiPage inheritedPage = PageCrawlerImpl.getInheritedPage(pageName, wikiPage);</span><br><span class="line">        <span class="keyword">if</span> (inheritedPage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WikiPagePath pagePath = wikiPage.getPageCrawler().getFullPath(inheritedPage);</span><br><span class="line">            String pathName = PathParser.render(pagePath);</span><br><span class="line">            buildIncludeDirective(pathName, sectionName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildIncludeDirective</span><span class="params">(String pathName, String sectionName)</span> </span>&#123;</span><br><span class="line">        buffer.append(<span class="string">&quot;\n!include &quot;</span>)</span><br><span class="line">            .append(sectionName)</span><br><span class="line">            .append(<span class="string">&quot; .&quot;</span>)</span><br><span class="line">            .append(pathName)</span><br><span class="line">            .append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引入<code>TestPageIncluder</code>类后，职责的层次更加清晰了，分离出来的这个类承担了组装测试页面信息的职责，<code>HtmlUtil</code>类只需要调用它的静态方法<code>render()</code>即可，避免了因承担太多职责而形成一个上帝类。通过提取出类和对应的方法，形成不同的抽象层次，让代码的阅读者有选择地阅读自己关心的部分，这就是清晰表达设计者意图的价值。</p>
<p>对比Robert Martin给出的重构第二个版本以及这个提取类的最终版本，我赞成将该主方法的逻辑提取给专门的类，但不赞成在主方法中定义过度抽象层次的<code>includeSetupAndTeardownPages()</code>方法。</p>
<p>我曾就Robert Martin给出的两个版本做过调查，发现仍然有一部分人偏爱第二个更加简洁的版本。这一现象恰好说明简单设计的第三条原则属于主观判断，不如第二条原则那般具有客观的评判标准，恰如大家对美各有自己的欣赏。但我认为，一定不会有人觉得重构前的版本才是最好。即使不存在重复代码，单从可读性角度判断，也会觉得最初版本的代码不堪入目，恰如大家对美的评判标准，仍具有一定的普适性。</p>
<p>Robert Martin在《代码整洁之道》中也给出了分离职责的类<code>SetupTeardownIncluder</code>。两个类的实现相差不大，只是<code>TestPageIncluder</code>类要少一些方法。除了没有<code>includeSetupAndTeardownPages()</code>方法外，我也未曾定义<code>findInheritedPage()</code>和<code>getPathNameForPage()</code>之类的方法，也没有提取<code>isSuite</code>字段，因为我认为这些都是不必要的软件元素，它违背了简单设计的第四条原则，应当用奥卡姆的剃刀一割了之。</p>
<p>当然，如果开发人员在编写代码时就能遵循简单设计原则，实则也不会写出FitNesse最早版本这样的代码，因为该原则与测试驱动开发相匹配，在完成一个失败测试的实现之后，应该即刻进行重构，重构时依据重用性、可读性和简单性对代码质量进行判断，自然不会出现大段的充满了重复、冗长的代码臭味。</p>
]]></content>
      <categories>
        <category>Design</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>TDD</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读开源框架，遍览Java嵌套类的用法</title>
    <url>/usage-of-java-nested-class/</url>
    <content><![CDATA[<p>Java的类对外而言只有一种面貌，但封装在类内部的形态却可以丰富多彩。嵌套类在这其中，扮演了极为重要的角色。它既丰富了类的层次，又可以灵活控制内部结构的访问限制与粒度，使得我们在开放性与封闭性之间、公开接口与内部实现之间取得适度的平衡。</p>
<span id="more"></span>

<p>嵌套类之所以能扮演这样的<strong>设计平衡角色</strong>，是因为嵌套类与其主类的关系不同，主类的所有成员对嵌套类而言都是完全开放的，主类的私有成员可以被嵌套类访问，而嵌套类则可以被看做是类边界中自成一体的高内聚类而被主类调用。因此，嵌套类的定义其实就是对类内部成员的进一步封装。虽然在一个类中定义嵌套类并不能减小类定义的规模，但由于嵌套类体现了不同层次的封装，使得一个相对较大的主类可以显得更有层次感，不至于因为成员过多而显得过于混乱。</p>
<p>当一个类的业务逻辑非常复杂，且它承担的职责却又不足以单独分离为另外的类型时，内部嵌套类尤其是静态嵌套类就会变得非常有用。它是帮助我们组织类内部代码的利器。通过阅读顶级的Java开源项目，我们发现内部嵌套类通常用于几种情况。</p>
<h3 id="封装Builder"><a href="#封装Builder" class="headerlink" title="封装Builder"></a>封装Builder</h3><p>Builder模式常常用于组装一个类，它通过更加流畅的接口形式简化构建组成元素的逻辑。在Java中，除非必要，我们一般会将一个类的Builder定义为内部嵌套类。这几乎已经成为一种惯有模式了。</p>
<p>例如<strong>框架airlift</strong>定义了<code>Request</code>类，它是客户端请求对象的一个封装。组成一个<code>Request</code>对象需要诸如Uri、header、http verb、body等元素，且这些元素的组成会因为客户请求的不同而调用不同的组装方法。这是典型的Builder模式应用场景。让我们看看在<strong>Presto框架</strong>下，它如何调用airlift提供的<code>Request</code>及对应的<code>Builder</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementClient</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Request <span class="title">buildQueryRequest</span><span class="params">(ClientSession session, String query)</span>    </span>&#123;</span><br><span class="line">        Request.Builder builder = prepareRequest(preparePost(), uriBuilderFrom(session.getServer()).replacePath(<span class="string">&quot;/v1/statement&quot;</span>).build())</span><br><span class="line">                .setBodyGenerator(createStaticBodyGenerator(query, UTF_8));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (session.getSource() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.setHeader(PrestoHeaders.PRESTO_SOURCE, session.getSource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (session.getClientInfo() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.setHeader(PrestoHeaders.PRESTO_CLIENT_INFO, session.getClientInfo());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (session.getCatalog() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.setHeader(PrestoHeaders.PRESTO_CATALOG, session.getCatalog());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (session.getSchema() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.setHeader(PrestoHeaders.PRESTO_SCHEMA, session.getSchema());</span><br><span class="line">        &#125;</span><br><span class="line">        builder.setHeader(PrestoHeaders.PRESTO_TIME_ZONE, session.getTimeZone().getId());</span><br><span class="line">        <span class="keyword">if</span> (session.getLocale() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            builder.setHeader(PrestoHeaders.PRESTO_LANGUAGE, session.getLocale().toLanguageTag());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; property = session.getProperties();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : property.entrySet()) &#123;</span><br><span class="line">            builder.addHeader(PrestoHeaders.PRESTO_SESSION, entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; statements = session.getPreparedStatements();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : statements.entrySet()) &#123;</span><br><span class="line">            builder.addHeader(PrestoHeaders.PRESTO_PREPARED_STATEMENT, urlEncode(entry.getKey()) + <span class="string">&quot;=&quot;</span> + urlEncode(entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        builder.setHeader(PrestoHeaders.PRESTO_TRANSACTION_ID, session.getTransactionId() == <span class="keyword">null</span> ? <span class="string">&quot;NONE&quot;</span> : session.getTransactionId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Request.<span class="function">Builder <span class="title">prepareRequest</span><span class="params">(Request.Builder builder, URI nextUri)</span>    </span>&#123;</span><br><span class="line">        builder.setHeader(PrestoHeaders.PRESTO_USER, user);</span><br><span class="line">        builder.setHeader(USER_AGENT, USER_AGENT_VALUE)</span><br><span class="line">                .setUri(nextUri);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，<code>StatementClient</code>会根据<code>ClientSession</code>对象的不同情况，构造不同的<code>Request</code>。由于引入了Builder模式，则这种构造<code>Request</code>对象的职责到<code>Request.Builder</code>对象。观察该对象的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Request.Builder builder = prepareRequest(...);</span><br></pre></td></tr></table></figure>

<p><code>Builder</code>类被定义为<code>Request</code>的静态嵌套类，以下为airlift框架的源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> URI uri;</span><br><span class="line">        <span class="keyword">private</span> String method;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ListMultimap&lt;String, String&gt; headers = ArrayListMultimap.create();</span><br><span class="line">        <span class="keyword">private</span> BodyGenerator bodyGenerator;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Request.<span class="function">Builder <span class="title">prepareHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> Request.Builder()).setMethod(<span class="string">&quot;HEAD&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Request.<span class="function">Builder <span class="title">prepareGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> Request.Builder()).setMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Request.<span class="function">Builder <span class="title">preparePost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> Request.Builder()).setMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Request.<span class="function">Builder <span class="title">preparePut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> Request.Builder()).setMethod(<span class="string">&quot;PUT&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Request.<span class="function">Builder <span class="title">prepareDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> Request.Builder()).setMethod(<span class="string">&quot;DELETE&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Request.<span class="function">Builder <span class="title">fromRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">            Request.Builder requestBuilder = <span class="keyword">new</span> Request.Builder();</span><br><span class="line">            requestBuilder.setMethod(request.getMethod());</span><br><span class="line">            requestBuilder.setBodyGenerator(request.getBodyGenerator());</span><br><span class="line">            requestBuilder.setUri(request.getUri());</span><br><span class="line">            Iterator var2 = request.getHeaders().entries().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (var2.hasNext()) &#123;</span><br><span class="line">                Entry entry = (Entry)var2.next();</span><br><span class="line">                requestBuilder.addHeader((String)entry.getKey(), (String)entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> requestBuilder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Request.<span class="function">Builder <span class="title">setUri</span><span class="params">(URI uri)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.uri = Request.validateUri(uri);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Request.<span class="function">Builder <span class="title">setMethod</span><span class="params">(String method)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.method = method;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Request.<span class="function">Builder <span class="title">setHeader</span><span class="params">(String name, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.headers.removeAll(name);</span><br><span class="line">            <span class="keyword">this</span>.headers.put(name, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Request.<span class="function">Builder <span class="title">addHeader</span><span class="params">(String name, String value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.headers.put(name, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Request.<span class="function">Builder <span class="title">setBodyGenerator</span><span class="params">(BodyGenerator bodyGenerator)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.bodyGenerator = bodyGenerator;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Request <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Request(<span class="keyword">this</span>.uri, <span class="keyword">this</span>.method, <span class="keyword">this</span>.headers, <span class="keyword">this</span>.bodyGenerator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个类的构建逻辑非常复杂，并有多种不同的组合可能性时，我们会倾向于使用Builder模式来封装这种变化的组装逻辑。惯用的模式是将Builder类定义为公有静态嵌套类，很多Java实践证实了这一做法。</p>
<h3 id="封装Iterator"><a href="#封装Iterator" class="headerlink" title="封装Iterator"></a>封装Iterator</h3><p>当我们需要在类中提供自定义的迭代器，且又不需要将该迭代器的实现对外公开时，都可以通过嵌套类实现一个内部迭代器。这是迭代器模式的一种惯用法。例如在<strong>Presto框架</strong>中，定义了属于自己的<code>PrestoResultSet</code>类，继承自JDBC的<code>ResultSet</code>，并重写了父类的迭代方法<code>next()</code>。<code>next</code>方法的迭代职责又委派给了一个内部迭代器<code>results</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrestoResultSet</span> <span class="keyword">implements</span> <span class="title">ResultSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;List&lt;Object&gt;&gt; results;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException  </span>&#123;</span><br><span class="line">        checkOpen();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!results.hasNext()) &#123;</span><br><span class="line">                row.set(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row.set(results.next());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> SQLException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (SQLException) e.getCause();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;Error fetching results&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个<code>results</code>实则是一个内部迭代器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrestoResultSet</span> <span class="keyword">implements</span> <span class="title">ResultSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultsPageIterator</span></span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">AbstractIterator</span>&lt;<span class="title">Iterable</span>&lt;<span class="title">List</span>&lt;<span class="title">Object</span>&gt;&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ResultsPageIterator</code>迭代器继承自<strong>Guava框架</strong>定义的<code>AbstractIterator&lt;T&gt;</code>，间接实现了接口<code>Iterator&lt;T&gt;</code>。</p>
<h3 id="封装内部概念"><a href="#封装内部概念" class="headerlink" title="封装内部概念"></a>封装内部概念</h3><p>编写整洁代码的实践告诉我们：类的定义要满足“单一职责原则”，这样的类才是专注的。编写可扩展代码的实践也告诉我们：类的定义要满足“单一职责原则”，如此才能保证只有一个引起变化的原因。然而，即使类只履行一个专注的职责，也可能因为过于复杂的业务逻辑而导致设计出相对比较庞大的类（真实项目总是要比玩具项目复杂100倍）。这时，我们会面临左右为难的选择。倘若不将职责分离到另外的单独类中，则该类就过于庞大，导致内部逻辑过于复杂；倘若将部分逻辑分离出去，又会导致类的数量过多，导致系统复杂度增加。这时，我们可以用嵌套类来封装内部概念，定义属于自己的数据与行为，在主类内部形成更加清晰的职责边界，却没有引起系统类数量的增加，算是一种折中的设计手法。</p>
<p>当然，我们必须谨记的一点是：<strong>究竟职责应该定义在独立类中，还是定义在附属的嵌套类，判断标准不是看代码量以及类的规模，而是看这些需要封装的逻辑究竟属于内部概念，还是外部概念。</strong></p>
<p>例如<strong>Presto框架</strong>的<code>HiveWriterFactory</code>类。它是一个工厂类，创建的产品为<code>HiveWriter</code>。在创建过程中，需要根据列名、列类型以及列的Hive类型进行组合，并将组合后的结果赋值给<code>Properties</code>类型的<code>schema</code>。</p>
<p>这些值并不需要公开，如果不对其进行封装，则存在问题：</p>
<ul>
<li>没有体现领域概念，只有散乱的三种类型的变量</li>
<li>无法将其作为整体放入到集合中，因而也无法调用集合的API对其进行转换</li>
</ul>
<p>针对Hive所要操作的数据，列名、列类型以及列的Hive类型这三个散乱概念实际上表达的是<strong>数据列</strong>的概念，于是就可以在这个工厂类中定义嵌套类来封装这些概念与逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiveWriterFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DataColumn</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HiveType hiveType;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DataColumn</span><span class="params">(String name, Type type, HiveType hiveType)</span>  </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = requireNonNull(name, <span class="string">&quot;name is null&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.type = requireNonNull(type, <span class="string">&quot;type is null&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.hiveType = requireNonNull(hiveType, <span class="string">&quot;hiveType is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> HiveType <span class="title">getHiveType</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hiveType;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在封装为<code>DataColumn</code>嵌套类后，就可以将其放入到<code>List&lt;DataColumn&gt;</code>集合中，然后像如下代码那样对其进行操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">schema.setProperty(META_TABLE_COLUMNS, dataColumns.stream()</span><br><span class="line">       .map(DataColumn::getName)</span><br><span class="line">       .collect(joining(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">schema.setProperty(META_TABLE_COLUMN_TYPES, dataColumns.stream()</span><br><span class="line">       .map(DataColumn::getHiveType)</span><br><span class="line">       .map(HiveType::getHiveTypeName)</span><br><span class="line">       .collect(joining(<span class="string">&quot;:&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>在开发过程中，我们还会经常遇见一种典型的数据结构，它需要将两个值对应起来形成一种映射。这种数据结构通常称之为tuple。虽然在Java 7已经提供了这种简便的结构（Scala在一开始就提供了tuple结构，而且还提供了<code>._1</code>和<code>._2</code>的快捷访问方式），但这种结构是通用的，不利于体现出业务概念。当这种结构仅仅在一个类的内部使用时，就是嵌套类登上舞台的时候了。</p>
<p>例如我们要建立<code>Type</code>与<code>Object</code>之间的映射关系，并被用在一个SQL语句的解析器中充当解析过程中的元数据，就可以定义为类<code>TypeAndValue</code>，命名直白，清晰可见：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLStatementParser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TypeAndValue&gt; accumulator = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">buildSql</span><span class="params">(JdbcClient client, Connection connection, String catalog, String schema, String table, List&lt;JdbcColumnHandle&gt; columns)</span> </span>&#123;</span><br><span class="line">        StringBuilder sql = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        String columnNames = columns.stream()</span><br><span class="line">                .map(JdbcColumnHandle::getColumnName)</span><br><span class="line">                .map(<span class="keyword">this</span>::quote)</span><br><span class="line">                .collect(joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line"></span><br><span class="line">        sql.append(<span class="string">&quot;SELECT &quot;</span>);</span><br><span class="line">        sql.append(columnNames);</span><br><span class="line">        <span class="keyword">if</span> (columns.isEmpty()) &#123;</span><br><span class="line">            sql.append(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sql.append(<span class="string">&quot; FROM &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!isNullOrEmpty(catalog)) &#123;</span><br><span class="line">            sql.append(quote(catalog)).append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isNullOrEmpty(schema)) &#123;</span><br><span class="line">            sql.append(quote(schema)).append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sql.append(quote(table));</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; clauses = toConjuncts(columns, accumulator);</span><br><span class="line">        <span class="keyword">if</span> (!clauses.isEmpty()) &#123;</span><br><span class="line">            sql.append(<span class="string">&quot; WHERE &quot;</span>)</span><br><span class="line">                    .append(Joiner.on(<span class="string">&quot; AND &quot;</span>).join(clauses));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PreparedStatement statement = client.getPreparedStatement(connection, sql.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; accumulator.size(); i++) &#123;</span><br><span class="line">            TypeAndValue typeAndValue = accumulator.get(i);</span><br><span class="line">            <span class="keyword">if</span> (typeAndValue.getType().equals(BigintType.BIGINT)) &#123;</span><br><span class="line">                statement.setLong(i + <span class="number">1</span>, (<span class="keyword">long</span>) typeAndValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.getType().equals(IntegerType.INTEGER)) &#123;</span><br><span class="line">                statement.setInt(i + <span class="number">1</span>, ((Number) typeAndValue.getValue()).intValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.getType().equals(SmallintType.SMALLINT)) &#123;</span><br><span class="line">                statement.setShort(i + <span class="number">1</span>, ((Number) typeAndValue.getValue()).shortValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.getType().equals(TinyintType.TINYINT)) &#123;</span><br><span class="line">                statement.setByte(i + <span class="number">1</span>, ((Number) typeAndValue.getValue()).byteValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.getType().equals(DoubleType.DOUBLE)) &#123;</span><br><span class="line">                statement.setDouble(i + <span class="number">1</span>, (<span class="keyword">double</span>) typeAndValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.getType().equals(RealType.REAL)) &#123;</span><br><span class="line">                statement.setFloat(i + <span class="number">1</span>, intBitsToFloat(((Number) typeAndValue.getValue()).intValue()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.getType().equals(BooleanType.BOOLEAN)) &#123;</span><br><span class="line">                statement.setBoolean(i + <span class="number">1</span>, (<span class="keyword">boolean</span>) typeAndValue.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.getType().equals(DateType.DATE)) &#123;</span><br><span class="line">                <span class="keyword">long</span> millis = DAYS.toMillis((<span class="keyword">long</span>) typeAndValue.getValue());</span><br><span class="line">                statement.setDate(i + <span class="number">1</span>, <span class="keyword">new</span> Date(UTC.getMillisKeepLocal(DateTimeZone.getDefault(), millis)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.getType().equals(TimeType.TIME)) &#123;</span><br><span class="line">                statement.setTime(i + <span class="number">1</span>, <span class="keyword">new</span> Time((<span class="keyword">long</span>) typeAndValue.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.getType().equals(TimeWithTimeZoneType.TIME_WITH_TIME_ZONE)) &#123;</span><br><span class="line">                statement.setTime(i + <span class="number">1</span>, <span class="keyword">new</span> Time(unpackMillisUtc((<span class="keyword">long</span>) typeAndValue.getValue())));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.getType().equals(TimestampType.TIMESTAMP)) &#123;</span><br><span class="line">                statement.setTimestamp(i + <span class="number">1</span>, <span class="keyword">new</span> Timestamp((<span class="keyword">long</span>) typeAndValue.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.getType().equals(TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE)) &#123;</span><br><span class="line">                statement.setTimestamp(i + <span class="number">1</span>, <span class="keyword">new</span> Timestamp(unpackMillisUtc((<span class="keyword">long</span>) typeAndValue.getValue())));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.getType() <span class="keyword">instanceof</span> VarcharType) &#123;</span><br><span class="line">                statement.setString(i + <span class="number">1</span>, ((Slice) typeAndValue.getValue()).toStringUtf8());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Can&#x27;t handle type: &quot;</span> + typeAndValue.getType());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> statement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeAndValue</span>    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TypeAndValue</span><span class="params">(Type type, Object value)</span>   </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.type = requireNonNull(type, <span class="string">&quot;type is null&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.value = requireNonNull(value, <span class="string">&quot;value is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Type <span class="title">getType</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TypeAndValue</code>内部类的封装，有效地体现了类型与值之间的映射关系，改进了代码的可读性。事实上，以上代码还有可堪改进的空间，例如我们可以利用类的封装性，将类型判断的语句封装为方法，例如<code>isBigInt()</code>、<code>isInteger()</code>、<code>isDouble()</code>、<code>isTimeWithTimeZone()</code>、<code>isVarcharType()</code>等方法，则前面的一系列分支语句会变得更流畅一些：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; accumulator.size(); i++) &#123;</span><br><span class="line">    TypeAndValue typeAndValue = accumulator.get(i);</span><br><span class="line">    <span class="keyword">if</span> (typeAndValue.isBigInt())) &#123;</span><br><span class="line">        statement.setLong(i + <span class="number">1</span>, (<span class="keyword">long</span>) typeAndValue.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.isInteger())) &#123;</span><br><span class="line">        statement.setInt(i + <span class="number">1</span>, ((Number) typeAndValue.getValue()).intValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (typeAndValue.isSmallInt())) &#123;</span><br><span class="line">        statement.setShort(i + <span class="number">1</span>, ((Number) typeAndValue.getValue()).shortValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Can&#x27;t handle type: &quot;</span> + typeAndValue.getType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作为内部Map的Key"><a href="#作为内部Map的Key" class="headerlink" title="作为内部Map的Key"></a>作为内部Map的Key</h3><p>假定一个类的内部需要用到<code>Map</code>集合，而该集合对象又仅仅在内部使用，并不会公开给外部调用者。对于这样的Map集合，倘若Java基本类型或者字符串无法承担key的作用，就可以定义一个内部静态嵌套类作为该Map的key。注意，由于嵌套类要作为唯一不重复的key，且该类型为引用类型，因而需要重写<code>equals()</code>方法与<code>hashCode()</code>方法，视情况还应该重写<code>toString()</code>方法。</p>
<p>例如在一个类中需要创建一个Map用以存储多个指标对象，但该指标的key由两个<code>ByteBuffer</code>对象联合组成，就可以封装为一个内部嵌套类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;MetricsKey, Metric&gt; metrics = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsKey</span>    </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer row;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer family;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MetricsKey</span><span class="params">(ByteBuffer row, ByteBuffer family)</span>   </span>&#123;</span><br><span class="line">        requireNonNull(row, <span class="string">&quot;row is null&quot;</span>);</span><br><span class="line">        requireNonNull(family, <span class="string">&quot;family is null&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.row = row;</span><br><span class="line">        <span class="keyword">this</span>.family = family;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((obj == <span class="keyword">null</span>) || (getClass() != obj.getClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MetricsKey other = (MetricsKey) obj;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.row, other.row)</span><br><span class="line">                &amp;&amp; Objects.equals(<span class="keyword">this</span>.family, other.family);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(row, family);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toStringHelper(<span class="keyword">this</span>)</span><br><span class="line">                    .add(<span class="string">&quot;row&quot;</span>, <span class="keyword">new</span> String(row.array(), UTF_8))</span><br><span class="line">                    .add(<span class="string">&quot;family&quot;</span>, <span class="keyword">new</span> String(row.array(), UTF_8))</span><br><span class="line">                    .toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现外部接口"><a href="#实现外部接口" class="headerlink" title="实现外部接口"></a>实现外部接口</h3><p>当我们在一个类的内部需要使用一个外部接口，且该接口的实现逻辑又比较复杂，而在类的外部又不存在重用的可能，此时就可以定义一个私有的内部嵌套类去实现该接口。</p>
<p>在<strong>Presto框架</strong>的<code>BenchmarkSuite</code>类内部，调用了<code>AbstractBenchmark</code>类的<code>runBenchmark()</code>方法，该方法需要传入<code>BenchmarkResultHook</code>接口类型的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runBenchmark</span><span class="params">(<span class="meta">@Nullable</span> BenchmarkResultHook benchmarkResultHook)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>而<code>BenchmarkResultHook</code>是一个独立定义的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BenchmarkResultHook</span> </span>&#123;</span><br><span class="line">    <span class="function">BenchmarkResultHook <span class="title">addResults</span><span class="params">(Map&lt;String, Long&gt; results)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类的内部，定义了实现<code>BenchmarkResultHook</code>接口的内部嵌套类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingBenchmarkResultWriter</span> <span class="keyword">implements</span> <span class="title">BenchmarkResultHook</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>BenchmarkSuite</code>中就可以使用它：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">benchmark.runBenchmark(</span><br><span class="line">    <span class="keyword">new</span> ForwardingBenchmarkResultWriter(</span><br><span class="line">            ImmutableList.of(</span><br><span class="line">                    <span class="keyword">new</span> JsonBenchmarkResultWriter(jsonOut),</span><br><span class="line">                        <span class="keyword">new</span> JsonAvgBenchmarkResultWriter(jsonAvgOut),</span><br><span class="line">                        <span class="keyword">new</span> SimpleLineBenchmarkResultWriter(csvOut),</span><br><span class="line">                        <span class="keyword">new</span> OdsBenchmarkResultWriter(<span class="string">&quot;presto.benchmark.&quot;</span> + benchmark.getBenchmarkName(), odsOut)</span><br><span class="line">                )</span><br><span class="line">        )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>实现外部接口还有一种特殊情况是利用嵌套类实现一个函数接口。虽然在多数情况下，当我们在使用函数接口时，会使用Lambda表达式来实现该接口，其本质其实是一个函数。然而，当一个函数的实现相对比较复杂，且有可能被类的内部多处重用时，就不能使用Lambda表达式了。可是针对这种情形，确乎又没有必要定义单独的类去实现该函数接口，这时就是嵌套类的用武之地了。</p>
<p>例如在<strong>Presto框架</strong>的<code>HivePageSource</code>类中有一个方法<code>createCoercer()</code>，它返回的类型是一个函数接口类型<code>Function&lt;Block, Block&gt;</code>。方法的实现会根据hive的类型决定返回的函数究竟是什么。目前支持以下四种情形：</p>
<ul>
<li>Integer数字转换为Varchar</li>
<li>Varchar转换为Integer数字</li>
<li>Integer数字的提升</li>
<li>Float转换为Double</li>
</ul>
<p>这四种情形对应的Coercer其实都是一个函数<code>Block -&gt; Block</code>，但这个转换的逻辑比较复杂，尤其针对“Integer数字的提升”情形，还存在多个条件分支的判断。于是，Presto就在<code>HivePageSource</code>定义了如下四个嵌套类，并且都实现了函数接口<code>Function&lt;Block, Block&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HivePageSource</span> <span class="keyword">implements</span> <span class="title">ConnectorPageSource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerNumberUpscaleCoercer</span> <span class="keyword">implements</span> <span class="title">Function</span>&lt;<span class="title">Block</span>, <span class="title">Block</span>&gt;  </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Type fromType;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Type toType;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IntegerNumberUpscaleCoercer</span><span class="params">(Type fromType, Type toType)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.fromType = requireNonNull(fromType, <span class="string">&quot;fromType is null&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.toType = requireNonNull(toType, <span class="string">&quot;toType is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Block <span class="title">apply</span><span class="params">(Block block)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerNumberToVarcharCoercer</span> <span class="keyword">implements</span> <span class="title">Function</span>&lt;<span class="title">Block</span>, <span class="title">Block</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Type fromType;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Type toType;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IntegerNumberToVarcharCoercer</span><span class="params">(Type fromType, Type toType)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.fromType = requireNonNull(fromType, <span class="string">&quot;fromType is null&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.toType = requireNonNull(toType, <span class="string">&quot;toType is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Block <span class="title">apply</span><span class="params">(Block block)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VarcharToIntegerNumberCoercer</span> <span class="keyword">implements</span> <span class="title">Function</span>&lt;<span class="title">Block</span>, <span class="title">Block</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Type fromType;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Type toType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> minValue;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxValue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">VarcharToIntegerNumberCoercer</span><span class="params">(Type fromType, Type toType)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//... </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Block <span class="title">apply</span><span class="params">(Block block)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FloatToDoubleCoercer</span> <span class="keyword">implements</span> <span class="title">Function</span>&lt;<span class="title">Block</span>, <span class="title">Block</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Block <span class="title">apply</span><span class="params">(Block block)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封装内部常量"><a href="#封装内部常量" class="headerlink" title="封装内部常量"></a>封装内部常量</h3><p>如果一个类的内部需要用到大量常量，而这些常量却没有重用的可能，换言之，这些常量无需公开，仅作为内部使用。这时，我们可以通过嵌套类对这些常量进行归类，既便于调用，又提高了可读性，形成一种组织良好的代码结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetadataLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IpAddressConstants</span>    </span>&#123;</span><br><span class="line">        <span class="comment">// IPv4: 255.255.255.255 - 15 characters</span></span><br><span class="line">        <span class="comment">// IPv6: FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF - 39 characters</span></span><br><span class="line">        <span class="comment">// IPv4 embedded into IPv6: FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:255.255.255.255 - 45 characters</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IPV4_STRING_MAX_LENGTH = <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IPV6_STRING_MAX_LENGTH = <span class="number">39</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EMBEDDED_IP_ADDRESS_STRING_MAX_LENGTH = <span class="number">45</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeConstants</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BigintType BIGINT = <span class="keyword">new</span> BigintType();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BooleanType BOOLEAN = <span class="keyword">new</span> BooleanType();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DoubleType DOUBLE = <span class="keyword">new</span> DoubleType();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TimestampType TIMESTAMP = <span class="keyword">new</span> TimestampType();            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部重用"><a href="#内部重用" class="headerlink" title="内部重用"></a>内部重用</h3><p>有些重用代码块，它的重用单元比方法要多一些，却又不成其为单独的类，因为它只在类的内部被重用，这时就可以将其定义为嵌套类，以利于内部重用。</p>
<p>例如，在一个并发处理程序的<code>Query</code>类中，我们需要根据一个布尔标志来判断当前线程是否需要中断。中断线程的逻辑无法封装在一个私有方法中。如果将这个逻辑直接写到调用方法中，有可能干扰到主要逻辑的阅读，为了提供代码的可读性，<code>Query</code>类定义了一个内部嵌套类<code>ThreadInterruptor</code>，用以封装中断当前线程的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean ignoreUserInterrupt = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean userAbortedQuery = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pageOutput</span><span class="params">(OutputFormat format, List&lt;String&gt; fieldNames)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Pager pager = Pager.create(); </span><br><span class="line">              ThreadInterruptor clientThread = <span class="keyword">new</span> ThreadInterruptor(); </span><br><span class="line">              Writer writer = createWriter(pager); </span><br><span class="line">              OutputHandler handler = createOutputHandler(format, writer, filedNames)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pager.isNullPager()) &#123;</span><br><span class="line">                ignoreUserInterrupt.set(<span class="keyword">true</span>);</span><br><span class="line">                pager.getFinishFuture().thenRun(() -&gt; &#123;</span><br><span class="line">                    userAbortedQuery.set(<span class="keyword">true</span>);</span><br><span class="line">                    ignoreUserInterrupt.set(<span class="keyword">false</span>);</span><br><span class="line">                    clientThread.interrupt();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            handler.processRow(client);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (userAbortedQuery.get() &amp;&amp; !(e instanceOf QueryAbortedException)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> QueryAbortedException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterruptor</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean processing = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (processing.get()) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            processing.set(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，由于<code>ThreadInterruptor</code>对象要放到try语句块中，因而需要实现<code>Closeable</code>接口，且需要通过try调用<code>close()</code>方法时，将<code>processing</code>标志变量置为<code>false</code>。</p>
<h3 id="内部异常"><a href="#内部异常" class="headerlink" title="内部异常"></a>内部异常</h3><p>这算是内部重用的一种特殊情形，即对异常的内部重用。当我们需要抛出一个异常，且希望抛出的消息能够体现该异常场景，又或者该异常需要携带的内容不仅仅包括消息或错误原因时，都需要我们自定义异常。倘若该自定义异常没有外部公开的必要，就可以通过嵌套类定义一个内部异常。</p>
<p>例如我们希望一个异常在抛出时能够携带类型信息，且该异常仅为内部使用，就可以这样来定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailureInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FailureException</span></span></span><br><span class="line"><span class="class">            <span class="keyword">extends</span> <span class="title">RuntimeException</span>    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String type;</span><br><span class="line"></span><br><span class="line">        FailureException(String type, String message, FailureException cause)   &#123;</span><br><span class="line">            <span class="keyword">super</span>(message, cause, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">this</span>.type = requireNonNull(type, <span class="string">&quot;type is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>    </span>&#123;</span><br><span class="line">            String message = getMessage();</span><br><span class="line">            <span class="keyword">if</span> (message != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> type + <span class="string">&quot;: &quot;</span> + message;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> type;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论嵌套类的使用形式如何多样，体现的价值又如何地梅兰秋菊各擅胜场，根本的原理还是逃不开面向对象设计的基本思想，即通过封装体现内聚的概念，从而利于重用，应对变化，或者就是单纯地组织代码，让代码的结构变得更加清晰。尤其是在相对复杂的真实项目中，如何控制对象类型的数量，又不至于违背“单一职责原则”，使用嵌套类是一条不错的中间路线选择。</p>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Design</tag>
        <tag>Design Pattern</tag>
        <tag>Java</tag>
        <tag>Open Source</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么我们需要正确地领域建模</title>
    <url>/why-do-we-need-domain-modeling/</url>
    <content><![CDATA[<img src="/why-do-we-need-domain-modeling/ddd-course.jpg" class="">

<p><strong>广而告知：</strong>我在<a href="https://gitbook.cn/gitchat/column/5b3235082ab5224deb750e02">GitChat的领域驱动战略设计实践达人课</a>已经发布，目前正在进入预售期。打开链接即可查看与订阅。同时，我还将在我的个人公众号上做抽奖活动，对于积极评论者会有本次课程的免费码赠送，敬请期待！</p>
<p>在领域驱动设计过程中，<strong>正确地进行领域建模</strong>是至为关键的环节。如果我们没有能够从业务需求中发现正确的领域概念，就可能导致职责的分配不合理，业务流程不清晰，出现没有任何领域行为的贫血对象，甚至做出错误的设计决策。</p>
<span id="more"></span>

<h3 id="最初的实现"><a href="#最初的实现" class="headerlink" title="最初的实现"></a>最初的实现</h3><p>在一个结算系统中，业务需求要求导入一个结算账单模板的Excel文档，然后通过账单号查询该模板需要填充的变量值，生成并导出最终需要的结算账单。结算账单有多种，例如内部结算账单等。不同账单的模板并不相同，需要填充的变量值也不相同。</p>
<p>团队确实进行了领域建模，发现了如下的几个领域概念以及对应的服务和资源库对象：</p>
<ul>
<li>InternalSettlementBill</li>
<li>InternalSettlementBillRepository</li>
<li>TemplateReplacement</li>
<li>BaseBillReviewExportTemplate</li>
<li>InternalSettlementBillService</li>
<li>BillReviewService</li>
</ul>
<p>为了方便大家对这个设计有直观认识，我先贴出这些关键类型的实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> settlement.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalSettlementBill</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String billNumber;</span><br><span class="line">    <span class="keyword">private</span> String newAndOldBillNumber;</span><br><span class="line">    <span class="keyword">private</span> String flightIdentity;</span><br><span class="line">    <span class="keyword">private</span> String flightNumber;</span><br><span class="line">    <span class="keyword">private</span> String flightRoute;</span><br><span class="line">    <span class="keyword">private</span> String scheduledDate;</span><br><span class="line">    <span class="keyword">private</span> String passengerClass;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Passenger&gt; passengers;</span><br><span class="line">    <span class="keyword">private</span> String serviceReason;</span><br><span class="line">    <span class="keyword">private</span> List&lt;CostDetail&gt; costDetails;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal totalCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InternalSettlementBillRepository</span> </span>&#123;</span><br><span class="line">    <span class="function">InternalSettlementBill <span class="title">queryByBillNumber</span><span class="params">(String billNumber)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> settlement.infrastructure.file;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.data;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateReplacement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rowIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cellNum;</span><br><span class="line">    <span class="keyword">private</span> String replaceValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pakcage settlement.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> settlement.infrastructure.file.TemplateReplacement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseBillReviewExportTemplate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> List&lt;TemplateReplacement&gt; <span class="title">queryAndComposeTemplateReplacementsBy</span><span class="params">(String billNumber)</span> </span>&#123;</span><br><span class="line">        T t = queryFilledDataBy(billNumber);</span><br><span class="line">        <span class="keyword">return</span> composeTemplateReplacements(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">queryFilledDataBy</span><span class="params">(String billNumber)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;TemplateReplacement&gt; <span class="title">composeTemplateReplacements</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pakcage settlement.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> settlement.infrastructure.file.TemplateReplacement;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalSettlementBillService</span> <span class="keyword">extends</span> <span class="title">BaseBillReviewExportTemplate</span>&lt;<span class="title">InternalSettlementBill</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> InternalSettlementBillRepository internalSettlementBillRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> InternalSettlementBill <span class="title">queryFilledDataBy</span><span class="params">(String billNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> internalSettlementBillRepository.queryByBillNumber(billNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;TemplateReplacement&gt; <span class="title">composeTemplateReplacements</span><span class="params">(InternalSettlementBill t)</span> </span>&#123;</span><br><span class="line">        List&lt;TemplateReplacement&gt; templateReplacements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        templateReplacements.add(<span class="keyword">new</span> TemplateReplacement(<span class="number">0</span>, <span class="number">0</span>, t.getNewAndOldBillNumber()));</span><br><span class="line">        templateReplacements.add(<span class="keyword">new</span> TemplateReplacement(<span class="number">1</span>, <span class="number">0</span>, t.getFlightIdentity()));</span><br><span class="line">        templateReplacements.add(<span class="keyword">new</span> TemplateReplacement(<span class="number">1</span>, <span class="number">2</span>, t.getFlightRoute()));</span><br><span class="line">        <span class="keyword">return</span> templateReplacements;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> settlement.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> settlement.infrastructure.file.FileDownloader;</span><br><span class="line"><span class="keyword">import</span> settlement.infrastructure.file.PoiUtils;</span><br><span class="line"><span class="keyword">import</span> settlement.infrastructure.file.TemplateReplacement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hssf.usermodel.HSSFWorkbook;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillReviewService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_REPLACE_PATTERN = <span class="string">&quot;@replace&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SHEET_INDEX = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;file-path.bill-templates-dir&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String billTemplatesDirPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PoiUtils poiUtils;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> FileDownloader fileDownloader;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> InternalSettlementBillService internalSettlementBillService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ExportBillReviewConfiguration configuration;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportBillReviewByTemplate</span><span class="params">(HttpServletResponse response, String billNumber, String templateName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String className = fetchClassNameFromConfigBy(templateName);</span><br><span class="line">            List&lt;TemplateReplacement&gt; replacements = templateReplacementsBy(billNumber, className);</span><br><span class="line"></span><br><span class="line">            HSSFWorkbook workbook = poiUtils.getHssfWorkbook(billTemplatesDirPath + templateName);</span><br><span class="line">            poiUtils.fillCells(workbook, DEFAULT_SHEET_INDEX, DEFAULT_REPLACE_PATTERN, replacements);</span><br><span class="line"></span><br><span class="line">            fileDownloader.downloadHSSFFile(response, workbook, templateName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Export bill review by template failed, templateName: &#123;&#125;&quot;</span>, templateName);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;TemplateReplacement&gt; <span class="title">templateReplacementsBy</span><span class="params">(String billNumber, String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (className) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;InternalSettlementBill&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> internalSettlementBillService.queryAndComposeTemplateReplacementsBy(billNumber);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">fetchClassNameFromConfigBy</span><span class="params">(String templateName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ExportBillReviewConfiguration.Item item : configuration.getItems()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.getTemplateName().equals(templateName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> item.getClassName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;can not found className by templateName in configuration file&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> settlement.web.controllers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> settlement.domain.*;</span><br><span class="line"><span class="keyword">import</span> settlement.web.model.ExportBillReviewRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/bill-review&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillReviewController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BillReviewService billReviewService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/export-template&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportBillReviewByTemplate</span><span class="params">(HttpServletResponse response, <span class="meta">@RequestBody</span> ExportBillReviewRequest request)</span> </span>&#123;</span><br><span class="line">        billReviewService.exportBillReviewByTemplate(response, request.getBillNumber(), request.getTemplateName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这些类中，领域层的<code>InternalSettlementBill</code>表达的是“内部结算账单”领域概念，显然，如代码所示，这个对象是一个典型的贫血对象。<code>BaseBillReviewExportTemplate</code>类是一个抽象类，<code>InternalSettlementBillService</code>是继承它的子类。团队开发人员运用了模板方法模式，<code>BaseBillReviewExportTemplate</code>是获取各种结算账单的<code>TemplateReplacement</code>的一个抽象，因为开发人员发现这个过程是通用的：</p>
<ul>
<li>通过billNumber查询结算账单</li>
<li>根据结算账单的值组装导出账单需要的模板替换对象</li>
</ul>
<h3 id="提炼领域知识"><a href="#提炼领域知识" class="headerlink" title="提炼领域知识"></a>提炼领域知识</h3><p><code>BaseBillReviewExportTemplate</code>是一个领域服务，但它其实有一个很糟糕的命名，让人无法看懂它到底承担了什么职责？从命名看，它蕴含了多个概念：bill、review、export、template。究竟要做什么？是账单评阅的导出模板？还是导出账单评阅的模板？它代表了模板的名词概念，还是代表导出的领域行为？真是让人丈二和尚摸不着头脑。其实，阅读其代码实现，发现这个类要做的不过就是获得结算账单的所谓“模板替换（TemplateReplacement）”对象罢了？</p>
<p><code>TemplateReplacement</code>表达的是什么概念呢？通过和团队成员沟通需求，结合代码我梳理出要实现的业务逻辑：</p>
<ul>
<li>用户首先导入一个结算账单模板的Excel工作薄；</li>
<li>Excel工作薄模板中对应的单元格中定义了一些变量值；系统需要从数据库中读取结算账单的信息，然后基于结算账单信息中的值去替换定义在模板中的这些变量；</li>
<li>导出替换了变量值的Excel工作薄。</li>
</ul>
<p>显然，替换模板中的变量值是我们期望完成的行为，其本质其实应该是一个模板变量：<code>TemplateVariable</code>。这个对象属于领域层的领域概念，不应该被定义在基础设施层。</p>
<p>如此，<code>BaseBillReviewExportTemplate</code>这个服务的命名就真可以说是名实不副了，不如更名为<code>BaseBillTemplateVariablesComposer</code>。但仔细看它的实现，我发现它不过就是通过一个Repository获得结算账单，再用结算账单中的对应值去组装模板变量。这个组装模板变量的行为放在这个服务中合适吗？遵循“信息专家模式”，<code>InternalSettlementBill</code>自身就具备了组装模板变量的信息，它才是承担组装职责的最佳专家啊！于是，我们可以转移职责：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> settlement.domain;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalSettlementBill</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String billNumber;</span><br><span class="line">    <span class="keyword">private</span> String newAndOldBillNumber;</span><br><span class="line">    <span class="keyword">private</span> String flightIdentity;</span><br><span class="line">    <span class="keyword">private</span> String flightNumber;</span><br><span class="line">    <span class="keyword">private</span> String flightRoute;</span><br><span class="line">    <span class="keyword">private</span> String scheduledDate;</span><br><span class="line">    <span class="keyword">private</span> String passengerClass;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Passenger&gt; passengers;</span><br><span class="line">    <span class="keyword">private</span> String serviceReason;</span><br><span class="line">    <span class="keyword">private</span> List&lt;CostDetail&gt; costDetails;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal totalCost;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TemplateVariable&gt; <span class="title">composeVariables</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Lists.newArrayList(</span><br><span class="line">            <span class="keyword">new</span> TemplateVariable(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.newAndOldBillNumber()),</span><br><span class="line">            <span class="keyword">new</span> TemplateVariable(<span class="number">1</span>, <span class="number">0</span>, <span class="keyword">this</span>.flightIdentity()),</span><br><span class="line">            <span class="keyword">new</span> TemplateVariable(<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">this</span>.flightRoute())</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于不同的结算模板都提供了不同的模板变量，我们就可以为其定义一个抽象的结算模板类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> settlement.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SettlementBill</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;TemplateVariable&gt; <span class="title">composeVariables</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> settlement.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalSettlementBill</span> <span class="keyword">implements</span> <span class="title">SettlementBill</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在转移了组装模板变量的职责后，我已经看不出<code>BaseBillTemplateVariablesComposer</code>这个服务还有什么存在必要了！是的，它还承担了调用Repository去获得结算账单的职责，但在转移了组装模板变量的职责后，这个服务已经被弱化为只剩下查询职责了。这个查询结算账单的职责不是Repository提供的么？再对这个查询功能做一次封装有何意义？所以，在<code>InternalSettlementBill</code>摆脱“贫血对象”的身份后，看起来很酷的模板方法模式就变得没有任何价值了！</p>
<h3 id="保持清晰的领域服务"><a href="#保持清晰的领域服务" class="headerlink" title="保持清晰的领域服务"></a>保持清晰的领域服务</h3><p>再来看服务<code>BillReviewService</code>服务。从实现内容看，它才是真正负责导出结算账单的服务。这个服务的类名既含糊，实现代码又混乱，看起来它根本就不是一个纯粹的业务服务，因为它将业务逻辑与技术实现搅在了一起：既有Excel工作薄的获取，又有通过poi框架实现对单元格数据的填充，还有文件的下载，同时还通过结算账单获得了需要填充的模板变量值。</p>
<p>之所以会出现如此混乱的局面，除了没有有效地将技术实现与业务逻辑通过抽象去隔离之外，<strong>最关键的还是没有正确地建立领域模型</strong>。实际上，这里的<strong>结算账单模板</strong>不正是我们要操作的领域对象吗？实际上，我们要完成的业务功能是<strong>填充以及导出结算账单模板，而不是填充工作薄的单元格，自然也不是下载工作薄文件</strong>。所谓的“工作薄”概念，其实是实现层面的细节。</p>
<p>为保障设计的纯粹性，我们理当将<strong>结算账单模板</strong>定义为一个POJO类型的领域实体对象。即使需要将其导出为Excel工作薄，我们也可以令其持有数据，然后再将数据写入到工作薄。但是，由于结算账单模板的部分内容是通过模板文件直接导入的，除了需要替换的模板变量值之外，其余内容无需重新写入。如果硬要将其定义为纯粹的领域对象，就需要记录账单所有值在工作薄中的坐标，以便于在生成模板文件时正确地填充值；然而，这个模板的部分值在工作薄文件中已经存在了，再做一次无谓的填充就显得多余了。故而，<strong>我们需要做一个设计妥协</strong>，直接将poi框架的<code>HSSFWorkbook</code>作为结算账单模板对象内部持有的属性。让领域层依赖poi框架使得我们的领域模型不再纯粹，但为了技术实现的便利性，偶尔退让一步，也未为不可，只要我们能守住底线：<strong>保持系统架构的清晰层次</strong>。</p>
<p>一旦将工作薄对象赋予结算账单模板对象，则模板自身就不再有多种结算账单类别，因为它们的区别在于workbook。因此，我们没有必要为各种结算账单定义对应的模板对象，只需一个<code>SettlementBillTemplate</code>即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> settlement.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hsf.usermodel.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettlementBillTemplate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HSSFWorkbook workbook;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sheetIndex;</span><br><span class="line">    <span class="keyword">private</span> String replacePattern;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SettlementBillTemplate</span><span class="params">(HSSFWorkbook workbook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(workbook, <span class="number">0</span>, <span class="string">&quot;@replace&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SettlementBillTemplate</span><span class="params">(HSSFWorkbook workbook, <span class="keyword">int</span> sheetIndex, String replacePattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.workbook = workbook;</span><br><span class="line">        <span class="keyword">this</span>.sheetIndex = sheetIndex;</span><br><span class="line">        <span class="keyword">this</span>.replacePattern = replacePattern;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然<code>SettlementBillTemplate</code>已经拥有了工作薄对象，为何不将填充模板变量值的功能赋予它呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettlementBillTemplate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillWith</span><span class="params">(SettlementBill bill)</span> </span>&#123;</span><br><span class="line">        HSSFSheet sheet = hssfWorkbook.getSheetAt(sheetIndex);</span><br><span class="line">        bill.composeVariables().foreach( v -&gt; &#123;</span><br><span class="line">            HSSFCell cell = sheet.getRow(v.getRowIndex()).getCell(v.getCellNum());</span><br><span class="line">            String cellValue = cell.getStringCellValue();</span><br><span class="line">            String replaceValue = v.getReplaceValue();</span><br><span class="line">            <span class="keyword">if</span> (replaceValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;&#123;&#125; -&gt; &#123;&#125; 替换值为空，未从数据库中查出相应字段值&quot;</span>, cellValue, replaceValue);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            logger.info(<span class="string">&quot;&#123;&#125; -&gt; &#123;&#125;&quot;</span>, cellValue, replaceValue);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cellValue.toLowerCase().contains(replacePattern)) &#123;</span><br><span class="line">                cell.setCellValue(cellValue.replace(replacePattern, replaceValue));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cell.setCellValue(replaceValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，组装模板以及模板变量的工作已经完成，剩下的就是导出模板了。那么，谁该拥有导出模板的能力呢？虽然要导出的数据是<code>SettlementBillTemplate</code>拥有的，但<strong>它并不具备读取与下载工作薄文件的能力</strong>，既然如此，就只能将其放到领域服务。<strong>你看，我在分配表达领域逻辑的职责时，是将领域服务排在最后的顺序。</strong></p>
<p>在此之前，我们还需要分离业务逻辑与技术实现。什么是业务逻辑？组装模板变量，组装模板以及导出模板都是业务逻辑，而读/写工作薄文件则是技术实现。既然如此，工作薄文件的读写职责就应该分配给基础设施层，然后在interfaces模块中定义它们的抽象接口。<strong>注：</strong>改进后的代码采用的代码结构皆以我的推荐为准。例如下面的接口定义是放在interfaces/file包中，实现放在gateways/file包中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> settlement.interfaces.file;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hssf.usermodel.HSSFWorkbook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkbookReader</span> </span>&#123;</span><br><span class="line">    <span class="function">HSSFWorkbook <span class="title">readFrom</span><span class="params">(String templateName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorkbookWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(HSSFWorkbook workbook, String targetPath)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> settlement.gateways.file;</span><br><span class="line"><span class="keyword">import</span> settlement.interfaces.file.WorkbookReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hssf.usermodel.HSSFWorkbook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelWorkbookReader</span> <span class="keyword">implements</span> <span class="title">WorkbookReader</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> settlement.gateways.file;</span><br><span class="line"><span class="keyword">import</span> settlement.interfaces.file.WorkbookWriter;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hssf.usermodel.HSSFWorkbook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelWorkbookWriter</span> <span class="keyword">implements</span> <span class="title">WorkbookWriter</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决资源库多态的问题"><a href="#解决资源库多态的问题" class="headerlink" title="解决资源库多态的问题"></a>解决资源库多态的问题</h3><p>还有一个问题没有解决，就是不同的结算账单是通过不同的Repository获得的。虽然模板已经没有类型的区别了，但用组装模板的模板变量值确实是不相同的。我们需要根据传入的<code>templateName</code>决定获得什么样的结算账单对象。但是，我们之前已经为<code>InternalSettlementBill</code>定义了对应的Repository，且它被定义为一个接口。是否可以将这个接口作为服务的属性，交给依赖注入去注入实现呢？例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettlementBillTemplateExporter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> InternalSettlementBillRepository repository;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是不对的。因为采用这样的定义，就意味着<code>SettlementBillTemplateExporter</code>服务只能查询<code>InternalSettlementBill</code>。要解决这个问题，似乎可以为资源库查询所有结算账单的行为定义一个统一接口，如<code>SettlementBillFinder</code>接口。然而，这一改进还是不能解决问题，因为决定实例化哪个Repository，是由调用者传递的<code>templateName</code>决定的。</p>
<p>在进行领域驱动设计时，为了隔离业务逻辑与技术实现，一般建议对技术实现尽可能做抽象，例如定义抽象的Repository接口，然后再利用依赖注入（Dependency Injection）完成对具体实现的注入。当我们使用框架来完成依赖注入时，就要求领域层的领域对象包括Repository、Service等对象都将由IoC框架来管理生命周期。这些IoC框架在带来依赖管理的便利时，也给我们的设计施加了一些约束。</p>
<p>一种解决办法是为资源库引入静态工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> settlement.repositories;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SettlementBillFinder</span> </span>&#123;</span><br><span class="line">    <span class="function">SettlementBill <span class="title">settlementBillBy</span><span class="params">(String billNumber)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> settlement.repositories;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InternalSettlementBillRepository</span> <span class="keyword">extends</span> <span class="title">SettlementBillFinder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// other methods;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> settlement.domain;</span><br><span class="line"><span class="keyword">import</span> settlement.repositories.SettlementBillFinder;</span><br><span class="line"><span class="keyword">import</span> settlement.gateways.persistence.InternalSettlementBillMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettlementBillFinderFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SettlementBillFinder <span class="title">create</span><span class="params">(String templateName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (templateName.toLowerCase()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;internal&quot;</span>: </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> InternalSettlementBillMapper();</span><br><span class="line">            <span class="comment">// 其余分支略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，这样的设计是有问题的，因为它破坏了各层的职责。如上所示的<code>SettlementBillFinderFactory</code>是一个静态工厂，它需要创建具体的资源库对象，就意味着它依赖了基础设施层的类，即放在gateways/persistence中的InternalSettlementBillMapper类，而工厂自身却属于领域层。倘若采用这种做法的话，前面运用的依赖注入方法就变得没有意义了。<strong>在领域驱动设计的实现时，我们确实需要时时刻刻保持谨慎，防守住因为某种实现原因导致对整洁架构的破坏。</strong></p>
<p>要做到这一点，可以考虑使用工厂方法模式，为工厂再定义一个抽象，转而将实现放到基础设施层。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> settlement.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SettlementBillFinderFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">SettlementBillFinder <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可惜，这样一个多态的工厂让我们又走回了老路，因为需要调用者根据<code>templateName</code>决定使用哪一个具体工厂！这与通过<code>templateName</code>确定选择使用哪一个Repository又有何区别呢？反而引入了不必要的间接。</p>
<p>如果使用Spring来管理依赖注入，有一种做法是在服务中定义一个<code>HashMap&lt;String, String&gt;</code>，其中key值对应模板名，value值对应<code>SettlementBillFinder</code>实现子类的类名，然后在配置文件中配置这些映射信息。当服务传入一个<code>templateName</code>时，在这个hashmap中搜索获得的子类类型，然后利用反射来创建这些类。这一方法看起来保证了可扩展性，但实在太繁琐，太复杂，且反射的使用也在一定程度影响了性能。</p>
<p>有两种更简单的办法：</p>
<ul>
<li>让Repository的实现子类自行判断：如果我们将结算账单视为一个领域概念，就应该为其只抽象一个<code>SettlementBillRepository</code>。即无需为每种结算账单提供专有的资源库抽象。在定义Repository的查询方法时，将<code>templateName</code>与<code>billNumber</code>都视为查询的条件，然后在实现类中根据<code>templateName</code>去查询不同的表，获得不同的结算账单领域对象。这个方法胜在简单，但较为死板不易扩展。</li>
<li>采用惯例优于配置（CoC）：依然将<code>templateName</code>作为服务方法的参数，也依旧提供一个<code>SettlementBillRepository</code>抽象，但在基础设施层为每个结算账单提供一个实现，且实现类遵循命名规则，即以<code>&#123;templateName&#125;</code>名字（单词首字母大写）为前缀，后缀统一为<code>SettlementBillRepository</code>，这样就可以基于规则组装类的类型名，再通过反射创建资源库对象。这一方法胜在能扩展，但依旧引入了反射。</li>
</ul>
<p>这里我选择使用最简单的第一种方案，于是导出服务就变为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> settlement.domain;</span><br><span class="line"><span class="keyword">import</span> settlement.repositories.SettlementBillRepository;</span><br><span class="line"><span class="keyword">import</span> settlement.interfaces.file.WorkbookReader;</span><br><span class="line"><span class="keyword">import</span> settlement.interfaces.file.WorkbookWriter;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hssf.usermodel.HSSFWorkbook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettlementBillTemplateExporter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="keyword">private</span> WorkbookReader reader;    </span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="keyword">private</span> WorkbookWriter writer;</span><br><span class="line">    <span class="meta">@Repository</span></span><br><span class="line">    <span class="keyword">private</span> SettlementBillRepository repository;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">(HttpServletResponse response, String templateName, String billNumber)</span> </span>&#123;</span><br><span class="line">        SettlementBill bill = repository.settlementBillBy(templateName, billNumber);</span><br><span class="line">        SettlementBillTemplate template = <span class="keyword">new</span> SettlementBillTemplate(reader.readFrom(templateName));</span><br><span class="line">        template.fillWith(bill);</span><br><span class="line">        writer.writeTo(response, template, templateName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="尽可能保证领域层的整洁"><a href="#尽可能保证领域层的整洁" class="headerlink" title="尽可能保证领域层的整洁"></a>尽可能保证领域层的整洁</h3><p>事情还未结束，因为在领域服务的方法中出现了“恼人”的<code>HttpServletReponse</code>，它属于servlet包的核心对象。在干净的领域层中，怎么能容忍它的出现呢？（当然poi框架的依赖算是例外，前面已经分析过。）仔细分析，我发现在导出逻辑的实现中，其实仅仅用到了<code>HttpServletResponse</code>对象的<code>getOutputStream()</code>方法，返回的<code>OutputStream</code>对象则是JDK中<code>java.io</code>库中的一个类。既然如此，我们可以在领域层为这一需求提供一个抽象，例如定义接口<code>OutputStreamProvider</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> settlement.domain;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OutputStreamProvider</span> </span>&#123;</span><br><span class="line">    <span class="function">OutputStream <span class="title">getOutputStream</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在的领域服务就可以使用在领域层中自定义的<code>OutputStreamProvider</code>抽象。此外，还得加上一些异常处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> settlement.domain;</span><br><span class="line"><span class="keyword">import</span> settlement.domain.exceptions.*;</span><br><span class="line"><span class="keyword">import</span> settlement.repositories.SettlementBillRepository;</span><br><span class="line"><span class="keyword">import</span> settlement.interfaces.file.WorkbookReader;</span><br><span class="line"><span class="keyword">import</span> settlement.interfaces.file.WorkbookWriter;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hssf.usermodel.HSSFWorkbook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettlementBillTemplateExporter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="keyword">private</span> WorkbookReader reader;    </span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="keyword">private</span> WorkbookWriter writer;</span><br><span class="line">    <span class="meta">@Repository</span></span><br><span class="line">    <span class="keyword">private</span> SettlementBillRepository repository;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">(OutputStreamProvider streamProvider, String templateName, String billNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SettlementBill bill = repository.settlementBillBy(templateName, billNumber);</span><br><span class="line">            SettlementBillTemplate template = <span class="keyword">new</span> SettlementBillTemplate(reader.readFrom(templateName));</span><br><span class="line">            template.fillWith(bill);</span><br><span class="line">            writer.writeTo(streamProvider, template, templateName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DownloadTemplateFileException | OpenTemplateFileException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TemplateFileFailedException(ex.getMessage(), ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用服务的定义就变得简单了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> settlement.application;</span><br><span class="line"><span class="keyword">import</span> settlement.domain.SettlementBillTemplateExporter;</span><br><span class="line"><span class="keyword">import</span> settlement.domain.OutputStreamProvider;</span><br><span class="line"><span class="keyword">import</span> settlement.domain.exceptions.TemplateFileFailedException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SettlementBillAppService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Service</span></span><br><span class="line">    <span class="keyword">private</span> SettlementBillTemplateExporter exporter;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportByTemplate</span><span class="params">(OutputStreamProvider streamProvider, String templateName, String billNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exporter.export(streamProvider, templateName, billNumber);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TemplateFileFailedException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationException(<span class="string">&quot;Failed to export settlement bill file.&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的，控制器的实现修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> settlement.gateways.controllers;</span><br><span class="line"><span class="keyword">import</span> settlement.application.SettlementBillAppService;</span><br><span class="line"><span class="keyword">import</span> settlement.gateways.controllers.model.ExportBillReviewRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/bill-review&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillTemplateController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SettlementBillAppService settlementBillService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/export-template&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportBillReviewByTemplate</span><span class="params">(HttpServletResponse response, <span class="meta">@RequestBody</span> ExportBillReviewRequest request)</span> </span>&#123;</span><br><span class="line">        exportService.exportByTemplate(response::getOutputStream, request.getTemplateName(), request.getBillNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码的层次结构"><a href="#代码的层次结构" class="headerlink" title="代码的层次结构"></a>代码的层次结构</h3><p>如上代码的层次结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">settlement</span><br><span class="line">    - application</span><br><span class="line">        - SettlementBillAppService</span><br><span class="line">    - domain</span><br><span class="line">        - SettlementBill</span><br><span class="line">        - TemplateVariable</span><br><span class="line">        - InternalSettlementBill</span><br><span class="line">        - SettlementBillTemplate</span><br><span class="line">        - SettlementBillTemplateExporter</span><br><span class="line">        - OutputStreamProvider</span><br><span class="line">        - exceptions</span><br><span class="line">            - TemplateFileFailedException </span><br><span class="line">            - DownloadTemplateFileException</span><br><span class="line">            - OpenTemplateFileException</span><br><span class="line">    - repositories（persistence技术实现的抽象）</span><br><span class="line">        - SettlementBillRepository</span><br><span class="line">    - interfaces（技术实现层面的抽象）</span><br><span class="line">        - file</span><br><span class="line">            - WorkbookReader</span><br><span class="line">            - WorkbookWriter</span><br><span class="line">    - gateways（包含技术实现层面）</span><br><span class="line">        - persistence</span><br><span class="line">            - SettlementBillMapper</span><br><span class="line">        - file</span><br><span class="line">            - ExcelWorkbookReader</span><br><span class="line">            - ExcelWorkbookWriter</span><br><span class="line">        - controllers</span><br><span class="line">            - BillTemplateController </span><br><span class="line">            - model</span><br><span class="line">                - ExportBillReviewRequest </span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上对代码的逐步演化，我们就此可以发现原来代码的诸多问题。这些问题往往是许多领域驱动设计新手容易犯的错误，包括：</p>
<ul>
<li>未能正确地表达领域知识</li>
<li>贫血的领域模型</li>
<li>层次不清，对DDD的分层架构理解混乱</li>
<li>领域服务与应用服务概念混乱</li>
<li>业务逻辑与技术实现纠缠在一起</li>
</ul>
<p>回归这些问题的原点，其实还是在于<strong>团队没有正确地进行领域建模</strong>。如果还要继续深究，则在于<strong>团队没有为领域建立统一语言</strong>。我们看前面对模板导出业务的分析，每一个步骤都没有正确表达业务逻辑，因而获得的领域对象也是不正确的。又由于没有建立统一语言，导致对类和方法的命名都不能很好地体现领域概念，甚至导致某些表达领域概念的类被错误地放在了基础设施层。当我们在运用面向对象编程范式来实现领域驱动设计时，对OO思想的理解偏差与知识缺乏也反映到了代码的实现上，尤其是对“贫血模型”的理解，对职责分配的认知，都会直接反映到代码层面上。</p>
<p>最后，如果团队成员没有清晰地理解分层架构各层的含义，以及为何要引入分层架构，就无法守住分层架构各层的边界，最后就会导致业务复杂度与技术复杂度的混搭。若系统简单还好说，一旦系统的业务复杂度增加带来系统规模的扩大，不紧守架构层次的边界，就可能导致我们事先建立的分层架构名存实亡，代码变成大泥球，重新回归到太初的混沌世界。</p>
<h3 id="达人课专属海报"><a href="#达人课专属海报" class="headerlink" title="达人课专属海报"></a>达人课专属海报</h3><p>下图为《领域驱动战略设计实践》达人课的专属海报，可微信扫描购买：</p>
<img src="/why-do-we-need-domain-modeling/ad.jpeg" class="">


]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>Architecture</tag>
        <tag>Design</tag>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>TDD编码实战讲义</title>
    <url>/handout-tdd-code-kata/</url>
    <content><![CDATA[<img src="/handout-tdd-code-kata/logo.jpg" class="">

<blockquote>
<p><strong>说明：</strong>本讲义是我在ThoughtWorks作为咨询师时，为客户开展TDD Code Kata而编写。案例为Guess Number，案例需求来自当时的同事王瑜珩。当时，我们共同在ThoughtWorks的Zynx交付团队，为培养团队TDD能力进行训练时，引入了本案例。讲义中给出的代码问题则来自客户方的受训学员，可谓“真实的代码坏味道”。个人认为TDD不只是开发方法，还应该是设计方法，因此讲义中包含了诸多设计原理、思想和原则。</p>
</blockquote>
<span id="more"></span>

<h2 id="目标收益"><a href="#目标收益" class="headerlink" title="目标收益"></a>目标收益</h2><ul>
<li>熟悉IDE快捷键；</li>
<li>掌握TDD基本知识；</li>
<li>识别代码坏味道，熟练运用重构手法；</li>
<li>熟悉JUnit与Mockito框架；</li>
<li>了解Google Guice框架；</li>
</ul>
<h2 id="整体需求"><a href="#整体需求" class="headerlink" title="整体需求"></a>整体需求</h2><p>实现猜数字的游戏。游戏有四个格子，每个格子有一个0到9的数字，任意两个格子的数字都不一样。你有6次猜测的机会，如果猜对则获胜，否则失败。每次猜测时需依序输入4个数字，程序会根据猜测的情况给出xAxB的反馈，A前面的数字代表位置和数字都对的个数，B前面的数字代表数字对但是位置不对的个数。</p>
<p>例如：答案是1 2 3 4， 那么对于不同的输入，有如下的输出</p>
<table>
<thead>
<tr>
<th>输入</th>
<th>输出</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1 5 6 7</td>
<td>1A0B</td>
<td>1位置正确</td>
</tr>
<tr>
<td>2 4 7 8</td>
<td>0A2B</td>
<td>2和4位置都不正确</td>
</tr>
<tr>
<td>0 3 2 4</td>
<td>1A2B</td>
<td>4位置正确，2和3位置不正确</td>
</tr>
<tr>
<td>5 6 7 8</td>
<td>0A0B</td>
<td>没有任何一个数字正确</td>
</tr>
<tr>
<td>4 3 2 1</td>
<td>0A4B</td>
<td>4个数字位置都不对</td>
</tr>
<tr>
<td>1 2 3 4</td>
<td>4A0B</td>
<td>胜出  全中</td>
</tr>
<tr>
<td>1 1 2 3</td>
<td>输入不正确，重新输入</td>
<td></td>
</tr>
<tr>
<td>1 2</td>
<td>输入不正确，重新输入</td>
<td></td>
</tr>
</tbody></table>
<p>答案在游戏开始时随机生成。输入只有6次机会，在每次猜测时，程序应给出当前猜测的结果，以及之前所有猜测的数字和结果以供玩家参考。输入界面为控制台（Console），以避免太多与问题无关的界面代码。输入时，用空格分隔数字。</p>
<h2 id="任务分解"><a href="#任务分解" class="headerlink" title="任务分解"></a>任务分解</h2><p>TDD的一个重要步骤是在分析需求之后，对其进行任务分解。每个任务相当于一个功能点，它们都是可以验证的。在进行TDD时，可以根据具体情况，对任务再进行分解，或者增加一些我们之前未曾发现的任务。</p>
<hr>
<h4 id="练习：分解任务"><a href="#练习：分解任务" class="headerlink" title="练习：分解任务"></a>练习：分解任务</h4><p>我们对Guess Number分解的任务为：</p>
<ul>
<li>随机生成答案</li>
<li>判断每次猜测的结果</li>
<li>检查输入是否合法</li>
<li>记录并显示历史猜测数据</li>
<li>判断游戏结果。判断猜测次数，如果满6次但是未猜对则判负；如果在6次内猜测的4个数字值与位置都正确，则判胜 </li>
</ul>
<hr>
<h4 id="讨论：选择开始的任务"><a href="#讨论：选择开始的任务" class="headerlink" title="讨论：选择开始的任务"></a>讨论：选择开始的任务</h4><p>在分解好任务开始测试驱动开发时，我们应该优先选择哪一个任务？ 选择的标准包括：</p>
<ul>
<li>任务的依赖性</li>
<li>任务的重要性</li>
</ul>
<p>从依赖的角度看，并不一定需要优先选择前序任务，因为我们可以使用Mock的方式驱动出当前任务需要依赖的接口，而不用考虑实现。例如，“随机生成答案”任务与“判断每次猜测的结果”任务之间存在前后序的依赖关系，但实现的顺序却并不需要按照此顺序。</p>
<p>对于任务的重要性，主要是判断任务是否整个系统（模块）的核心功能。一个判断标准是确定任务是功能的主要流程还是异常流程。例如任务“检查输入是否合法”即为异常流程，可以考虑后做。</p>
<hr>
<h2 id="测试驱动开发"><a href="#测试驱动开发" class="headerlink" title="测试驱动开发"></a>测试驱动开发</h2><h3 id="开始第一个任务"><a href="#开始第一个任务" class="headerlink" title="开始第一个任务"></a>开始第一个任务</h3><p>我们认为，任务“判断每次的猜测结果”可以作为起始的核心任务。</p>
<h4 id="任务：判断每次的猜测结果"><a href="#任务：判断每次的猜测结果" class="headerlink" title="任务：判断每次的猜测结果"></a>任务：判断每次的猜测结果</h4><p>在进行测试驱动时，选择好任务后，就需要对测试用例进行分析。可以假设该任务就是你要实现的一个完整功能，然后从外部调用的角度去思考用例。这体现为两个方面：</p>
<ul>
<li>选择测试样本；</li>
<li>驱动承担该职责的对象，根据意图设计接口；</li>
</ul>
<p>选择测试样本的方法请参考实例化需求。例如，这里可以选择全中或全错等样本。通常情况下，编写的第一个测试应该选择最简单的样本。</p>
<hr>
<h4 id="知识：Specification-By-Example"><a href="#知识：Specification-By-Example" class="headerlink" title="知识：Specification By Example"></a>知识：Specification By Example</h4><p>由Gojko Adzic的著作Specification By Example（实例化需求），介绍了如何通过实例去分析和沟通需求。它是一组过程模式，可以协助软件产品的变更，确保有效地交付正确的产品。实例化需求的过程分为：</p>
<ul>
<li>从目标中获取范围</li>
<li>用实例进行描述</li>
<li>精炼需求说明</li>
<li>自动化验证，无须改变需求说明</li>
<li>频繁验证</li>
<li>演进出一个文档系统</li>
</ul>
<p>更多内容，请参考该书。</p>
<hr>
<p><strong>注意：单元测试不能针对方法编写测试，而应根据业务编写测试用例。一个测试方法只能做一件事情，代表一个测试样本和一个业务规则。</strong></p>
<hr>
<h4 id="思考：测试驱动开发的驱动力"><a href="#思考：测试驱动开发的驱动力" class="headerlink" title="思考：测试驱动开发的驱动力"></a>思考：测试驱动开发的驱动力</h4><p>设计接口是体现测试驱动开发“驱动力”的重要一点。之所以先编写测试，就是希望开发人员<strong>站在调用者的角度去思考</strong>，即所谓“<strong>意图导向编程</strong>”。从调用的角度思考，可以驱动我们思考并达到如下目的： </p>
<ul>
<li>如何命名被测试类以及方法，才能更好地表达设计者的意图，使得测试具有更好的可读性；</li>
<li>被测对象的创建必须简单，这样才符合测试哲学，从而使得设计具有良好的可测试性；</li>
<li>测试使我们只关注接口，而非实现；</li>
</ul>
<hr>
<h4 id="知识：Given-When-Then模式"><a href="#知识：Given-When-Then模式" class="headerlink" title="知识：Given-When-Then模式"></a>知识：Given-When-Then模式</h4><p>在编写测试方法时，应遵循Given-When-Then模式，这种方式描述了测试的准备，期待的行为，以及相关的验收条件。Given-When-Then模式体现了TDD对设计的驱动力：</p>
<ul>
<li>编写Given时，“驱动”我们思考被测对象的创建，以及它与其他对象的协作；</li>
<li>编写When时，“驱动”我们思考被测接口的方法命名，以及它需要接收的传入参数；考虑行为方式，究竟是<strong>命令式</strong>还是<strong>查询式</strong>方法(CQS原则)；</li>
<li>编写Then时，“驱动”我们分析被测接口的返回值；</li>
</ul>
<hr>
<h4 id="知识：CQS原则"><a href="#知识：CQS原则" class="headerlink" title="知识：CQS原则"></a>知识：CQS原则</h4><p>CQS原则，即命令-查询分离原则（Command-Query Separation），是指一个函数要么是一个命令来执行动作，要么是一个查询来给调用者返回数据。但是不能两者都是。</p>
<hr>
<p>对于任务“判断每次的猜测结果”，我们<strong>首先要考虑由谁来执行此任务</strong>。从面向对象设计的角度来讲，这里的任务即“职责”，我们要找到职责的承担者。<strong>从拟人化的角度去思考所谓“对象”</strong>，就是要找到<strong>能够彻底理解（Understand）该职责的对象</strong>。遵循信息专家模式，大多数情况下，承担职责的对象常常是拥有与该职责相关信息的信息持有者，即所谓“信息专家”。 </p>
<hr>
<h4 id="知识：信息专家模式"><a href="#知识：信息专家模式" class="headerlink" title="知识：信息专家模式"></a>知识：信息专家模式</h4><p>信息专家模式（Information Expert）是GRASP模式中解决类的职责分配问题的最基本的模式。 </p>
<p><strong>问题：</strong></p>
<p>当我们为系统发现完对象和职责之后，职责的分配原则（职责将分配给哪个对象执行）是什么？</p>
<p><strong>解决方案：</strong></p>
<p>职责的执行需要某些信息（information），把职责分配给该信息的拥有者。换句话说，某项职责的执行需要某些资源，只有拥有这些资源的对象才有资格执行职责。</p>
<p><strong>优点：</strong></p>
<ul>
<li>信息的拥有者类同时就是信息的操作者类，可以减少不必要的类之间的关联。</li>
<li>各类的职责单一明确，容易理解。</li>
</ul>
<hr>
<h4 id="思考：寻找承担职责“判断每次的猜测结果”的对象"><a href="#思考：寻找承担职责“判断每次的猜测结果”的对象" class="headerlink" title="思考：寻找承担职责“判断每次的猜测结果”的对象"></a>思考：寻找承担职责“判断每次的猜测结果”的对象</h4><p>可能的答案：Game，Player，Round  </p>
<p>提示：应让学员充分思考承担职责的角色，不能在未经分析之前就开始编写测试，从而忽略测试带来的驱动力，甚至忘记一些基本的命名原则和面向对象设计思想。例如，学员可能会将被测类命名为<code>Guess</code>、<code>Check</code>，而被测方法也被命名为<code>guess()</code>、<code>check()</code>。</p>
<hr>
<h4 id="知识：命名规则"><a href="#知识：命名规则" class="headerlink" title="知识：命名规则"></a>知识：命名规则</h4><p><strong>类命名规则：</strong>测试类与被测类的命名应保持一致，通常情况下，测试类的名称为：被测类名称+Test后缀。例如这里的Game类为被测类，则测试类命名为GameTest。</p>
<p><strong>方法命名规则：</strong>测试方法应表述业务含义，这样就能使得测试类可以成为文档。测试方法可以足够长，以便于清晰地表述业务。为了更好地辨别方法名表达的含义，ThoughtWorks提倡用Ruby风格的命名方法，即下划线分隔方法的每个单词，而非Java传统的驼峰风格。建议测试方法名以should开头，此时，默认的主语为被测类。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_0A0B_when_no_number_guessed_correctly</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//...     </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的方法可以阅读为：Game should return 0A0B when no number guessed correctly。显然，这是一条描述了业务规则的自然语言。 </p>
<hr>
<p>现在编写测试。由于事先已经明确被测类为Game，编写测试的Given部分，让我们思考如何创建Game对象？是否可以简单地创建？ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Game game = <span class="keyword">new</span> Game(); </span><br></pre></td></tr></table></figure>

<p>分析任务，需要判断猜测结果，则必然要求获知游戏的答案。这个答案与Game的关系是什么呢？这里产生的驱动力是如何创建Game对象？为了创建该对象，需要提供哪些准备？这使得我们驱动出<code>Answer</code>类的定义。 </p>
<h4 id="讨论：由4个数字组成的答案是否需要封装？"><a href="#讨论：由4个数字组成的答案是否需要封装？" class="headerlink" title="讨论：由4个数字组成的答案是否需要封装？"></a>讨论：由4个数字组成的答案是否需要封装？</h4><p>学员容易写出的代码，以如下方式表现答案(Answer)： </p>
<ul>
<li>整数数组 </li>
<li>整数类型的可变参数 </li>
<li>字符串 </li>
</ul>
<p>第一种方式除了缺乏对整数值的限制外，一个问题还在于暴露了实现细节。第二种方式甚至无法对答案的个数进行限制。第三种方式则与输入有关，使得Game类还要承担解析输入字符串的职责，违背了单一职责原则（说明：在后面，我们为Answer类提供了工厂方法，可以将传入的字符串解析为Answer对象，也即是由Answer承担解析输入字符串的职责，这同时也遵循“信息专家模式”。） </p>
<hr>
<h4 id="思考：Answer的定义"><a href="#思考：Answer的定义" class="headerlink" title="思考：Answer的定义"></a>思考：Answer的定义</h4><p>我们可以从如何构造一个Answer对象着手，看看该如何定义<code>Answer</code>类。  </p>
<h4 id="知识：单一职责原则"><a href="#知识：单一职责原则" class="headerlink" title="知识：单一职责原则"></a>知识：单一职责原则</h4><p>由Robert Martin提出，该原则指出：就一个类而言，应该只专注于做一件事和仅有一个引起变化的原因。</p>
<hr>
<p>编写When可以帮助开发者思考类的行为。一定要从业务而非实现的角度去思考接口。例如： </p>
<ul>
<li>实现角度的设计：<code>check()</code> </li>
<li>业务角度的设计：<code>guess()</code>  </li>
</ul>
<p>注意两个方法命名表达意图的不同。 </p>
<p>编写Then实际上是考虑如何验证。没有任何验证的测试不能称其为测试。由于该任务为判断输入答案是否正确，并获得猜测结果，因而必然需要返回值。从需求来看，只需要返回一个形如xAxB的字符串即可。</p>
<hr>
<h4 id="思考：是否需要将猜测结果封装为类？"><a href="#思考：是否需要将猜测结果封装为类？" class="headerlink" title="思考：是否需要将猜测结果封装为类？"></a>思考：是否需要将猜测结果封装为类？</h4><p>至少就目前而言，并没有必要。因为从需求来看，仅仅需要返回一个形如xAxB的字符串而言。这是需要遵循简单设计的要求，不必过度设计。</p>
<hr>
<p>如前所述，任务“判断每次的猜测结果”存在多个测试样本，例如一个都不对，或者全部正确，又或者值正确而位置不正确等，因而需要编写多个测试。在编写第一个测试时，可以简单实现使得测试快速通过，然后随着多个测试的编写，再驱动出检查输入数值的算法。</p>
<p>根据以上的分析，我们编写的第一个测试如下所示，它遵循了Given-When-Then模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span>    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_return_0A0B_when_no_number_is_correct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//given</span></span><br><span class="line">    Answer actualAnswer = Answer.createAnswer(<span class="string">&quot;1 2 3 4&quot;</span>);        </span><br><span class="line">    Game game = <span class="keyword">new</span> Game(actualAnswer);        </span><br><span class="line">    Answer inputAnswer = Answer.createAnswer(<span class="string">&quot;5 6 7 8&quot;</span>);      </span><br><span class="line"></span><br><span class="line">     <span class="comment">//when        </span></span><br><span class="line">     String result = game.guess(inputAnswer);        </span><br><span class="line"></span><br><span class="line">    <span class="comment">//then        </span></span><br><span class="line">    assertThat(result , is(<span class="string">&quot;0A0B&quot;</span>));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个测试已经驱动出了<code>Answer</code>的创建，<code>Game</code>类的定义，<code>guess()</code>接口的定义。在保证编译通过后，应该首先运行该测试。此时测试必然是失败的。为了使该测试快速通过，我们可以简单实现guess()方法，例如直接返回“0A0B”字符串。接着，就可以编写第二个测试。</p>
<hr>
<h4 id="思考：为何要先运行一个失败的测试？"><a href="#思考：为何要先运行一个失败的测试？" class="headerlink" title="思考：为何要先运行一个失败的测试？"></a>思考：为何要先运行一个失败的测试？</h4><p>首先，它能够保证测试框架是没有问题的；其次，它可以避免偶然的成功，因为测试通过不等于实现一定是正确的。</p>
<hr>
<p>在编写第二个测试时，由于测试样本与之前的测试完全不一样，之前的简单实现就不能满足新增的测试了。事实上，测试就是要去验证实现逻辑，这其中最重要的测试目标就是分支。不同的分支可能会返回不同的结果，如果我们根据分支来设计测试，就能有效保障实现的正确性。这称为“三角测试法”。</p>
<p>常见问题：</p>
<ul>
<li>没有将测试代码看做是代码的一部分。当编写多个测试方法时，没有及时重构；例如，应及时将<code>game</code>对象与<code>actualAnswer</code>对象提取为字段，以避免不必要的声明。</li>
<li>直接暴露表达式，而未对表达式进行方法提取，以表达业务意义；</li>
<li><code>guess()</code>方法过长；应该通过提取方法来改进代码的可读性；</li>
<li><code>Game</code>类与<code>Answer</code>类的职责分配不合理，将<code>Answer</code>类设计为仅具有<code>get()</code>和<code>set()</code>的数据对象，而将判断数值是否正确、位置是否正确的逻辑分配给了<code>Game</code>。没有考虑<code>get()</code>和<code>set()</code>是否真正有必要；如果我们对<code>guess()</code>方法进行了方法提取，可以识别出代码的坏味道“Feature Envy”，即<code>Game</code>的方法用到的都是<code>Answer</code>的属性。这时，应该采用移动方法的重构手法对其进行重构。</li>
</ul>
<h3 id="开始第二个任务"><a href="#开始第二个任务" class="headerlink" title="开始第二个任务"></a>开始第二个任务</h3><p>我们选择的第二个任务为“随机生成答案”，这是一个独立的职责。编写测试类时，很容易驱动出AnswerGenerator类。关键在于，我们该如何编写单元测试来验证生成的结果。我们对结果的要求是： </p>
<ul>
<li>数字必须是0…9之间； </li>
<li>产生的四个数字不能相同； </li>
</ul>
<hr>
<h4 id="讨论：究竟由谁来承担“随机生成答案”的职责？"><a href="#讨论：究竟由谁来承担“随机生成答案”的职责？" class="headerlink" title="讨论：究竟由谁来承担“随机生成答案”的职责？"></a>讨论：究竟由谁来承担“随机生成答案”的职责？</h4><p>学员容易将此职责直接分配给<code>Answer</code>。然而，随机生成答案与创建一个答案适用于不同的场景，这对于<code>Answer</code>的调用者而言，并不友好。尤其对于只需要答案的场景，还需要无端地引入对随机数的依赖，显然是不合理的。 </p>
<hr>
<p>编写测试方法的过程与前相似，仍然按照Given-When-Then模式来编写（若测试方法比较简单，可以不遵循这一模式，但思考的过程却应该按照该模式）。</p>
<p>在编写then部分的测试时，可能出现疑问。 </p>
<p><strong>问题：如何验证生成的答案是否正确？</strong></p>
<p>我们已经将答案建模为<code>Answer</code>，因此<code>AnswerGenerator</code>的generate()方法要返回的对象类型为<code>Answer</code>。那么，我们怎么知道返回的<code>Answer</code>对象是合法的呢？一种做法是获取Answer的属性，然后再进行验证。那么，<strong>为了测试的验证而暴露这些属性，是否适合</strong>？  </p>
<p>要完成对答案正确性的验证，直接暴露答案的属性是不妥当的，至少目前没有获取答案属性的需求。我们的做法是定义一个验证方法。这是否仍然属于为测试而定义行为的做法呢？这个问题有点像鸡与鸡蛋的哲学问题。<strong>我们应该还原到设计，看看这种手法是否改善了设计</strong>，如此即可。毕竟，这种对答案正确性的校验，也可以说是业务逻辑的一种。</p>
<p><strong>说明：</strong>在开始编写“检查输入是否合法”任务时，你会发现，这里所谓多余的验证，就会派上用场。 </p>
<p>这个验证方法可以是单纯的返回true或者false，但从需求来看，这个返回结果并没有很好地展现验证要求：究竟是因为数字超出了范围，还是出现了相同的数字？我个人更倾向于用自定义异常来表示生成的答案违背了这两条规则。因此，我们可以为<code>Answer</code>定义一个<code>validate()</code>方法，以验证生成的Answer是否满足规则要求；如果不符合，就抛出对应的异常。</p>
<hr>
<h4 id="知识：JUnit中对异常的验证"><a href="#知识：JUnit中对异常的验证" class="headerlink" title="知识：JUnit中对异常的验证"></a>知识：JUnit中对异常的验证</h4><p>随着JUnit版本的演化，先后提供了三种验证异常的机制。</p>
<ul>
<li>一种是传统的在测试代码中通过编写<code>try... catch</code>结合<code>fail()</code>方法进行验证。这种方法带来的问题是验证逻辑太繁琐。</li>
<li>第二种方法是利用<code>@Test</code>的<code>expected</code>方法，通过指定异常类型值来验证。它的好处是简单直接，缺点是只能验证抛出异常的类型。</li>
<li>第三种方法是利用ExpectedException Rule。Rule可以更灵活地验证异常，包括异常类型和异常消息。我们也可以通过定义派生自<code>TypeSafeMatcher</code>的<code>Matcher</code>类，来验证异常的更多信息。</li>
</ul>
<hr>
<p><strong>问题：如何确定测试通过就意味着实现正确？</strong></p>
<p>第二个任务看似简单，实则不然。原因在于这里产生了一个随机数。随机数带来了不确定性，它可能偶然地让测试通过了。也许，运行测试100次，前面的99次都通过了，最后一次失败，仍然视为失败。</p>
<p>生成随机数自然是调用Java的JDK。<strong>在单元测试环节中，倘若我们要测试的单元需要调用别的API，则在这个测试中，我们可以假定这个API是正确的。</strong>我们对Java JDK的正确性自然信心十足。那么，为何我们还要考虑测试的随机失败？这是因为在这个任务的测试中，我们测试的并非随机数的生成逻辑，而在于随机数的种子是否恰当，实现逻辑中是否判断了可能出现的错误数字？</p>
<p>由于生成随机数的逻辑并非确定无疑的，测试时我们就不能依赖于它。这正是Mock可以派上用场的时候。为此，我们需要将生成随机数的功能提取为类<code>RandomIntGenerator</code>，再注入到<code>AnswerGenerator</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnswerGenerator</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> RandomIntGenerator randomIntGenerator;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnswerGenerator</span><span class="params">(RandomIntGenerator randomIntGenerator)</span> </span>&#123;         </span><br><span class="line">        <span class="keyword">this</span>.randomIntGenerator = randomIntGenerator;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类的实现调用了Java提供的<code>Random</code>类，但在测试时，我们却可以通过Mock它的行为，使得返回的结果变为确定的数字：     </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test(expected = OutOfRangeAnswerException.class)</span>     </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_throw_OutOfRangeAnswerException_which_is_not_between_0_and_9</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">    RandomIntGenerator randomIntGenerator = mock(RandomIntGenerator.class);         </span><br><span class="line">    when(randomIntGenerator.nextInt()).thenReturn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>);         </span><br><span class="line">    AnswerGenerator answerGenerator = <span class="keyword">new</span> AnswerGenerator(randomIntGenerator);</span><br><span class="line"></span><br><span class="line">    answerGenerator.generate(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<hr>
<h4 id="重构：组合Game与AnswerGenerator"><a href="#重构：组合Game与AnswerGenerator" class="headerlink" title="重构：组合Game与AnswerGenerator"></a>重构：组合Game与AnswerGenerator</h4><p>在实现第一个任务时，我们定义的Game接受了Answer对象作为游戏的答案。现在，我们定义了AnswerGenerator用以生成符合条件的随机答案。我们当然可以在调用该对象的generate()方法生成答案后，再将该答案作为构造函数参数传递给Game对象。但更好的做法是直接将AnswerGenerator作为构造函数参数传递给Game，在其内部调用它的generate()方法。</p>
<h3 id="开始第三个任务"><a href="#开始第三个任务" class="headerlink" title="开始第三个任务"></a>开始第三个任务</h3><p>之所以将“验证输入是否合法”放在第三个任务，是因为它不属于happy path的范畴。它属于辅助业务，重要性相对次之。</p>
<p><strong>提示：</strong>对于第三个任务，可以采用Specification By Example的方式来考虑测试用例。</p>
<p><strong>问题：参数 vs. 字段</strong></p>
<p>学员在定义执行该任务的类时，一种可能性是将输入的答案作为类的构造函数参数。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> InputValidator(<span class="string">&quot;1 2 3 5&quot;</span>).validate();</span><br></pre></td></tr></table></figure>

<p>存在两个错误：</p>
<ul>
<li>错误地判断了输入值的生命周期。什么内容应该放在构造函数中作为参数？换言之，构造函数参数与对象之间的关系是什么？之所以要作为构造函数参数，就是意味着在某种场景下这些参数值应该在创建该对象时就存在。这些参数值与对象“生死与共”，它们的生命周期是保持一致的。如果不是，就不应该作为构造函数的参数。你觉得输入应该作为构造函数吗？如果我要验证另一条输入应该怎么办？再创建一个<code>InputValidator</code>对象吗？</li>
<li>违反了阅读直觉。<code>validate()</code>方法验证谁？验证空吗？显然这样的接口违反了主-谓-宾的语法。</li>
</ul>
<p><strong>问题：封装的Answer与输入</strong></p>
<p>既然已经封装了Answer对象，为何<code>validate()</code>方法还是要接收字符串类型的输入？阅读需求，已可寻求到答案。</p>
<p><strong>问题：引入<code>InputValidator</code>类型是否有必要？</strong></p>
<p>多数人会认为这里的验证逻辑与Answer相关，根据前面提到的“信息专家模式”，似乎应该将验证逻辑放到Answer中。然而，这里的需求明确地表示了，如果输入不符合要求，就不允许创建该Answer，而是抛出异常。所以，这里的部分验证逻辑是在创建Answer之前就应该存在，当然就不应该由Answer承担了。</p>
<p>针对第三个任务，验证结果的逻辑不应该由boolean型或错误码来表现。对于表达一种错误规则来说，如果你将其看做是一种业务规则，最好的表达方式是采用自定义异常，除非这门语言允许返回两个值（例如Go语言支持返回多个字，但并不支持异常）。对此，在第二个任务中已有描述，这里不再赘述。</p>
<hr>
<h4 id="重构：Answer的验证逻辑"><a href="#重构：Answer的验证逻辑" class="headerlink" title="重构：Answer的验证逻辑"></a>重构：Answer的验证逻辑</h4><p>在开发第二个任务时，我们已经在<code>Answer</code>类中定义了<code>validate()</code>方法。现在，<code>InputValidator</code>类又提供了<code>validate()</code>方法，且其中部分逻辑是相同的。在实现时，应该如何重构现有代码？</p>
<hr>
<h3 id="开始第四个任务"><a href="#开始第四个任务" class="headerlink" title="开始第四个任务"></a>开始第四个任务</h3><p>还剩下两个任务：</p>
<ul>
<li>记录并显示历史猜测数据</li>
<li>判断游戏结果</li>
</ul>
<p>究竟应该选择哪一个任务作为第四个任务，并没有定论。从业务逻辑看，“判断游戏结果”任务更重要，它才是整个游戏的核心逻辑。可从技术实现看，“判断游戏结果”可以依赖“记录并显示历史猜测数据”。因为分析“判断游戏结果”任务，实际上做了两件事：其一是判断猜测次数是否超过指定的6次；其二是判断每次猜测的结果。第二件事已经被我们开发的第二个任务覆盖。而对于测试次数而言，如果我们记录了历史猜测数据，那么这个次数也可以唾手可得。</p>
<hr>
<h4 id="讨论：测试驱动开发需要事先设计吗？"><a href="#讨论：测试驱动开发需要事先设计吗？" class="headerlink" title="讨论：测试驱动开发需要事先设计吗？"></a>讨论：测试驱动开发需要事先设计吗？</h4><p>Martin Fowler的文章Is Design Dead?其实就是对此问题的正本清源。由于测试驱动开发提倡“测试先行，简单设计”，许多人就误认为TDD不需要设计，以讹传讹之下，甚至导致许多优秀的设计者抛弃了设计去实践TDD，最后得出TDD不可行的结论。</p>
<p>我个人认为，<strong>视场景而定，测试驱动开发仍可进行事先设计</strong>。设计并不仅包含技术层面的设计如对OO思想乃至设计模式的运用，它本身还包括对需求的分析与建模。若不分析需求就开始编写测试，就好像没有搞清楚要去的地方，就开始快步前行，最后发现南辕北辙。测试驱动开发提倡的任务分解，实际上就是一种需求的分析。而如何寻找职责，以及识别职责的承担者则可以视为建模设计。测试驱动更像是一种培养设计专注力的手段，就像冥想者通过盘腿静坐的手段来体悟天地一样，测试驱动可以强迫你站在测试的角度（就是使用者的角度）去思考接口，如此才能设计出表现意图的接口。但编写测试自身并不能取代设计，正如盘腿静坐并不等于就是冥想。</p>
<p>在开始测试驱动开发之前，做适度的事先设计，还有利于我们仔细思考技术实现的解决方案。它与测试驱动接口的设计并不相悖。解决方案或许属于实现层面，若过早思考实现，会干扰我们对接口的判断；但完全不理会实现，又可能导致设计方向的走偏。举例来说，如果我们要实现XML消息到Java对象的转换。一种解决方案是通过jaxb将消息转换为Java对象，然后再定义转换映射的<code>Transformer</code>，通过硬编码或者反射的方式将其转换为相关的领域对象。然后在执行了业务操作后，再将返回的结果转换为另一个Jaxb对象。而另一种解决方案则是通过引入模板，例如StringTemplate或者Velocity，定义转换的模板，然后进行替换实现。这两种解决方案的区别，直接影响了我们划分任务的方式。</p>
<hr>
<p>我们选择“记录并显示历史猜测数据”作为第四个任务。同样，对于此任务，我们要事先考虑清楚，究竟应该由谁来承担这个职责？恩，注意，这里其实包含了两项任务：记录与显示。当我们看到类似“和”、“或者”等并列连接词时，都应该思考它是否表达了多个职责？因此，对于第四个任务，我们应该稍稍拆分一下，分解成两个任务：</p>
<ul>
<li>记录历史猜测数据；</li>
<li>显示历史猜测数据；</li>
</ul>
<p>那么应该谁来“记录历史猜测数据”？我们应该寻找承担该职责的对象。</p>
<hr>
<h4 id="知识：寻找职责的承担者"><a href="#知识：寻找职责的承担者" class="headerlink" title="知识：寻找职责的承担者"></a>知识：寻找职责的承担者</h4><p>寻找职责的承担者，其实就是寻找某个可以承担该职责的角色。角色又是什么？想象我们现实世界中的角色。看看我们身边，是否角色遍地可寻？BA角色负责分析需求，DEV角色负责实现功能，QA角色负责测试功能是否正确，PM角色负责管理整个项目的进度与项目成员。我们是依据什么来划分角色的？——能力。能力的体现是什么？除了诸多素质要求，最直接的体现就是“知识”。因此，所谓“角色”，就是拥有了相关“知识”从而具有相关“能力”的人。</p>
<hr>
<p>什么角色应该记录历史猜测数据呢？那就是要寻找谁具有记录历史猜测数据的能力。于是推之于知识，就是谁拥有每一次猜测的数据。显然，<code>Game</code>拥有当前猜测的数据，因此承担责任的应该为<code>Game</code>。</p>
<p>现在，开始编写测试。既然已经辨别出<code>Game</code>对象，就应该针对它编写测试方法，让我们还是从测试方法的业务逻辑描述开始吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameTest</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Answer actualAnswer = Answer.createAnswer(<span class="string">&quot;1 2 3 4&quot;</span>);     </span><br><span class="line">    <span class="keyword">private</span> Game game;     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;         </span><br><span class="line">        AnswerGenerator answerGenerator = mock(AnswerGenerator.class);         </span><br><span class="line">        when(answerGenerator.generate()).thenReturn(actualAnswer);         </span><br><span class="line">        game = <span class="keyword">new</span> Game(answerGenerator);     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_record_every_guess_result</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        game.guess(Answer.createAnswer(<span class="string">&quot;2 1 6 7&quot;</span>));       </span><br><span class="line">        game.guess(Answer.createAnswer(<span class="string">&quot;1 2 3 4&quot;</span>));       </span><br><span class="line"></span><br><span class="line">        List&lt;GuessResult&gt; guessHistory = game.guessHistory();         </span><br><span class="line"></span><br><span class="line">        assertThat(guessResults.size(), is(<span class="number">2</span>));         </span><br><span class="line">        assertThat(guessResults.get(<span class="number">0</span>).result(), is(<span class="string">&quot;0A2B&quot;</span>));         </span><br><span class="line">        assertThat(guessResults.get(<span class="number">0</span>).inputAnswer().toString(), is(<span class="string">&quot;2 1 6 7&quot;</span>));         </span><br><span class="line">        assertThat(guessResults.get(<span class="number">1</span>).result(), is(<span class="string">&quot;4A0B&quot;</span>));         </span><br><span class="line">        assertThat(guessResults.get(<span class="number">1</span>).inputAnswer().toString(), is(<span class="string">&quot;1 2 3 4&quot;</span>));     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，实际上我驱动出了<code>Game</code>的<code>guessHistory()</code>方法，同时还得到了一个封装了猜测结果的<code>GuessResult</code>对象。与第一个任务不同的是，我没有使用字符串来表示猜测结果，这是因为这里的历史猜测数据不仅包含了猜测结果，还包含了当前的测测数据。</p>
<p>现在，应该考虑“显示历史猜测记录”的任务了。这个功能就是要在猜测了数字之后，在控制台显示历史猜测记录。虽然是控制台，我们仍然认为这属于界面的工作。<strong>TDD根本就不应该用来驱动界面设计</strong>，还是将注意力放到业务逻辑上来吧。抛开界面，这里的逻辑就转换为：</p>
<ul>
<li>当用户猜测了数字后，应该显示历史猜测记录。</li>
</ul>
<p>将界面与业务逻辑分开体现了“关注点分离”原则，也是表现层设计的常用做法。最常见的处理界面设计的模式就是MVC模式。因此在这里可以引入<code>GameController</code>类，就目前而言，它可以负责<code>Game</code>与<code>GameView</code>的协作，所以相应的还可以为界面显示定义一个专属的View对象。</p>
<p>虽然在这里是用控制台显示历史猜测数据信息，实现非常简单，直接调用<code>System.out.println()</code>方法即可，然而我们却很难测试控制台是否显示了该信息。虽然有一些框架也提供了Mock控制台的功能，但就TDD而言，这样的测试并无实际意义。<strong>我们需要合理地辨别在功能实现中，哪些内容适合编写自动化测试，哪些内容适合人工测试。</strong>因此，这里可以引入Mock框架来模拟<code>GameView</code>，我们只需验证<code>Controller</code>与<code>View</code>之间的协作即可。这时，测试还有助于我们设计出可测试性好的类。</p>
<p>因为是<code>Controller</code>，需要接受用户输入，而非直接传入答案的字符串值。同理，我们在TDD中也不可能测试业务逻辑与控制台的交互。因此，同样需要引入<code>InputCommand</code>类型来封装输入逻辑，然后以Mock框架来模拟<code>InputCommand</code>。 故而，我们为该功能编写的测试为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameControllerTest</span> </span>&#123;     </span><br><span class="line">    <span class="meta">@Mock</span>     </span><br><span class="line">    <span class="keyword">private</span> GameView mockGameView;     </span><br><span class="line">    <span class="meta">@Mock</span>     </span><br><span class="line">    <span class="keyword">private</span> InputCommand mockCommand;     </span><br><span class="line">    <span class="meta">@Mock</span>     </span><br><span class="line">    <span class="keyword">private</span> AnswerGenerator mockGenerator;     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Game game;     </span><br><span class="line">    <span class="keyword">private</span> Answer correctAnswer;     </span><br><span class="line">    <span class="keyword">private</span> Answer errorAnswer;     </span><br><span class="line">    <span class="keyword">private</span> GameController gameController;     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;         </span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);      </span><br><span class="line">   </span><br><span class="line">        correctAnswer = Answer.createAnswer(<span class="string">&quot;1 2 3 4&quot;</span>);         </span><br><span class="line">        errorAnswer = Answer.createAnswer(<span class="string">&quot;1 2 5 6&quot;</span>);   </span><br><span class="line">      </span><br><span class="line">        when(mockGenerator.generate()).thenReturn(correctAnswer);         </span><br><span class="line">        game = <span class="keyword">new</span> Game(mockGenerator);         </span><br><span class="line">        gameController = <span class="keyword">new</span> GameController(game, mockGameView);     </span><br><span class="line">    &#125;         </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_display_guess_history_message_when_guess_number_twice</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">        <span class="comment">//given         </span></span><br><span class="line">        when(mockCommand.input()).thenReturn(errorAnswer);         </span><br><span class="line">        GameController gameController = <span class="keyword">new</span> GameController(game, mockGameView);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//when         </span></span><br><span class="line">        gameController.play(mockCommand);         </span><br><span class="line"></span><br><span class="line">        <span class="comment">//then       </span></span><br><span class="line">        verify(mockGameView).showGuessHistory(anyList());     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编写该测试之前，我们实则做了一部分设计与分析工作，辨别各种职责以及承担这些职责的对象，尤其重要的是，要分辨出它们之间的协作方式。对协作的分析应以被测对象为主。一旦分析清楚，就应该编写测试，通过测试来驱动对象之间的协作方式。在编写的测试中，参与协作的其他对象都可以通过Mock来模拟，不一定要有实现，只需体现它们的接口即可。 </p>
<p>例如，在当前这个测试中，除了之前已经处理过的<code>Game</code>与<code>AnswerGenerator</code>之间的协作外，我主要考虑了<code>InputCommand</code>与<code>GameView</code>之间的协作方式，其中包括：三者之间的依赖注入，例如<code>GameView</code>作为构造函数的参数，因为一个<code>GameController</code>对象应对应一个<code>GameView</code>对象；而<code>InputCommand</code>则作为<code>play()</code>方法的输入参数。这里的<code>GameController</code>的接口就是通过测试驱动获得的。由于我们测试的是历史猜测结果是否显示，因此使用了Mockito框架的<code>verify</code>方法对这种对象之间的协作进行了验证。之所以在验证逻辑中没有验证具体的猜测结果是否正确，是因为这个逻辑已经在<code>Game</code>的测试中覆盖；而对于<code>GameController</code>，我们需要验证的逻辑只限于“是否显示历史猜测数据”，而非“显示了什么样的历史猜测数据”。 </p>
<p><strong>注意：</strong>这里创建了多个Mock对象，因此使用了Mockito提供的<code>@Mock</code>便捷方式来创建这些Mock对象。 </p>
<p><code>InputCommand</code>可以定义为接口，真正的控制台实现交给了<code>ConsoleInputCommand</code>类。实现如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleInputCommand</span> <span class="keyword">implements</span> <span class="title">InputCommand</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> BufferedReader bufferedReader;     </span><br><span class="line"></span><br><span class="line">    &#123;         </span><br><span class="line">        bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Answer <span class="title">input</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">        <span class="keyword">try</span> &#123;             </span><br><span class="line">            String inputAnswer = bufferedReader.readLine();             </span><br><span class="line">            <span class="keyword">return</span> Answer.createAnswer(inputAnswer);         </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;             </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());         </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="开始第五个任务"><a href="#开始第五个任务" class="headerlink" title="开始第五个任务"></a>开始第五个任务</h3><p>在开始编写测试之前，先要深入分析该任务表达的需求信息。“判断游戏结果。判断猜测次数，如果满6次但是未猜对则判负；如果在6次内猜测的4个数字值与位置都正确，则判胜。”实际上这里引入了对游戏猜测的控制逻辑，主要是对猜测次数的控制。这样的控制逻辑应该交给谁呢？ </p>
<p>多数时候，程序员容易将这样的控制逻辑放到主程序入口处，即main()函数中。这并非恰当的方式。一方面，这里的控制逻辑仍然属于业务逻辑的范畴，不应该暴露给调用者，同时也加大了调用者的负担；另一方面，倘若程序不再作为控制台程序时，例如编写Web Application，主程序入口的内容就要调整，甚至导致这一逻辑的重复。 </p>
<p>有了编写第四个任务作为基础，我们很容易判断出该控制逻辑应该交给<code>GameController</code>。编写测试也变得简单： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameControllerTest</span> </span>&#123;     </span><br><span class="line">    <span class="meta">@Test</span>     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_end_game_and_display_sucessful_message_when_number_is_correct_in_first_round</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">        <span class="comment">//given         </span></span><br><span class="line">        when(mockCommand.input()).thenReturn(correctAnswer);         </span><br><span class="line"></span><br><span class="line">        <span class="comment">//when       </span></span><br><span class="line">        gameController.play(mockCommand);         </span><br><span class="line"></span><br><span class="line">        <span class="comment">//then         </span></span><br><span class="line">        verify(mockCommand, times(<span class="number">1</span>)).input();         </span><br><span class="line">        verify(mockGameView).showMessage(<span class="string">&quot;successful&quot;</span>);     </span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">should_end_game_and_display_failure_message_once_times_reach_max_times</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">        <span class="comment">//given         </span></span><br><span class="line">        when(mockCommand.input()).thenReturn(errorAnswer);         </span><br><span class="line">        GameController gameController = <span class="keyword">new</span> GameController(game, mockGameView);         </span><br><span class="line"></span><br><span class="line">        <span class="comment">//when         </span></span><br><span class="line">        gameController.play(mockCommand);         </span><br><span class="line"></span><br><span class="line">        <span class="comment">//then         </span></span><br><span class="line">        verify(mockCommand, times(<span class="number">6</span>)).input();         </span><br><span class="line">        verify(mockGameView).showMessage(<span class="string">&quot;failed&quot;</span>);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的两个测试与第四个任务测试“显示历史猜测数据”任务的测试相似，唯一不同的是我们添加了对<code>InputCommand</code>协作的验证，并以Mockito提供的<code>times()</code>方法准确的验证了调用的次数。默认情况下，<code>verify</code>验证的次数为1，但我在第一个测试中仍然给出了times(1)，是希望在测试中明确的表示它被执行了一次。 </p>
<p>通过编写测试，我们驱动出了<code>GameController</code>、<code>InputCommand</code>与<code>GameView</code>之间的协作关系，并且还驱动出<code>showMessage()</code>方法。如果你觉得<code>showMessage()</code>方法的定义太过宽泛，也可以定义<code>showFailure()</code>和<code>showSuccess()</code>方法来体现这里表达的业务逻辑。 </p>
<p><code>GameController</code>的实现就变简单了： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameController</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_TIMES = <span class="number">6</span>;     </span><br><span class="line">    <span class="keyword">private</span> Game game;     </span><br><span class="line">    <span class="keyword">private</span> GameView gameView;     </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GameController</span><span class="params">(Game game, GameView gameView)</span> </span>&#123;         </span><br><span class="line">        <span class="keyword">this</span>.game = game;         </span><br><span class="line">        <span class="keyword">this</span>.gameView = gameView;     </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(InputCommand inputCommand)</span> </span>&#123;         </span><br><span class="line">        GuessResult guessResult;         </span><br><span class="line">        <span class="keyword">do</span> &#123;             </span><br><span class="line">            Answer inputAnswer = inputCommand.input();             </span><br><span class="line">            guessResult = game.guess(inputAnswer);             </span><br><span class="line">            gameView.showCurrentResult(guessResult);             </span><br><span class="line">            gameView.showGuessHistory(game.guessHistory());         </span><br><span class="line">        &#125; <span class="keyword">while</span> (!guessResult.correct() &amp;&amp; game.guessHistory().size() &lt; MAX_TIMES);  </span><br><span class="line">       </span><br><span class="line">        gameView.showMessage(guessResult.correct() ? <span class="string">&quot;successful&quot;</span> : <span class="string">&quot;failed&quot;</span>);         </span><br><span class="line">        gameView.showMessage(<span class="string">&quot;The correct number is &quot;</span> + game.actualAnswer());     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运用依赖注入框架"><a href="#运用依赖注入框架" class="headerlink" title="运用依赖注入框架"></a>运用依赖注入框架</h2><p>至此，我们的程序基本完成。我们定义并实现了各个参与协作的类，但是，我们需要管理类之间的依赖，组合这些相关的对象。由于我们采用了测试驱动，因此比较好的保证了各个类的可测试性，而达成可测试性的诀窍就是“依赖注入”。 </p>
<hr>
<h4 id="知识：依赖注入"><a href="#知识：依赖注入" class="headerlink" title="知识：依赖注入"></a>知识：依赖注入</h4><p>依赖注入模式体现了“面向接口设计”原则，即分离接口与实现，并通过构造函数注入、设值方法注入或接口注入等手法将外部依赖注入到一个类中，从而解除该类与它协作的外部类之间的依赖。具体类型参考Martin Fowler的文章Inversion of Control Containers and the Dependency Injection pattern(<a href="http://martinfowler.com/articles/injection.html)%E3%80%82">http://martinfowler.com/articles/injection.html)。</a></p>
<hr>
<p>在我们的例子中，主要通过构造函数注入的方式实现依赖注入。我们当然可以自己来组合这些类，但也可以运用现有的框架，例如Java平台下的Spring以及更轻量级的Guice(<a href="https://code.google.com/p/google-guice/)%E3%80%82">https://code.google.com/p/google-guice/)。</a> </p>
<p>在目前的设计中，我们仅仅针对<code>GameView</code>以及<code>InputCommand</code>进行了接口与实现分离。由于<code>InputCommand</code>是作为<code>play()</code>方法的传入参数，不在依赖管理范围之内。至于<code>RandomIntGenerator</code>以及<code>AnswerGenerator</code>则是通过类直接注入的，因此，我们仅需做如下调整。 </p>
<p>首先为那些运用了构造函数注入的类配置Guice提供的<code>@Inject</code>，如下所示： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnswerGenerator</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> RandomIntGenerator randomIntGenerator;     </span><br><span class="line">    <span class="meta">@Inject</span>     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnswerGenerator</span><span class="params">(RandomIntGenerator randomIntGenerator)</span> </span>&#123;         </span><br><span class="line">        <span class="keyword">this</span>.randomIntGenerator = randomIntGenerator;     </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> Answer actualAnswer;     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;GuessResult&gt; guessHistory;     </span><br><span class="line">    <span class="meta">@Inject</span>     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Game</span><span class="params">(AnswerGenerator answerGenerator)</span> </span>&#123;         </span><br><span class="line">        <span class="keyword">this</span>.actualAnswer = answerGenerator.generate();         </span><br><span class="line">        guessHistory = <span class="keyword">new</span> ArrayList&lt;GuessResult&gt;();     </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameController</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_TIMES = <span class="number">6</span>;     </span><br><span class="line">    <span class="keyword">private</span> Game game;     </span><br><span class="line">    <span class="keyword">private</span> GameView gameView;     </span><br><span class="line">    <span class="meta">@Inject</span>     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GameController</span><span class="params">(Game game, GameView gameView)</span> </span>&#123;         </span><br><span class="line">        <span class="keyword">this</span>.game = game;         </span><br><span class="line">        <span class="keyword">this</span>.gameView = gameView;     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>GameView</code>接口，在默认情况下，Guice框架并不知道该注入它的哪个实现类（即使此时只有一个实现类），因此需要创建一个Module，它派生自Guice提供的<code>AbstractModule</code>，能够将接口与实现类进行绑定： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuessNumberModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;     </span><br><span class="line">    <span class="meta">@Override</span>     </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;         </span><br><span class="line">        bind(GameView.class).to(ConsoleGameView.class);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在在<code>main()</code>函数中就无需进行繁琐的类型间组合，Guice框架会帮我们完成依赖对象之间的注入。唯一需要做的是创建一个<code>Injector</code>对象，通过它可以获得我们需要的<code>GameController</code>实例： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuessNumber</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;         </span><br><span class="line">        Injector injector = createInjector(<span class="keyword">new</span> GuessNumberModule());         </span><br><span class="line">        GameController gameController = injector.getInstance(GameController.class);</span><br><span class="line">        InputCommand command = <span class="keyword">new</span> ConsoleInputCommand();     </span><br><span class="line">    </span><br><span class="line">        System.out.println(<span class="string">&quot;Please input four numbers following by X X X X(0--9)&quot;</span>);         </span><br><span class="line">        gameController.play(command);     </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="TDD知识"><a href="#TDD知识" class="headerlink" title="TDD知识"></a>TDD知识</h2><h3 id="TDD核心"><a href="#TDD核心" class="headerlink" title="TDD核心"></a>TDD核心</h3><ul>
<li>红：测试失败 </li>
<li>绿：测试通过 </li>
<li>重构：优化代码和测试 </li>
</ul>
<h3 id="TDD三大定律"><a href="#TDD三大定律" class="headerlink" title="TDD三大定律"></a>TDD三大定律</h3><p>该定律由Robert Martin提出： </p>
<ul>
<li>没有测试之前不要写任何功能代码 </li>
<li>只编写恰好能够体现一个失败情况的测试代码 </li>
<li>只编写恰好能通过测试的功能代码 </li>
</ul>
<h3 id="FIRST原则"><a href="#FIRST原则" class="headerlink" title="FIRST原则"></a>FIRST原则</h3><ul>
<li>Fast: 测试要非常快，每秒能执行几百或几千个 </li>
<li>Isolated：测试应能够清楚的隔离一个失败</li>
<li>Repeatable：测试应可重复运行，且每次都以同样的方式成功或失败 </li>
<li>Self-verifying：测试要无歧义的表达成功或失败 </li>
<li>Timely：频繁、小规模的修改代码 </li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>OO</tag>
        <tag>Java</tag>
        <tag>TDD</tag>
      </tags>
  </entry>
</search>
